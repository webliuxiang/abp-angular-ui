/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.3.0.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/operator/finally';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_LOGMANAGER_BASE_URL = new InjectionToken<string>('API_LOGMANAGER_BASE_URL');

@Injectable()
export class FileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 根据文件token下载文件
     * @param token (optional) 
     * @return Success
     */
    downloadReport(token: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/File/DownloadReport?";
        if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadReport(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 查询租户是否可用，可能返回三种情况：NotFound、InActive（不活跃的）、Available
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * 输入为包含tenantId={value}字符串的加密文本，作用尚不明确
     * @param body (optional) 
     * @return Success
     */
    resolveTenantId(body: ResolveTenantIdInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResolveTenantId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResolveTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveTenantId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 将审计日志导出到表格AuditLogs.xlsx
     * @param startDate (optional) 开始时间
     * @param endDate (optional) 结束时间
     * @param userName (optional) 用户名
     * @param serviceName (optional) 服务名称
     * @param methodName (optional) 方法名称
     * @param browserInfo (optional) 浏览器信息
     * @param hasException (optional) 是否包含异常
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogsToExcel(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogsToExcel?";
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "serviceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "methodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "browserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "hasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "minExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "maxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * 获取被跟踪实体变更记录
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChanges(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChanges?";
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName !== undefined)
            url_ += "entityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEntityChangeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * 分页获取审计日志：用户操作接口的一系列信息
     * @param startDate (optional) 开始时间
     * @param endDate (optional) 结束时间
     * @param userName (optional) 用户名
     * @param serviceName (optional) 服务名称
     * @param methodName (optional) 方法名称
     * @param browserInfo (optional) 浏览器信息
     * @param hasException (optional) 是否包含异常
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPagedAuditLogs(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAuditLogListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetPagedAuditLogs?";
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "serviceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "methodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "browserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "hasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "minExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "maxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedAuditLogs(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedAuditLogs(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAuditLogListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAuditLogListDto>(<any>null);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 获取租户的用户
     * @param body (optional) 
     * @return Success
     */
    findUsers(body: CommonLookupFindUsersInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * 获取默认版本名称
     * @return Success
     */
    getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetDefaultEditionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultEditionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultEditionName(<any>response_);
                } catch (e) {
                    return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDefaultEditionNameOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDefaultEditionNameOutput>(<any>null);
    }

    /**
     * 获取验证码的有效类型
     * @return Success
     */
    getValidateCodeTypesForCombobox(): Observable<ListResultDtoOfComboboxItemDtoTOfInt32> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetValidateCodeTypesForCombobox";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetValidateCodeTypesForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetValidateCodeTypesForCombobox(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfComboboxItemDtoTOfInt32>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfComboboxItemDtoTOfInt32>><any>_observableThrow(response_);
        }));
    }

    protected processGetValidateCodeTypesForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfComboboxItemDtoTOfInt32> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfComboboxItemDtoTOfInt32.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfComboboxItemDtoTOfInt32>(<any>null);
    }
}

@Injectable()
export class DataEngineTestCacheServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 测试Cahce对象的CRUD接口
     * @return Success
     */
    testCacheCRUD(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DataEngineTestCache/TestCacheCRUD";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestCacheCRUD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestCacheCRUD(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processTestCacheCRUD(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * 测试获取Cahce类型相关接口
     * @return Success
     */
    testGetCahceType(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DataEngineTestCache/TestGetCahceType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestGetCahceType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestGetCahceType(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processTestGetCahceType(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

@Injectable()
export class DataEngineTestClientServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 测试配置文件生成相关接口
     * @return Success
     */
    testClientFile(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DataEngineTestClient/TestClientFile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestClientFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestClientFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTestClientFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 测试客户端注册相关接口
     * @return Success
     */
    testClientRegister(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DataEngineTestClient/TestClientRegister";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestClientRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestClientRegister(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processTestClientRegister(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

@Injectable()
export class DataEngineTestExporterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 测试Exporter对象的CRUD接口
     * @return Success
     */
    testExporterCRUD(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DataEngineTestExporter/TestExporterCRUD";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestExporterCRUD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestExporterCRUD(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processTestExporterCRUD(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * 测试Exporter的初始化启动停止释放过程
     * @return Success
     */
    testExporterISSD(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DataEngineTestExporter/TestExporterISSD";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestExporterISSD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestExporterISSD(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processTestExporterISSD(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * 测试获取Exporter类型相关接口
     * @return Success
     */
    testGetExporterType(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DataEngineTestExporter/TestGetExporterType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestGetExporterType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestGetExporterType(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processTestGetExporterType(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

@Injectable()
export class DataEngineTestIndexerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 测试获取Indexer类型相关接口
     * @return Success
     */
    testGetIndexerType(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DataEngineTestIndexer/TestGetIndexerType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestGetIndexerType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestGetIndexerType(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processTestGetIndexerType(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * 测试Indexer对象的CRUD接口
     * @return Success
     */
    testIndexerCRUD(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DataEngineTestIndexer/TestIndexerCRUD";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestIndexerCRUD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestIndexerCRUD(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processTestIndexerCRUD(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * 测试Indexer的初始化启动停止释放过程
     * @return Success
     */
    testIndexerISSD(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DataEngineTestIndexer/TestIndexerISSD";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestIndexerISSD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestIndexerISSD(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processTestIndexerISSD(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

@Injectable()
export class DataEngineTestShipperServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 测试获取Shipper类型相关接口
     * @return Success
     */
    testGetShipperType(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DataEngineTestShipper/TestGetShipperType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestGetShipperType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestGetShipperType(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processTestGetShipperType(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * 测试服务端Shipper对象的CRUD接口
     * @return Success
     */
    testServerShipperCRUD(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DataEngineTestShipper/TestServerShipperCRUD";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestServerShipperCRUD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestServerShipperCRUD(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processTestServerShipperCRUD(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * 测试服务端Shipper的初始化启动停止释放过程
     * @return Success
     */
    testServerShipperISSD(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DataEngineTestShipper/TestServerShipperISSD";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestServerShipperISSD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestServerShipperISSD(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processTestServerShipperISSD(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

@Injectable()
export class DataSetTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 测试外部数据集相关接口
     * @return Success
     */
    testExternalDataSetCrud(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DataSetTest/TestExternalDataSetCrud";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestExternalDataSetCrud(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestExternalDataSetCrud(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processTestExternalDataSetCrud(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * 测试内部数据集相关接口
     * @return Success
     */
    testInternalDataSetCrud(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DataSetTest/TestInternalDataSetCrud";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestInternalDataSetCrud(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestInternalDataSetCrud(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processTestInternalDataSetCrud(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

@Injectable()
export class DebugDataSetServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 删除所有索引
     * @return Success
     */
    deleteAllIndex(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DebugDataSet/DeleteAllIndex";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllIndex(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllIndex(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAllIndex(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 触发一次索引更替后台任务
     * @return Success
     */
    testRotateWorker(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DebugDataSet/TestRotateWorker";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestRotateWorker(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestRotateWorker(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTestRotateWorker(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DynamicFormServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 获取ESExporter导出目的地动态表单配置参数
     * @return Success
     */
    getESExporterDestinationConfiguration(): Observable<DynamicFormOutput> {
        let url_ = this.baseUrl + "/api/services/app/DynamicForm/GetESExporterDestinationConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetESExporterDestinationConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetESExporterDestinationConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<DynamicFormOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DynamicFormOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetESExporterDestinationConfiguration(response: HttpResponseBase): Observable<DynamicFormOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicFormOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicFormOutput>(<any>null);
    }

    /**
     * 上传动态表单参数
     * @param body (optional) 
     * @return Success
     */
    postESExporterDestinationConfiguration(body: ESExporterDestination | undefined): Observable<ESExporterDestination> {
        let url_ = this.baseUrl + "/api/services/app/DynamicForm/PostESExporterDestinationConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostESExporterDestinationConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostESExporterDestinationConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<ESExporterDestination>><any>_observableThrow(e);
                }
            } else
                return <Observable<ESExporterDestination>><any>_observableThrow(response_);
        }));
    }

    protected processPostESExporterDestinationConfiguration(response: HttpResponseBase): Observable<ESExporterDestination> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ESExporterDestination.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ESExporterDestination>(<any>null);
    }
}

@Injectable()
export class ExternalYSLogDataSetObjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 外部数据集--批量删除数据集的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExternalYSLogDataSetObject/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 外部数据集--添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateExternalYSLogDataSetObjectInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/ExternalYSLogDataSetObject/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * 外部数据集--删除指定数据集
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExternalYSLogDataSetObject/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 外部数据集--通过指定id获取YSLogDataSetObjectListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<ExternalYSLogDataSetObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/ExternalYSLogDataSetObject/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ExternalYSLogDataSetObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalYSLogDataSetObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ExternalYSLogDataSetObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalYSLogDataSetObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalYSLogDataSetObjectListDto>(<any>null);
    }

    /**
     * 外部数据集--获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | null | undefined): Observable<GetExternalYSLogDataSetObjectForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ExternalYSLogDataSetObject/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetExternalYSLogDataSetObjectForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetExternalYSLogDataSetObjectForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetExternalYSLogDataSetObjectForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetExternalYSLogDataSetObjectForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetExternalYSLogDataSetObjectForEditOutput>(<any>null);
    }

    /**
     * 外部数据集--分页获取数据集信息
     * @param schemaName (optional) 
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(schemaName: string | null | undefined, filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfExternalYSLogDataSetObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/ExternalYSLogDataSetObject/GetPaged?";
        if (schemaName !== undefined)
            url_ += "schemaName=" + encodeURIComponent("" + schemaName) + "&"; 
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfExternalYSLogDataSetObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfExternalYSLogDataSetObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfExternalYSLogDataSetObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfExternalYSLogDataSetObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfExternalYSLogDataSetObjectListDto>(<any>null);
    }
}

@Injectable()
export class GetUserLoginAttemptsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 获取用户最近十次登录尝试记录
     * @param count (optional) 
     * @return Success
     */
    getRecentUserLoginAttempts(count: number | undefined): Observable<ListResultDtoOfUserLoginAttemptDto> {
        let url_ = this.baseUrl + "/api/services/app/GetUserLoginAttempts/GetRecentUserLoginAttempts?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentUserLoginAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentUserLoginAttempts(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentUserLoginAttempts(response: HttpResponseBase): Observable<ListResultDtoOfUserLoginAttemptDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfUserLoginAttemptDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfUserLoginAttemptDto>(<any>null);
    }

    /**
     * @param ip (optional) 
     * @return Success
     */
    isClientIpLocked(ip: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/GetUserLoginAttempts/IsClientIpLocked?";
        if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsClientIpLocked(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsClientIpLocked(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsClientIpLocked(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param userNameOrEmailAddress (optional) 
     * @return Success
     */
    isUserAccountLocked(userNameOrEmailAddress: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/GetUserLoginAttempts/IsUserAccountLocked?";
        if (userNameOrEmailAddress !== undefined)
            url_ += "userNameOrEmailAddress=" + encodeURIComponent("" + userNameOrEmailAddress) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUserAccountLocked(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUserAccountLocked(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsUserAccountLocked(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class HostCachingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 清楚所有缓存
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostCaching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 清除指定缓存
     * @param body (optional) 
     * @return Success
     */
    clearCache(body: EntityDtoOfString | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostCaching/ClearCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取所有缓存
     * @return Success
     */
    getAllCaches(): Observable<ListResultDtoOfHostCacheDto> {
        let url_ = this.baseUrl + "/api/services/app/HostCaching/GetAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfHostCacheDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfHostCacheDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCaches(response: HttpResponseBase): Observable<ListResultDtoOfHostCacheDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfHostCacheDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfHostCacheDto>(<any>null);
    }
}

@Injectable()
export class InternalYSLogDataSetObjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 内部数据集--批量删除数据集的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InternalYSLogDataSetObject/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 内部数据集--清空指定数据集的所有索引
     * @param body (optional) 
     * @return Success
     */
    clear(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InternalYSLogDataSetObject/Clear";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClear(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClear(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 内部数据集--添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateInternalYSLogDataSetObjectInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/InternalYSLogDataSetObject/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * 内部数据集--删除指定数据集
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InternalYSLogDataSetObject/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 内部数据集---通过指定id获取YSLogDataSetObjectListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<InternalYSLogDataSetObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/InternalYSLogDataSetObject/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<InternalYSLogDataSetObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InternalYSLogDataSetObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<InternalYSLogDataSetObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InternalYSLogDataSetObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InternalYSLogDataSetObjectListDto>(<any>null);
    }

    /**
     * 内部数据集--获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | null | undefined): Observable<GetInternalYSLogDataSetObjectForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/InternalYSLogDataSetObject/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetInternalYSLogDataSetObjectForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetInternalYSLogDataSetObjectForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetInternalYSLogDataSetObjectForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetInternalYSLogDataSetObjectForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInternalYSLogDataSetObjectForEditOutput>(<any>null);
    }

    /**
     * 内部数据集--分页获取数据集信息
     * @param schemaName (optional) 
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(schemaName: string | null | undefined, filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfInternalYSLogDataSetObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/InternalYSLogDataSetObject/GetPaged?";
        if (schemaName !== undefined)
            url_ += "schemaName=" + encodeURIComponent("" + schemaName) + "&"; 
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfInternalYSLogDataSetObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfInternalYSLogDataSetObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfInternalYSLogDataSetObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfInternalYSLogDataSetObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfInternalYSLogDataSetObjectListDto>(<any>null);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 新建和更新语言的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateLanguage(body: CreateOrUpdateLanguageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除指定语言
     * @param id (optional) 
     * @return Success
     */
    deleteLanguage(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/DeleteLanguage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取语言的新建或编辑模板
     * @param id (optional) 
     * @return Success
     */
    getLanguageForEdit(id: number | null | undefined): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguageForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguageForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLanguageForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguageForEditOutput>(<any>null);
    }

    /**
     * 获取所有语言以及默认语言
     * @return Success
     */
    getLanguages(): Observable<GetLanguagesOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguagesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguagesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLanguagesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguagesOutput>(<any>null);
    }

    /**
     * 获取源语言与目标语言一一对应的文本对
     * @param sourceName 语言名称
     * @param baseLanguageName (optional) 原语言名称
     * @param targetLanguageName 目标语言名称
     * @param targetValueFilter (optional) 目标值过滤
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getLanguageTexts(sourceName: string, baseLanguageName: string | null | undefined, targetLanguageName: string, targetValueFilter: string | null | undefined, filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfLanguageTextListDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageTexts?";
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "sourceName=" + encodeURIComponent("" + sourceName) + "&"; 
        if (baseLanguageName !== undefined)
            url_ += "baseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&"; 
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "targetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&"; 
        if (targetValueFilter !== undefined)
            url_ += "targetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&"; 
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageTexts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTexts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageTexts(response: HttpResponseBase): Observable<PagedResultDtoOfLanguageTextListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLanguageTextListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLanguageTextListDto>(<any>null);
    }

    /**
     * 重置为当地默认语言
     * @param body (optional) 
     * @return Success
     */
    setDefaultLanguage(body: SetDefaultLanguageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新语言中一些字符串所指代的值
     * @param body (optional) 
     * @return Success
     */
    updateLanguageText(body: UpdateLanguageTextInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class NetworkSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 获取备用网卡信息，仅供展示，不允许修改。
     * @return Success
     */
    getBackupNetworkSettings(): Observable<BackupNetworkSettingsListDto> {
        let url_ = this.baseUrl + "/api/services/app/NetworkSettings/GetBackupNetworkSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBackupNetworkSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBackupNetworkSettings(<any>response_);
                } catch (e) {
                    return <Observable<BackupNetworkSettingsListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BackupNetworkSettingsListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBackupNetworkSettings(response: HttpResponseBase): Observable<BackupNetworkSettingsListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BackupNetworkSettingsListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BackupNetworkSettingsListDto>(<any>null);
    }

    /**
     * 获取主网卡配置信息，这里展示的InterfaceName和InterfaceDisplayName仅仅是供用户知晓的，不允许修改。
    后续考虑屏蔽InterfaceName，仅展示InterfaceDisplayName
     * @return Success
     */
    getNetworkSettings(): Observable<NetworkSettingsListDto> {
        let url_ = this.baseUrl + "/api/services/app/NetworkSettings/GetNetworkSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNetworkSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNetworkSettings(<any>response_);
                } catch (e) {
                    return <Observable<NetworkSettingsListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NetworkSettingsListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetNetworkSettings(response: HttpResponseBase): Observable<NetworkSettingsListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NetworkSettingsListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NetworkSettingsListDto>(<any>null);
    }

    /**
     * 更新主网卡配置，注意对dto对象中的IP校验是比较严格的。
     * @param body (optional) 
     * @return Success
     */
    updateNetworkSettings(body: NetworkSettingsEditDto | undefined): Observable<NetworkSettingsResultDto> {
        let url_ = this.baseUrl + "/api/services/app/NetworkSettings/UpdateNetworkSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNetworkSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNetworkSettings(<any>response_);
                } catch (e) {
                    return <Observable<NetworkSettingsResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NetworkSettingsResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNetworkSettings(response: HttpResponseBase): Observable<NetworkSettingsResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NetworkSettingsResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NetworkSettingsResultDto>(<any>null);
    }
}

@Injectable()
export class SecuritySettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 获取登录相关的安全配置。包括
        是否启用登录校验码
        是否启用用户账户锁定
        是否启用IP地址锁定
        用户账户锁定触发阈值和锁定时长（分钟）
        IP地址锁定触发阈值和锁定时长（分钟）
        最大强制注销时长（小时）
     * @return Success
     */
    getLoginSettings(): Observable<SecurityLoginSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/SecuritySettings/GetLoginSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoginSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoginSettings(<any>response_);
                } catch (e) {
                    return <Observable<SecurityLoginSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SecurityLoginSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoginSettings(response: HttpResponseBase): Observable<SecurityLoginSettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityLoginSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SecurityLoginSettingsDto>(<any>null);
    }

    /**
     * 获取密码相关的安全设置，包括
    密码最小长度
    是否需要数字
    是否需要小写字母
    是否需要大写字母
    是否需要除字母数字以外的特殊字符
     * @return Success
     */
    getPasswordSettings(): Observable<SecurityPasswordSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/SecuritySettings/GetPasswordSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordSettings(<any>response_);
                } catch (e) {
                    return <Observable<SecurityPasswordSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SecurityPasswordSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPasswordSettings(response: HttpResponseBase): Observable<SecurityPasswordSettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityPasswordSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SecurityPasswordSettingsDto>(<any>null);
    }

    /**
     * 更新登录相关的安全配置
     * @param body (optional) 包含配置的DTO对象
     * @return Success
     */
    updateLoginSettings(body: SecurityLoginSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SecuritySettings/UpdateLoginSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLoginSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLoginSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLoginSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新密码相关的安全设置
     * @param body (optional) 
     * @return Success
     */
    updatePasswordSettings(body: SecurityPasswordSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SecuritySettings/UpdatePasswordSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePasswordSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePasswordSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePasswordSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 获取当前系统的版本以及发行信息
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }

    /**
     * 获取用户配置
     * @return Success
     */
    getUserConfigurations(): Observable<AbpUserConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetUserConfigurations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserConfigurations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserConfigurations(<any>response_);
                } catch (e) {
                    return <Observable<AbpUserConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AbpUserConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserConfigurations(response: HttpResponseBase): Observable<AbpUserConfigurationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AbpUserConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AbpUserConfigurationDto>(<any>null);
    }

    /**
     * 更新用户的SignInToken
     * @return Success
     */
    updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/UpdateUserSignInToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserSignInToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignInToken(<any>response_);
                } catch (e) {
                    return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateUserSignInTokenOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateUserSignInTokenOutput>(<any>null);
    }
}

@Injectable()
export class SmtpSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 获取发件人邮箱配置
     * @return Success
     */
    getSmtpSettings(): Observable<SmtpSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/SmtpSettings/GetSmtpSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSmtpSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSmtpSettings(<any>response_);
                } catch (e) {
                    return <Observable<SmtpSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SmtpSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSmtpSettings(response: HttpResponseBase): Observable<SmtpSettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SmtpSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SmtpSettingsDto>(<any>null);
    }

    /**
     * 发送测试邮件
     * @param toMailAddress (optional) 
     * @return Success
     */
    sendTestEmail(toMailAddress: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SmtpSettings/SendTestEmail?";
        if (toMailAddress !== undefined)
            url_ += "toMailAddress=" + encodeURIComponent("" + toMailAddress) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    testJob(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SmtpSettings/TestJob";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestJob(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processTestJob(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * 更新发件人邮箱配置
     * @param body (optional) 
     * @return Success
     */
    updateSmtpSettings(body: SmtpSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SmtpSettings/UpdateSmtpSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSmtpSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSmtpSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSmtpSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SystemAlertSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 获取系统告警设置
     * @return Success
     */
    getSystemAlertSettings(): Observable<SystemAlertSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/SystemAlertSettings/GetSystemAlertSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSystemAlertSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSystemAlertSettings(<any>response_);
                } catch (e) {
                    return <Observable<SystemAlertSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SystemAlertSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSystemAlertSettings(response: HttpResponseBase): Observable<SystemAlertSettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemAlertSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemAlertSettingsDto>(<any>null);
    }

    /**
     * 更新系统告警设置
     * @param body (optional) 
     * @return Success
     */
    updateSystemAlertSettings(body: SystemAlertSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SystemAlertSettings/UpdateSystemAlertSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSystemAlertSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSystemAlertSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSystemAlertSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TestBackgroundJobServicesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 添加一次性任务
     * @return Success
     */
    addBackgroundJob(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TestBackgroundJobServices/AddBackgroundJob";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddBackgroundJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddBackgroundJob(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddBackgroundJob(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 用于后端测试触发Hangfire
     * @param args (optional) 
     * @return Success
     */
    addHangfireTestPing(args: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TestBackgroundJobServices/AddHangfireTestPing?";
        if (args !== undefined)
            url_ += "args=" + encodeURIComponent("" + args) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddHangfireTestPing(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddHangfireTestPing(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddHangfireTestPing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除任务
     * @param jobId (optional) 
     * @return Success
     */
    deleteJob(jobId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TestBackgroundJobServices/DeleteJob?";
        if (jobId !== undefined)
            url_ += "jobId=" + encodeURIComponent("" + jobId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteJob(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteJob(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取任务信息，JobData似乎不能作为返回值，会报错
     * @param jobId (optional) 
     * @return Success
     */
    getJobData(jobId: string | null | undefined): Observable<JobData> {
        let url_ = this.baseUrl + "/api/services/app/TestBackgroundJobServices/GetJobData?";
        if (jobId !== undefined)
            url_ += "jobId=" + encodeURIComponent("" + jobId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobData(<any>response_);
                } catch (e) {
                    return <Observable<JobData>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobData>><any>_observableThrow(response_);
        }));
    }

    protected processGetJobData(response: HttpResponseBase): Observable<JobData> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobData>(<any>null);
    }

    /**
     * 获取任务状态
     * @param jobId (optional) 
     * @return Success
     */
    getJobState(jobId: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/TestBackgroundJobServices/GetJobState?";
        if (jobId !== undefined)
            url_ += "jobId=" + encodeURIComponent("" + jobId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobState(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetJobState(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 重排任务
     * @param jobId (optional) 
     * @return Success
     */
    requeueJob(jobId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TestBackgroundJobServices/RequeueJob?";
        if (jobId !== undefined)
            url_ += "jobId=" + encodeURIComponent("" + jobId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequeueJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequeueJob(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRequeueJob(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    testGetParaFormDB(body: NullableIdDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TestBackgroundJobServices/TestGetParaFormDB";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestGetParaFormDB(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestGetParaFormDB(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTestGetParaFormDB(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 用于后端测试触发BackgroundJob
     * @param args (optional) 
     * @return Success
     */
    testPing(args: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TestBackgroundJobServices/TestPing?";
        if (args !== undefined)
            url_ += "args=" + encodeURIComponent("" + args) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestPing(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestPing(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTestPing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TimeZoneServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 获取时间控件所需信息
     * @param selectedTimezoneId (optional) 
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string | null | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/TimeZone/GetTimezoneComboboxItems?";
        if (selectedTimezoneId !== undefined)
            url_ += "selectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezoneComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezoneComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<ComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboboxItemDto[]>(<any>null);
    }

    /**
     * 获取所有时区信息
     * @return Success
     */
    getTimezones(defaultTimezoneScope: SettingScopes): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/TimeZone/GetTimezones?";
        if (defaultTimezoneScope === undefined || defaultTimezoneScope === null)
            throw new Error("The parameter 'defaultTimezoneScope' must be defined and cannot be null.");
        else
            url_ += "defaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezones(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezones(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfNameValueDto>(<any>null);
    }
}

@Injectable()
export class WebSiteLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 下载日志文件压缩包
     * @return Success
     */
    downloadWebLogs(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WebSiteLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * 获取最新的网站日志信息
     * @return Success
     */
    getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebSiteLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLatestWebLogsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLatestWebLogsOutput>(<any>null);
    }
}

@Injectable()
export class YSLogDataAlertObjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除YSLogDataAlertObject的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataAlertObject/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改告警任务的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateYSLogDataAlertObjectInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataAlertObject/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * 删除告警任务信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataAlertObject/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取YSLogDataAlertObjectListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<YSLogDataAlertObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataAlertObject/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<YSLogDataAlertObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<YSLogDataAlertObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<YSLogDataAlertObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = YSLogDataAlertObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YSLogDataAlertObjectListDto>(<any>null);
    }

    /**
     * 获取异常记录
     * @param id (optional) 
     * @return Success
     */
    getErrorList(id: number | undefined): Observable<AlertHistoryInstance[]> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataAlertObject/GetErrorList?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetErrorList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetErrorList(<any>response_);
                } catch (e) {
                    return <Observable<AlertHistoryInstance[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AlertHistoryInstance[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetErrorList(response: HttpResponseBase): Observable<AlertHistoryInstance[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AlertHistoryInstance.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AlertHistoryInstance[]>(<any>null);
    }

    /**
     * 获取编辑 告警任务
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | null | undefined): Observable<GetYSLogDataAlertObjectForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataAlertObject/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetYSLogDataAlertObjectForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetYSLogDataAlertObjectForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetYSLogDataAlertObjectForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetYSLogDataAlertObjectForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetYSLogDataAlertObjectForEditOutput>(<any>null);
    }

    /**
     * 获取告警任务的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfYSLogDataAlertObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataAlertObject/GetPaged?";
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfYSLogDataAlertObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfYSLogDataAlertObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfYSLogDataAlertObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfYSLogDataAlertObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfYSLogDataAlertObjectListDto>(<any>null);
    }

    /**
     * 手动触发一次后台任务
     * @param body (optional) 
     * @return Success
     */
    startJob(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataAlertObject/StartJob";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartJob(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStartJob(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class YSLogDataAnalyzeObjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除YSLogDataAnalyzeObject的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataAnalyzeObject/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateYSLogDataAnalyzeObjectInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataAnalyzeObject/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataAnalyzeObject/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 生成下载文件的Token，有效期10分钟，只能使用一次
     * @param body (optional) 
     * @return Success
     */
    generateDownloadToken(body: EntityDtoOfInt64 | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataAnalyzeObject/GenerateDownloadToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateDownloadToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateDownloadToken(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateDownloadToken(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 通过指定id获取YSLogDataAnalyzeObjectListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<YSLogDataAnalyzeObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataAnalyzeObject/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<YSLogDataAnalyzeObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<YSLogDataAnalyzeObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<YSLogDataAnalyzeObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = YSLogDataAnalyzeObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YSLogDataAnalyzeObjectListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | null | undefined): Observable<GetYSLogDataAnalyzeObjectForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataAnalyzeObject/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetYSLogDataAnalyzeObjectForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetYSLogDataAnalyzeObjectForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetYSLogDataAnalyzeObjectForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetYSLogDataAnalyzeObjectForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetYSLogDataAnalyzeObjectForEditOutput>(<any>null);
    }

    /**
     * 获取报表任务最近10条运行记录
     * @param id (optional) 
     * @return Success
     */
    getHistoryRecords(id: number | undefined): Observable<ReportHistoryInstanceListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataAnalyzeObject/GetHistoryRecords?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHistoryRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHistoryRecords(<any>response_);
                } catch (e) {
                    return <Observable<ReportHistoryInstanceListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReportHistoryInstanceListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHistoryRecords(response: HttpResponseBase): Observable<ReportHistoryInstanceListDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReportHistoryInstanceListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportHistoryInstanceListDto[]>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfYSLogDataAnalyzeObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataAnalyzeObject/GetPaged?";
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfYSLogDataAnalyzeObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfYSLogDataAnalyzeObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfYSLogDataAnalyzeObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfYSLogDataAnalyzeObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfYSLogDataAnalyzeObjectListDto>(<any>null);
    }

    /**
     * 手动触发一次后台任务
     * @param body (optional) 
     * @return Success
     */
    startJob(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataAnalyzeObject/StartJob";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartJob(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStartJob(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class YSLogDataBackupObjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除YSLogDataBackupObject的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataBackupObject/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateYSLogDataBackupObjectInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataBackupObject/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataBackupObject/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取YSLogDataBackupObjectListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<YSLogDataBackupObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataBackupObject/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<YSLogDataBackupObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<YSLogDataBackupObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<YSLogDataBackupObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = YSLogDataBackupObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YSLogDataBackupObjectListDto>(<any>null);
    }

    /**
     * 获取异常记录
     * @param id (optional) 
     * @return Success
     */
    getErrorList(id: number | undefined): Observable<BackupHistoryInstance[]> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataBackupObject/GetErrorList?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetErrorList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetErrorList(<any>response_);
                } catch (e) {
                    return <Observable<BackupHistoryInstance[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BackupHistoryInstance[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetErrorList(response: HttpResponseBase): Observable<BackupHistoryInstance[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BackupHistoryInstance.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BackupHistoryInstance[]>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | null | undefined): Observable<GetYSLogDataBackupObjectForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataBackupObject/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetYSLogDataBackupObjectForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetYSLogDataBackupObjectForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetYSLogDataBackupObjectForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetYSLogDataBackupObjectForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetYSLogDataBackupObjectForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfYSLogDataBackupObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataBackupObject/GetPaged?";
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfYSLogDataBackupObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfYSLogDataBackupObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfYSLogDataBackupObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfYSLogDataBackupObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfYSLogDataBackupObjectListDto>(<any>null);
    }

    /**
     * 手动启动备份任务
     * @param id (optional) 
     * @return Success
     */
    startDataBackup(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataBackupObject/StartDataBackup?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartDataBackup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartDataBackup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStartDataBackup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class YSLogDataClientObjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量取消注册客户端
     * @param body (optional) 
     * @return Success
     */
    batchUnRegister(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataClientObject/BatchUnRegister";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchUnRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchUnRegister(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchUnRegister(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取YSLogDataClientObjectListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<YSLogDataClientObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataClientObject/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<YSLogDataClientObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<YSLogDataClientObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<YSLogDataClientObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = YSLogDataClientObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YSLogDataClientObjectListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | null | undefined): Observable<GetYSLogDataClientObjectForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataClientObject/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetYSLogDataClientObjectForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetYSLogDataClientObjectForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetYSLogDataClientObjectForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetYSLogDataClientObjectForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetYSLogDataClientObjectForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfYSLogDataClientObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataClientObject/GetPaged?";
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfYSLogDataClientObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfYSLogDataClientObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfYSLogDataClientObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfYSLogDataClientObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfYSLogDataClientObjectListDto>(<any>null);
    }

    /**
     * 获取所有未注册客户端
     * @return Success
     */
    getUnRegisteredDataClients(): Observable<UnRegisteredDataClientDto[]> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataClientObject/GetUnRegisteredDataClients";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnRegisteredDataClients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnRegisteredDataClients(<any>response_);
                } catch (e) {
                    return <Observable<UnRegisteredDataClientDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnRegisteredDataClientDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnRegisteredDataClients(response: HttpResponseBase): Observable<UnRegisteredDataClientDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UnRegisteredDataClientDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnRegisteredDataClientDto[]>(<any>null);
    }

    /**
     * 注册或者修改的公共方法
    修改时只允许修改Name和Description
     * @param body (optional) 
     * @return Success
     */
    registerOrUpdate(body: CreateOrUpdateYSLogDataClientObjectInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataClientObject/RegisterOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterOrUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * 解决冲突客户端
     * @param body (optional) 
     * @return Success
     */
    solveConflictClient(body: SolveConflictDataClientDto | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataClientObject/SolveConflictClient";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSolveConflictClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSolveConflictClient(<any>response_);
                } catch (e) {
                    return <Observable<number[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<number[]>><any>_observableThrow(response_);
        }));
    }

    protected processSolveConflictClient(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(<any>null);
    }

    /**
     * 取消注册客户端
     * @param body (optional) 
     * @return Success
     */
    unRegister(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataClientObject/UnRegister";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnRegister(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnRegister(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class YSLogDataCollectorObjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除YSLogDataCollectorObject的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataCollectorObject/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改采集任务的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateYSLogDataCollectorObjectInput | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataCollectorObject/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<number[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<number[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(<any>null);
    }

    /**
     * 删除采集任务信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataCollectorObject/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取YSLogDataCollectorObjectListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<YSLogDataCollectorObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataCollectorObject/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<YSLogDataCollectorObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<YSLogDataCollectorObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<YSLogDataCollectorObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = YSLogDataCollectorObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YSLogDataCollectorObjectListDto>(<any>null);
    }

    /**
     * 获取编辑采集任务的数据结构
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | null | undefined): Observable<GetYSLogDataCollectorObjectForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataCollectorObject/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetYSLogDataCollectorObjectForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetYSLogDataCollectorObjectForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetYSLogDataCollectorObjectForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetYSLogDataCollectorObjectForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetYSLogDataCollectorObjectForEditOutput>(<any>null);
    }

    /**
     * 获取采集任务的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfYSLogDataCollectorObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataCollectorObject/GetPaged?";
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfYSLogDataCollectorObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfYSLogDataCollectorObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfYSLogDataCollectorObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfYSLogDataCollectorObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfYSLogDataCollectorObjectListDto>(<any>null);
    }

    /**
     * 获取指定SchemaName的配置清单
     * @param schemaName (optional) 
     * @return Success
     */
    getShipperTypeDesctription(schemaName: string | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataCollectorObject/GetShipperTypeDesctription?";
        if (schemaName !== undefined)
            url_ += "schemaName=" + encodeURIComponent("" + schemaName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShipperTypeDesctription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShipperTypeDesctription(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetShipperTypeDesctription(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * 启动指定采集任务
     * @param body (optional) 
     * @return Success
     */
    start(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataCollectorObject/Start";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStart(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStart(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 停止采集任务
     * @param body (optional) 
     * @return Success
     */
    stop(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataCollectorObject/Stop";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStop(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStop(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class YSLogDataEngineObjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 检查配置是否有效
     * @return Success
     */
    checkConnection(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataEngineObject/CheckConnection";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckConnection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckConnection(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckConnection(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class YSLogDataFormatterObjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除YSLogDataFormatterObject的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataFormatterObject/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改数据解析组件的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateYSLogDataFormatterObjectInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataFormatterObject/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * 删除数据解析组件信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataFormatterObject/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取YSLogDataFormatterObjectListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<YSLogDataFormatterObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataFormatterObject/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<YSLogDataFormatterObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<YSLogDataFormatterObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<YSLogDataFormatterObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = YSLogDataFormatterObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YSLogDataFormatterObjectListDto>(<any>null);
    }

    /**
     * 获取编辑 数据解析组件
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | null | undefined): Observable<GetYSLogDataFormatterObjectForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataFormatterObject/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetYSLogDataFormatterObjectForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetYSLogDataFormatterObjectForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetYSLogDataFormatterObjectForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetYSLogDataFormatterObjectForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetYSLogDataFormatterObjectForEditOutput>(<any>null);
    }

    /**
     * 获取指定SchemaName的配置清单
     * @param schemaName (optional) 
     * @return Success
     */
    getFormatterTypeDesctription(schemaName: string | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataFormatterObject/GetFormatterTypeDesctription?";
        if (schemaName !== undefined)
            url_ += "schemaName=" + encodeURIComponent("" + schemaName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormatterTypeDesctription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormatterTypeDesctription(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetFormatterTypeDesctription(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * 获取数据解析组件的分页列表信息
     * @param schemaName (optional) 
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(schemaName: string | null | undefined, filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfYSLogDataFormatterObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataFormatterObject/GetPaged?";
        if (schemaName !== undefined)
            url_ += "schemaName=" + encodeURIComponent("" + schemaName) + "&"; 
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfYSLogDataFormatterObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfYSLogDataFormatterObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfYSLogDataFormatterObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfYSLogDataFormatterObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfYSLogDataFormatterObjectListDto>(<any>null);
    }
}

@Injectable()
export class YSLogDataRestoreObjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除YSLogDataRestoreObject的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataRestoreObject/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateYSLogDataRestoreObjectInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataRestoreObject/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataRestoreObject/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取YSLogDataRestoreObjectListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<YSLogDataRestoreObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataRestoreObject/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<YSLogDataRestoreObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<YSLogDataRestoreObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<YSLogDataRestoreObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = YSLogDataRestoreObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YSLogDataRestoreObjectListDto>(<any>null);
    }

    /**
     * 获取异常记录
     * @param id (optional) 
     * @return Success
     */
    getErrorList(id: number | undefined): Observable<RestoreHistoryInstance[]> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataRestoreObject/GetErrorList?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetErrorList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetErrorList(<any>response_);
                } catch (e) {
                    return <Observable<RestoreHistoryInstance[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RestoreHistoryInstance[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetErrorList(response: HttpResponseBase): Observable<RestoreHistoryInstance[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RestoreHistoryInstance.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RestoreHistoryInstance[]>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | null | undefined): Observable<GetYSLogDataRestoreObjectForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataRestoreObject/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetYSLogDataRestoreObjectForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetYSLogDataRestoreObjectForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetYSLogDataRestoreObjectForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetYSLogDataRestoreObjectForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetYSLogDataRestoreObjectForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfYSLogDataRestoreObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataRestoreObject/GetPaged?";
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfYSLogDataRestoreObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfYSLogDataRestoreObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfYSLogDataRestoreObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfYSLogDataRestoreObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfYSLogDataRestoreObjectListDto>(<any>null);
    }

    /**
     * 开始还原任务
     * @param id (optional) 
     * @return Success
     */
    startDataRestore(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataRestoreObject/StartDataRestore?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartDataRestore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartDataRestore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStartDataRestore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class YSLogDataSetObjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 通过id获取指定数据集信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<YSLogDataSetObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataSetObject/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<YSLogDataSetObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<YSLogDataSetObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<YSLogDataSetObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = YSLogDataSetObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YSLogDataSetObjectListDto>(<any>null);
    }

    /**
     * 获取该数据集所包含的若干个索引的mapping，经过平铺/展开后合并后形成的哈希表
     * @param id (optional) 
     * @return Success
     */
    getMapping(id: number | undefined): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataSetObject/GetMapping?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMapping(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: string; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: string; }>><any>_observableThrow(response_);
        }));
    }

    protected processGetMapping(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string; }>(<any>null);
    }

    /**
     * 获取该数据集索引包含的索引清单
     * @param id (optional) 
     * @return Success
     */
    getMatchedIndicesInfo(id: number | undefined): Observable<IndiceInfo[]> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataSetObject/GetMatchedIndicesInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMatchedIndicesInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMatchedIndicesInfo(<any>response_);
                } catch (e) {
                    return <Observable<IndiceInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IndiceInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMatchedIndicesInfo(response: HttpResponseBase): Observable<IndiceInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IndiceInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IndiceInfo[]>(<any>null);
    }

    /**
     * 分页获取数据集信息
     * @param schemaName (optional) 
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(schemaName: string | null | undefined, filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfYSLogDataSetObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/YSLogDataSetObject/GetPaged?";
        if (schemaName !== undefined)
            url_ += "schemaName=" + encodeURIComponent("" + schemaName) + "&"; 
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfYSLogDataSetObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfYSLogDataSetObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfYSLogDataSetObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfYSLogDataSetObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfYSLogDataSetObjectListDto>(<any>null);
    }
}

@Injectable()
export class YSLogMountPointObjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除YSLogMountPointObject的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogMountPointObject/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateYSLogMountPointObjectInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogMountPointObject/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogMountPointObject/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取YSLogMountPointObjectListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<YSLogMountPointObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/YSLogMountPointObject/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<YSLogMountPointObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<YSLogMountPointObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<YSLogMountPointObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = YSLogMountPointObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YSLogMountPointObjectListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | null | undefined): Observable<GetYSLogMountPointObjectForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/YSLogMountPointObject/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetYSLogMountPointObjectForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetYSLogMountPointObjectForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetYSLogMountPointObjectForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetYSLogMountPointObjectForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetYSLogMountPointObjectForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(mountType: MountProtocol, filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfYSLogMountPointObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/YSLogMountPointObject/GetPaged?";
        if (mountType === undefined || mountType === null)
            throw new Error("The parameter 'mountType' must be defined and cannot be null.");
        else
            url_ += "mountType=" + encodeURIComponent("" + mountType) + "&"; 
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfYSLogMountPointObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfYSLogMountPointObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfYSLogMountPointObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfYSLogMountPointObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfYSLogMountPointObjectListDto>(<any>null);
    }

    /**
     * 挂载 NFS
     * @param id (optional) 
     * @return Success
     */
    mountNFSPoint(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogMountPointObject/MountNFSPoint?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMountNFSPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMountNFSPoint(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMountNFSPoint(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 挂载 SMB
     * @param id (optional) 
     * @return Success
     */
    mountSMBPoint(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogMountPointObject/MountSMBPoint?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMountSMBPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMountSMBPoint(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMountSMBPoint(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 断开 NFS 挂载
     * @param id (optional) 
     * @return Success
     */
    uMountNFSPoint(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogMountPointObject/UMountNFSPoint?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUMountNFSPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUMountNFSPoint(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUMountNFSPoint(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 断开 SMB 挂载
     * @param id (optional) 
     * @return Success
     */
    uMountSMBPoint(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogMountPointObject/UMountSMBPoint?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUMountSMBPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUMountSMBPoint(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUMountSMBPoint(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class YSLogSearchObjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除YSLogSearchObject的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogSearchObject/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateYSLogSearchObjectInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/YSLogSearchObject/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogSearchObject/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取YSLogSearchObjectListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<YSLogSearchObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/YSLogSearchObject/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<YSLogSearchObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<YSLogSearchObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<YSLogSearchObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = YSLogSearchObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YSLogSearchObjectListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | null | undefined): Observable<GetYSLogSearchObjectForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/YSLogSearchObject/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetYSLogSearchObjectForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetYSLogSearchObjectForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetYSLogSearchObjectForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetYSLogSearchObjectForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetYSLogSearchObjectForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfYSLogSearchObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/YSLogSearchObject/GetPaged?";
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfYSLogSearchObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfYSLogSearchObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfYSLogSearchObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfYSLogSearchObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfYSLogSearchObjectListDto>(<any>null);
    }

    /**
     * 使用新定义的查询对象进行查询，输入为完整的查询对象
     * @param body (optional) 
     * @return Success
     */
    performSearchByDefinition(body: CreateOrUpdateYSLogSearchObjectInput | undefined): Observable<YSLogQueryResult> {
        let url_ = this.baseUrl + "/api/services/app/YSLogSearchObject/PerformSearchByDefinition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPerformSearchByDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPerformSearchByDefinition(<any>response_);
                } catch (e) {
                    return <Observable<YSLogQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<YSLogQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processPerformSearchByDefinition(response: HttpResponseBase): Observable<YSLogQueryResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = YSLogQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YSLogQueryResult>(<any>null);
    }

    /**
     * 使用已定义的查询对象进行查询，输入为选取的查询对象的id
     * @param id (optional) 
     * @return Success
     */
    performSearchById(id: number | undefined): Observable<YSLogQueryResult> {
        let url_ = this.baseUrl + "/api/services/app/YSLogSearchObject/PerformSearchById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPerformSearchById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPerformSearchById(<any>response_);
                } catch (e) {
                    return <Observable<YSLogQueryResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<YSLogQueryResult>><any>_observableThrow(response_);
        }));
    }

    protected processPerformSearchById(response: HttpResponseBase): Observable<YSLogQueryResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = YSLogQueryResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YSLogQueryResult>(<any>null);
    }
}

@Injectable()
export class YSLogTenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 获取当前租户的特性
     * @return Success
     */
    getCurrentTenantFeatures(): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/YSLogTenant/GetCurrentTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentTenantFeatures(<any>response_);
                } catch (e) {
                    return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentTenantFeatures(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTenantFeaturesEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTenantFeaturesEditOutput>(<any>null);
    }

    /**
     * 更新当前租户许可证
     * @param body (optional) 
     * @return Success
     */
    updateCurrentTenantLicense(body: CurrentTenantLicenseEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogTenant/UpdateCurrentTenantLicense";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrentTenantLicense(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentTenantLicense(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCurrentTenantLicense(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新当前租户信息
     * @param body (optional) 
     * @return Success
     */
    updateCurrentTenantProfile(body: CurrentTenantProfileEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogTenant/UpdateCurrentTenantProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrentTenantProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentTenantProfile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCurrentTenantProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class YSLogUserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 修改语言
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogUser/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 修改当前用户密码
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogUser/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取当前用户的个人信息
     * @return Success
     */
    getCurrentUserProfileForEdit(): Observable<CurrentUserProfileEditDto> {
        let url_ = this.baseUrl + "/api/services/app/YSLogUser/GetCurrentUserProfileForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserProfileForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserProfileForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<CurrentUserProfileEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentUserProfileEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrentUserProfileEditDto>(<any>null);
    }

    /**
     * 更新当前用户个人信息
     * @param body (optional) 
     * @return Success
     */
    updateCurrentUserProfile(body: CurrentUserProfileEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogUser/UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class YSLogUserManagementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除用户
     * @param body (optional) 用户Id列表
     * @return Success
     */
    batchDelete(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogUserManagement/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或编辑用户的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateUserInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/YSLogUserManagement/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * 删除指定用户
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogUserManagement/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取新建或编辑用户信息的模板，以及所有角色，IsAssigned用来判断当前用户是否拥有该角色
     * @param id (optional) 
     * @return Success
     */
    getForEditTree(id: number | null | undefined): Observable<GetUserForEditTreeOutput> {
        let url_ = this.baseUrl + "/api/services/app/YSLogUserManagement/GetForEditTree?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEditTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEditTree(<any>response_);
                } catch (e) {
                    return <Observable<GetUserForEditTreeOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserForEditTreeOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEditTree(response: HttpResponseBase): Observable<GetUserForEditTreeOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserForEditTreeOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserForEditTreeOutput>(<any>null);
    }

    /**
     * 分页获取所有用户
     * @param role (optional) 检索角色Id列表
     * @param onlyLockedUsers (optional) 仅被锁定的用户
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(role: number[] | null | undefined, onlyLockedUsers: boolean | undefined, filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/YSLogUserManagement/GetPaged?";
        if (role !== undefined)
            role && role.forEach(item => { url_ += "role=" + encodeURIComponent("" + item) + "&"; });
        if (onlyLockedUsers === null)
            throw new Error("The parameter 'onlyLockedUsers' cannot be null.");
        else if (onlyLockedUsers !== undefined)
            url_ += "onlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&"; 
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserListDto>(<any>null);
    }

    /**
     * 获取新建或编辑用户信息的模板，以及所有角色，IsAssigned用来判断当前用户是否拥有该角色
     * @param id (optional) 
     * @return Success
     */
    getUserForEdit(id: number | null | undefined): Observable<GetUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/YSLogUserManagement/GetUserForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserForEditOutput>(<any>null);
    }

    /**
     * 解除被锁定用户
     * @param body (optional) 
     * @return Success
     */
    unlock(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogUserManagement/Unlock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlock(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlock(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class YSLogVisualizeObjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除YSLogVisualizeObject的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogVisualizeObject/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateYSLogVisualizeObjectInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/YSLogVisualizeObject/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/YSLogVisualizeObject/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取YSLogVisualizeObjectListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<YSLogVisualizeObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/YSLogVisualizeObject/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<YSLogVisualizeObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<YSLogVisualizeObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<YSLogVisualizeObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = YSLogVisualizeObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YSLogVisualizeObjectListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | null | undefined): Observable<GetYSLogVisualizeObjectForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/YSLogVisualizeObject/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetYSLogVisualizeObjectForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetYSLogVisualizeObjectForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetYSLogVisualizeObjectForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetYSLogVisualizeObjectForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetYSLogVisualizeObjectForEditOutput>(<any>null);
    }

    /**
     * 分页获取列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfYSLogVisualizeObjectListDto> {
        let url_ = this.baseUrl + "/api/services/app/YSLogVisualizeObject/GetPaged?";
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfYSLogVisualizeObjectListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfYSLogVisualizeObjectListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfYSLogVisualizeObjectListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfYSLogVisualizeObjectListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfYSLogVisualizeObjectListDto>(<any>null);
    }

    /**
     * 使用新定义的可视化对象进行可视化查询，输入为完整的可视化对象
     * @param body (optional) 
     * @return Success
     */
    performSearchByDefinition(body: CreateOrUpdateYSLogVisualizeObjectInput | undefined): Observable<YSLogAggregationResult> {
        let url_ = this.baseUrl + "/api/services/app/YSLogVisualizeObject/PerformSearchByDefinition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPerformSearchByDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPerformSearchByDefinition(<any>response_);
                } catch (e) {
                    return <Observable<YSLogAggregationResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<YSLogAggregationResult>><any>_observableThrow(response_);
        }));
    }

    protected processPerformSearchByDefinition(response: HttpResponseBase): Observable<YSLogAggregationResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = YSLogAggregationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YSLogAggregationResult>(<any>null);
    }

    /**
     * 使用新定义的可视化对象进行可视化查询，输入为完整的可视化对象,返回值为CSV类型数据
     * @param body (optional) 
     * @return Success
     */
    performSearchByDefinitionCSVData(body: CreateOrUpdateYSLogVisualizeObjectInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/YSLogVisualizeObject/PerformSearchByDefinitionCSVData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPerformSearchByDefinitionCSVData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPerformSearchByDefinitionCSVData(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPerformSearchByDefinitionCSVData(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 使用已保存的可视化对象进行可视化查询，输入为选取的可视化对象id
     * @param id (optional) 
     * @return Success
     */
    performSearchById(id: number | undefined): Observable<YSLogAggregationResult> {
        let url_ = this.baseUrl + "/api/services/app/YSLogVisualizeObject/PerformSearchById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPerformSearchById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPerformSearchById(<any>response_);
                } catch (e) {
                    return <Observable<YSLogAggregationResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<YSLogAggregationResult>><any>_observableThrow(response_);
        }));
    }

    protected processPerformSearchById(response: HttpResponseBase): Observable<YSLogAggregationResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = YSLogAggregationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YSLogAggregationResult>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 前端用户登录接口
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * Google/Facebook等第三方登录
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }

    /**
     * 生成验证码图片，name为必填项，生成的验证码与name绑定，当前Tenant模式需要输入tid为1，有效期为三分钟
     * @param name (optional) 
     * @param tid (optional) 
     * @return Success
     */
    generateVerification(name: string | null | undefined, tid: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/GenerateVerification?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (tid !== undefined)
            url_ += "tid=" + encodeURIComponent("" + tid) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateVerification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateVerification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateVerification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取外部认证，对接Google/Facebook等登录选项
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * 用于供前端检查系统是否启用了登录验证码
    若未启用，则不需要显示相应的前端元素
     * @return Success
     */
    isCaptchaVerificationEnabled(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/TokenAuth/IsCaptchaVerificationEnabled";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsCaptchaVerificationEnabled(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsCaptchaVerificationEnabled(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsCaptchaVerificationEnabled(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class VerificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_LOGMANAGER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 根据验证类型获取验证码，需配置session，目前不可用
     * @param type 验证码类型
     * @return Success
     */
    generateCaptcha(type: CaptchaType): Observable<void> {
        let url_ = this.baseUrl + "/api/Verification/GenerateCaptcha?";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateCaptcha(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateCaptcha(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateCaptcha(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

/** 验证租户名称是否可用 */
export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName!: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

/** 验证租户名称是否可用 */
export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export enum TenantAvailabilityState {
    Available = "Available",
    InActive = "InActive",
    NotFound = "NotFound",
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state!: TenantAvailabilityState;
    tenantId!: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
    c!: string | undefined;

    constructor(data?: IResolveTenantIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ResolveTenantIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveTenantIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["c"] = this.c;
        return data; 
    }
}

export interface IResolveTenantIdInput {
    c: string | undefined;
}

export class FileDto implements IFileDto {
    fileName!: string;
    fileType!: string;
    fileToken!: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fileToken = _data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;
}

export enum EntityChangeType {
    Created = "Created",
    Updated = "Updated",
    Deleted = "Deleted",
}

export class EntityChangeListDto implements IEntityChangeListDto {
    userId!: number;
    userName!: string | undefined;
    changeTime!: moment.Moment;
    entityTypeFullName!: string | undefined;
    changeType!: EntityChangeType;
    entityChangeSetId!: number;
    id!: number;

    constructor(data?: IEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.changeTime = _data["changeTime"] ? moment(_data["changeTime"].toString()) : <any>undefined;
            this.entityTypeFullName = _data["entityTypeFullName"];
            this.changeType = _data["changeType"];
            this.entityChangeSetId = _data["entityChangeSetId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        data["entityTypeFullName"] = this.entityTypeFullName;
        data["changeType"] = this.changeType;
        data["entityChangeSetId"] = this.entityChangeSetId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityChangeListDto {
    userId: number;
    userName: string | undefined;
    changeTime: moment.Moment;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeType;
    entityChangeSetId: number;
    id: number;
}

export class PagedResultDtoOfEntityChangeListDto implements IPagedResultDtoOfEntityChangeListDto {
    totalCount!: number;
    items!: EntityChangeListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EntityChangeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfEntityChangeListDto {
    totalCount: number;
    items: EntityChangeListDto[] | undefined;
}

export class AuditLogListDto implements IAuditLogListDto {
    /** 用户Id */
    userId!: number | undefined;
    /** 用户名 */
    userName!: string | undefined;
    /** 模拟租户Id */
    impersonatorTenantId!: number | undefined;
    /** 模拟用户Id */
    impersonatorUserId!: number | undefined;
    /** 服务名称 */
    serviceName!: string | undefined;
    /** 方法名称 */
    methodName!: string | undefined;
    /** 参数 */
    parameters!: string | undefined;
    /** 执行时间 */
    executionTime!: moment.Moment;
    /** 持续时间 */
    executionDuration!: number;
    /** 客户端ip地址 */
    clientIpAddress!: string | undefined;
    /** 客户端 */
    clientName!: string | undefined;
    /** 浏览器信息 */
    browserInfo!: string | undefined;
    /** 异常 */
    exception!: string | undefined;
    customData!: string | undefined;
    id!: number;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.impersonatorTenantId = _data["impersonatorTenantId"];
            this.impersonatorUserId = _data["impersonatorUserId"];
            this.serviceName = _data["serviceName"];
            this.methodName = _data["methodName"];
            this.parameters = _data["parameters"];
            this.executionTime = _data["executionTime"] ? moment(_data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = _data["executionDuration"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.browserInfo = _data["browserInfo"];
            this.exception = _data["exception"];
            this.customData = _data["customData"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAuditLogListDto {
    /** 用户Id */
    userId: number | undefined;
    /** 用户名 */
    userName: string | undefined;
    /** 模拟租户Id */
    impersonatorTenantId: number | undefined;
    /** 模拟用户Id */
    impersonatorUserId: number | undefined;
    /** 服务名称 */
    serviceName: string | undefined;
    /** 方法名称 */
    methodName: string | undefined;
    /** 参数 */
    parameters: string | undefined;
    /** 执行时间 */
    executionTime: moment.Moment;
    /** 持续时间 */
    executionDuration: number;
    /** 客户端ip地址 */
    clientIpAddress: string | undefined;
    /** 客户端 */
    clientName: string | undefined;
    /** 浏览器信息 */
    browserInfo: string | undefined;
    /** 异常 */
    exception: string | undefined;
    customData: string | undefined;
    id: number;
}

export class PagedResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
    totalCount!: number;
    items!: AuditLogListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAuditLogListDto {
    totalCount: number;
    items: AuditLogListDto[] | undefined;
}

export class CommonLookupFindUsersInput implements ICommonLookupFindUsersInput {
    tenantId!: number | undefined;
    maxResultCount!: number;
    skipCount!: number;
    filterText!: string | undefined;

    constructor(data?: ICommonLookupFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filterText = _data["filterText"];
        }
    }

    static fromJS(data: any): CommonLookupFindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new CommonLookupFindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filterText"] = this.filterText;
        return data; 
    }
}

export interface ICommonLookupFindUsersInput {
    tenantId: number | undefined;
    maxResultCount: number;
    skipCount: number;
    filterText: string | undefined;
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export class PagedResultDtoOfNameValueDto implements IPagedResultDtoOfNameValueDto {
    totalCount!: number;
    items!: NameValueDto[] | undefined;

    constructor(data?: IPagedResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfNameValueDto {
    totalCount: number;
    items: NameValueDto[] | undefined;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name!: string | undefined;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IGetDefaultEditionNameOutput {
    name: string | undefined;
}

export class ComboboxItemDtoTOfInt32 implements IComboboxItemDtoTOfInt32 {
    value!: number;
    displayText!: string | undefined;
    isSelected!: boolean;

    constructor(data?: IComboboxItemDtoTOfInt32) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.displayText = _data["displayText"];
            this.isSelected = _data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDtoTOfInt32 {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDtoTOfInt32();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface IComboboxItemDtoTOfInt32 {
    value: number;
    displayText: string | undefined;
    isSelected: boolean;
}

export class ListResultDtoOfComboboxItemDtoTOfInt32 implements IListResultDtoOfComboboxItemDtoTOfInt32 {
    items!: ComboboxItemDtoTOfInt32[] | undefined;

    constructor(data?: IListResultDtoOfComboboxItemDtoTOfInt32) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ComboboxItemDtoTOfInt32.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfComboboxItemDtoTOfInt32 {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfComboboxItemDtoTOfInt32();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfComboboxItemDtoTOfInt32 {
    items: ComboboxItemDtoTOfInt32[] | undefined;
}

export class BaseFormConfiguration implements IBaseFormConfiguration {
    key!: string | undefined;
    label!: string | undefined;
    required!: boolean;

    protected _discriminator: string;

    constructor(data?: IBaseFormConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "BaseFormConfiguration";
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.label = _data["label"];
            this.required = _data["required"];
        }
    }

    static fromJS(data: any): BaseFormConfiguration {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "numberInput") {
            let result = new NumberInputFormConfiguration();
            result.init(data);
            return result;
        }
        if (data["type"] === "radioGroup") {
            let result = new RadioGroupFormConfiguration();
            result.init(data);
            return result;
        }
        if (data["type"] === "selector") {
            let result = new SelectorFormConfiguration();
            result.init(data);
            return result;
        }
        if (data["type"] === "switch") {
            let result = new SwitchFormConfiguration();
            result.init(data);
            return result;
        }
        if (data["type"] === "textarea") {
            let result = new TextareaFormConfiguration();
            result.init(data);
            return result;
        }
        if (data["type"] === "text") {
            let result = new TextFormConfiguration();
            result.init(data);
            return result;
        }
        let result = new BaseFormConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this._discriminator; 
        data["key"] = this.key;
        data["label"] = this.label;
        data["required"] = this.required;
        return data; 
    }
}

export interface IBaseFormConfiguration {
    key: string | undefined;
    label: string | undefined;
    required: boolean;
}

export class DynamicFormOutput implements IDynamicFormOutput {
    form_name!: string | undefined;
    list!: BaseFormConfiguration[] | undefined;

    constructor(data?: IDynamicFormOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.form_name = _data["form_name"];
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(BaseFormConfiguration.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DynamicFormOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicFormOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["form_name"] = this.form_name;
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDynamicFormOutput {
    form_name: string | undefined;
    list: BaseFormConfiguration[] | undefined;
}

export enum AuthMode {
    None = "None",
    ApiKeyAuthentication = "ApiKeyAuthentication",
    BasicAuthentication = "BasicAuthentication",
}

/** ESExporter导出目的地 */
export class ESExporterDestination implements IESExporterDestination {
    host!: string | undefined;
    port!: number;
    description!: string | undefined;
    ssl!: boolean;
    authMode!: AuthMode;
    apiKey!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;
    logType!: string[] | undefined;

    constructor(data?: IESExporterDestination) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.host = _data["host"];
            this.port = _data["port"];
            this.description = _data["description"];
            this.ssl = _data["ssl"];
            this.authMode = _data["authMode"];
            this.apiKey = _data["apiKey"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            if (Array.isArray(_data["logType"])) {
                this.logType = [] as any;
                for (let item of _data["logType"])
                    this.logType!.push(item);
            }
        }
    }

    static fromJS(data: any): ESExporterDestination {
        data = typeof data === 'object' ? data : {};
        let result = new ESExporterDestination();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["host"] = this.host;
        data["port"] = this.port;
        data["description"] = this.description;
        data["ssl"] = this.ssl;
        data["authMode"] = this.authMode;
        data["apiKey"] = this.apiKey;
        data["userName"] = this.userName;
        data["password"] = this.password;
        if (Array.isArray(this.logType)) {
            data["logType"] = [];
            for (let item of this.logType)
                data["logType"].push(item);
        }
        return data; 
    }
}

/** ESExporter导出目的地 */
export interface IESExporterDestination {
    host: string | undefined;
    port: number;
    description: string | undefined;
    ssl: boolean;
    authMode: AuthMode;
    apiKey: string | undefined;
    userName: string | undefined;
    password: string | undefined;
    logType: string[] | undefined;
}

export class ExternalYSLogDataSetObjectEditDto implements IExternalYSLogDataSetObjectEditDto {
    /** Id */
    id!: number | undefined;
    /** 关联的ES集群Id */
    cluster_id!: number;
    /** 名称 */
    name!: string;
    /** 描述 */
    description!: string | undefined;
    /** 该数据集中所包含的数据类型的SchemaName
一经指定不允许修改 */
    schema_name!: string;
    /** 对应“ByPattern”模式的索引名称表达式 */
    pattern!: string | undefined;

    constructor(data?: IExternalYSLogDataSetObjectEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cluster_id = _data["cluster_id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.schema_name = _data["schema_name"];
            this.pattern = _data["pattern"];
        }
    }

    static fromJS(data: any): ExternalYSLogDataSetObjectEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalYSLogDataSetObjectEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cluster_id"] = this.cluster_id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["schema_name"] = this.schema_name;
        data["pattern"] = this.pattern;
        return data; 
    }
}

export interface IExternalYSLogDataSetObjectEditDto {
    /** Id */
    id: number | undefined;
    /** 关联的ES集群Id */
    cluster_id: number;
    /** 名称 */
    name: string;
    /** 描述 */
    description: string | undefined;
    /** 该数据集中所包含的数据类型的SchemaName
一经指定不允许修改 */
    schema_name: string;
    /** 对应“ByPattern”模式的索引名称表达式 */
    pattern: string | undefined;
}

export class CreateOrUpdateExternalYSLogDataSetObjectInput implements ICreateOrUpdateExternalYSLogDataSetObjectInput {
    ysLogDataSetObject!: ExternalYSLogDataSetObjectEditDto;

    constructor(data?: ICreateOrUpdateExternalYSLogDataSetObjectInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ysLogDataSetObject = new ExternalYSLogDataSetObjectEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ysLogDataSetObject = _data["ysLogDataSetObject"] ? ExternalYSLogDataSetObjectEditDto.fromJS(_data["ysLogDataSetObject"]) : new ExternalYSLogDataSetObjectEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateExternalYSLogDataSetObjectInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateExternalYSLogDataSetObjectInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ysLogDataSetObject"] = this.ysLogDataSetObject ? this.ysLogDataSetObject.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateOrUpdateExternalYSLogDataSetObjectInput {
    ysLogDataSetObject: ExternalYSLogDataSetObjectEditDto;
}

export enum AuthencationMethod {
    None = "None",
    BasicAuthentication = "BasicAuthentication",
}

/** 管理平台记录已知/注册的ES集群 目前只考虑1个集群（即本地127.0.0.1:9200），通过Seed指定，无法删除。 开发时可以换成其他测试集群。 目前也不需要考虑开放增删改查功能。 */
export class YSLogESClusterObject implements IYSLogESClusterObject {
    /** ES集群标识符，短 */
    name!: string | undefined;
    /** ES集群地址（host或ip均可，host就是主机名）
目前暂时不对属性值作校验
后续有需求的话再判断
如果是IP地址，则直接使用
如果不是IP地址，则尝试作主机名/域名解析
网络层的API本来就支持这样的业务逻辑，如果不支持则自行实现 */
    host!: string | undefined;
    /** ES集群端口 */
    port!: number;
    /** 是否启用了https */
    http_enabled!: boolean;
    authencation_method!: AuthencationMethod;
    /** 用户名或id */
    user!: string | undefined;
    /** 密码或apikey */
    password!: string | undefined;
    id!: number;

    constructor(data?: IYSLogESClusterObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.host = _data["host"];
            this.port = _data["port"];
            this.http_enabled = _data["http_enabled"];
            this.authencation_method = _data["authencation_method"];
            this.user = _data["user"];
            this.password = _data["password"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): YSLogESClusterObject {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogESClusterObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["host"] = this.host;
        data["port"] = this.port;
        data["http_enabled"] = this.http_enabled;
        data["authencation_method"] = this.authencation_method;
        data["user"] = this.user;
        data["password"] = this.password;
        data["id"] = this.id;
        return data; 
    }
}

/** 管理平台记录已知/注册的ES集群 目前只考虑1个集群（即本地127.0.0.1:9200），通过Seed指定，无法删除。 开发时可以换成其他测试集群。 目前也不需要考虑开放增删改查功能。 */
export interface IYSLogESClusterObject {
    /** ES集群标识符，短 */
    name: string | undefined;
    /** ES集群地址（host或ip均可，host就是主机名）
目前暂时不对属性值作校验
后续有需求的话再判断
如果是IP地址，则直接使用
如果不是IP地址，则尝试作主机名/域名解析
网络层的API本来就支持这样的业务逻辑，如果不支持则自行实现 */
    host: string | undefined;
    /** ES集群端口 */
    port: number;
    /** 是否启用了https */
    http_enabled: boolean;
    authencation_method: AuthencationMethod;
    /** 用户名或id */
    user: string | undefined;
    /** 密码或apikey */
    password: string | undefined;
    id: number;
}

export class KeyValuePairOfStringString implements IKeyValuePairOfStringString {
    key!: string | undefined;
    value!: string | undefined;

    constructor(data?: IKeyValuePairOfStringString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): KeyValuePairOfStringString {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValuePairOfStringString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface IKeyValuePairOfStringString {
    key: string | undefined;
    value: string | undefined;
}

export enum IndexMatchMode {
    ByPattern = "ByPattern",
    ByAlias = "ByAlias",
}

export class ExternalYSLogDataSetObjectListDto implements IExternalYSLogDataSetObjectListDto {
    /** 关联的数据集Id */
    cluster_id!: number;
    cluster!: YSLogESClusterObject;
    /** 数据集名称 */
    name!: string | undefined;
    /** 数据集描述 */
    description!: string | undefined;
    /** 该数据集中所包含的数据类型的SchemaName */
    schema_name!: string | undefined;
    schema_name_pair!: KeyValuePairOfStringString;
    match_mode!: IndexMatchMode;
    /** 对应“ByPattern”模式的索引名称表达式 */
    pattern!: string | undefined;
    /** 该数据集包含的索引数量 */
    index_number!: number;
    /** 该数据集索引包含的文档数量 */
    doc_number!: number;
    /** 该数据集索引的存储空间 */
    store_size!: string | undefined;
    id!: number;

    constructor(data?: IExternalYSLogDataSetObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cluster_id = _data["cluster_id"];
            this.cluster = _data["cluster"] ? YSLogESClusterObject.fromJS(_data["cluster"]) : <any>undefined;
            this.name = _data["name"];
            this.description = _data["description"];
            this.schema_name = _data["schema_name"];
            this.schema_name_pair = _data["schema_name_pair"] ? KeyValuePairOfStringString.fromJS(_data["schema_name_pair"]) : <any>undefined;
            this.match_mode = _data["match_mode"];
            this.pattern = _data["pattern"];
            this.index_number = _data["index_number"];
            this.doc_number = _data["doc_number"];
            this.store_size = _data["store_size"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ExternalYSLogDataSetObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalYSLogDataSetObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cluster_id"] = this.cluster_id;
        data["cluster"] = this.cluster ? this.cluster.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        data["schema_name"] = this.schema_name;
        data["schema_name_pair"] = this.schema_name_pair ? this.schema_name_pair.toJSON() : <any>undefined;
        data["match_mode"] = this.match_mode;
        data["pattern"] = this.pattern;
        data["index_number"] = this.index_number;
        data["doc_number"] = this.doc_number;
        data["store_size"] = this.store_size;
        data["id"] = this.id;
        return data; 
    }
}

export interface IExternalYSLogDataSetObjectListDto {
    /** 关联的数据集Id */
    cluster_id: number;
    cluster: YSLogESClusterObject;
    /** 数据集名称 */
    name: string | undefined;
    /** 数据集描述 */
    description: string | undefined;
    /** 该数据集中所包含的数据类型的SchemaName */
    schema_name: string | undefined;
    schema_name_pair: KeyValuePairOfStringString;
    match_mode: IndexMatchMode;
    /** 对应“ByPattern”模式的索引名称表达式 */
    pattern: string | undefined;
    /** 该数据集包含的索引数量 */
    index_number: number;
    /** 该数据集索引包含的文档数量 */
    doc_number: number;
    /** 该数据集索引的存储空间 */
    store_size: string | undefined;
    id: number;
}

export class GetExternalYSLogDataSetObjectForEditOutput implements IGetExternalYSLogDataSetObjectForEditOutput {
    data_set!: ExternalYSLogDataSetObjectEditDto;

    constructor(data?: IGetExternalYSLogDataSetObjectForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data_set = _data["data_set"] ? ExternalYSLogDataSetObjectEditDto.fromJS(_data["data_set"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetExternalYSLogDataSetObjectForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetExternalYSLogDataSetObjectForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data_set"] = this.data_set ? this.data_set.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetExternalYSLogDataSetObjectForEditOutput {
    data_set: ExternalYSLogDataSetObjectEditDto;
}

export class PagedResultDtoOfExternalYSLogDataSetObjectListDto implements IPagedResultDtoOfExternalYSLogDataSetObjectListDto {
    totalCount!: number;
    items!: ExternalYSLogDataSetObjectListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfExternalYSLogDataSetObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExternalYSLogDataSetObjectListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfExternalYSLogDataSetObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfExternalYSLogDataSetObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfExternalYSLogDataSetObjectListDto {
    totalCount: number;
    items: ExternalYSLogDataSetObjectListDto[] | undefined;
}

/** 用户登录尝试 */
export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName!: string | undefined;
    userName!: string | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    result!: string | undefined;
    creationTime!: moment.Moment;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.userName = _data["userName"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.browserInfo = _data["browserInfo"];
            this.result = _data["result"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

/** 用户登录尝试 */
export interface IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userName: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: moment.Moment;
}

export class ListResultDtoOfUserLoginAttemptDto implements IListResultDtoOfUserLoginAttemptDto {
    items!: UserLoginAttemptDto[] | undefined;

    constructor(data?: IListResultDtoOfUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;
}

export class EntityDtoOfString implements IEntityDtoOfString {
    id!: string | undefined;

    constructor(data?: IEntityDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfString {
    id: string | undefined;
}

/** HostCache的Dto */
export class HostCacheDto implements IHostCacheDto {
    name!: string | undefined;

    constructor(data?: IHostCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): HostCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

/** HostCache的Dto */
export interface IHostCacheDto {
    name: string | undefined;
}

export class ListResultDtoOfHostCacheDto implements IListResultDtoOfHostCacheDto {
    items!: HostCacheDto[] | undefined;

    constructor(data?: IListResultDtoOfHostCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(HostCacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfHostCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfHostCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfHostCacheDto {
    items: HostCacheDto[] | undefined;
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
    id!: number;

    constructor(data?: IEntityDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfInt64 {
    id: number;
}

export enum InternalRotatePolicy {
    RotateByAge = "RotateByAge",
    RotateBySize = "RotateBySize",
    RotateByAgeAndSize = "RotateByAgeAndSize",
}

/** 编辑数据集对象的Dto YSLog.WebManagement.DataSet.Entities.YSLogDataSetObject */
export class InternalYSLogDataSetObjectEditDto implements IInternalYSLogDataSetObjectEditDto {
    /** Id */
    id!: number | undefined;
    /** 关联的ES集群Id */
    cluster_id!: number;
    /** 名称 */
    name!: string;
    /** 描述 */
    description!: string | undefined;
    /** 该数据集中所包含的数据类型的SchemaName
一经指定不允许修改 */
    schema_name!: string;
    rotate_policy!: InternalRotatePolicy;
    /** 索引更替策略中的时间阈值
单位为天 */
    age_threshold!: number;
    /** 索引更替策略中的容量阈值
单位为GB */
    size_threshold!: number;

    constructor(data?: IInternalYSLogDataSetObjectEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cluster_id = _data["cluster_id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.schema_name = _data["schema_name"];
            this.rotate_policy = _data["rotate_policy"];
            this.age_threshold = _data["age_threshold"];
            this.size_threshold = _data["size_threshold"];
        }
    }

    static fromJS(data: any): InternalYSLogDataSetObjectEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new InternalYSLogDataSetObjectEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cluster_id"] = this.cluster_id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["schema_name"] = this.schema_name;
        data["rotate_policy"] = this.rotate_policy;
        data["age_threshold"] = this.age_threshold;
        data["size_threshold"] = this.size_threshold;
        return data; 
    }
}

/** 编辑数据集对象的Dto YSLog.WebManagement.DataSet.Entities.YSLogDataSetObject */
export interface IInternalYSLogDataSetObjectEditDto {
    /** Id */
    id: number | undefined;
    /** 关联的ES集群Id */
    cluster_id: number;
    /** 名称 */
    name: string;
    /** 描述 */
    description: string | undefined;
    /** 该数据集中所包含的数据类型的SchemaName
一经指定不允许修改 */
    schema_name: string;
    rotate_policy: InternalRotatePolicy;
    /** 索引更替策略中的时间阈值
单位为天 */
    age_threshold: number;
    /** 索引更替策略中的容量阈值
单位为GB */
    size_threshold: number;
}

/** 更新/创建数据集对象的dto */
export class CreateOrUpdateInternalYSLogDataSetObjectInput implements ICreateOrUpdateInternalYSLogDataSetObjectInput {
    ysLogDataSetObject!: InternalYSLogDataSetObjectEditDto;

    constructor(data?: ICreateOrUpdateInternalYSLogDataSetObjectInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ysLogDataSetObject = new InternalYSLogDataSetObjectEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ysLogDataSetObject = _data["ysLogDataSetObject"] ? InternalYSLogDataSetObjectEditDto.fromJS(_data["ysLogDataSetObject"]) : new InternalYSLogDataSetObjectEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateInternalYSLogDataSetObjectInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateInternalYSLogDataSetObjectInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ysLogDataSetObject"] = this.ysLogDataSetObject ? this.ysLogDataSetObject.toJSON() : <any>undefined;
        return data; 
    }
}

/** 更新/创建数据集对象的dto */
export interface ICreateOrUpdateInternalYSLogDataSetObjectInput {
    ysLogDataSetObject: InternalYSLogDataSetObjectEditDto;
}

/** 数据集列表的Dto YSLog.WebManagement.DataSet.Entities.YSLogDataSetObject */
export class InternalYSLogDataSetObjectListDto implements IInternalYSLogDataSetObjectListDto {
    /** 关联的数据集Id */
    cluster_id!: number;
    cluster!: YSLogESClusterObject;
    /** 数据集名称 */
    name!: string | undefined;
    /** 数据集描述 */
    description!: string | undefined;
    /** 该数据集中所包含的数据类型的SchemaName */
    schema_name!: string | undefined;
    schema_name_pair!: KeyValuePairOfStringString;
    match_mode!: IndexMatchMode;
    /** 对应“ByAlias”模式的读索引别名 */
    read_alias!: string | undefined;
    rotate_policy!: InternalRotatePolicy;
    /** 索引更替策略中的时间阈值
单位为天 */
    age_threshold!: number;
    /** 索引更替策略中的容量阈值
单位为GB */
    size_threshold!: number;
    /** 该数据集包含的索引数量 */
    index_number!: number;
    /** 该数据集索引包含的文档数量 */
    doc_number!: number;
    /** 该数据集索引的存储空间 */
    store_size!: string | undefined;
    id!: number;

    constructor(data?: IInternalYSLogDataSetObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cluster_id = _data["cluster_id"];
            this.cluster = _data["cluster"] ? YSLogESClusterObject.fromJS(_data["cluster"]) : <any>undefined;
            this.name = _data["name"];
            this.description = _data["description"];
            this.schema_name = _data["schema_name"];
            this.schema_name_pair = _data["schema_name_pair"] ? KeyValuePairOfStringString.fromJS(_data["schema_name_pair"]) : <any>undefined;
            this.match_mode = _data["match_mode"];
            this.read_alias = _data["read_alias"];
            this.rotate_policy = _data["rotate_policy"];
            this.age_threshold = _data["age_threshold"];
            this.size_threshold = _data["size_threshold"];
            this.index_number = _data["index_number"];
            this.doc_number = _data["doc_number"];
            this.store_size = _data["store_size"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): InternalYSLogDataSetObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new InternalYSLogDataSetObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cluster_id"] = this.cluster_id;
        data["cluster"] = this.cluster ? this.cluster.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        data["schema_name"] = this.schema_name;
        data["schema_name_pair"] = this.schema_name_pair ? this.schema_name_pair.toJSON() : <any>undefined;
        data["match_mode"] = this.match_mode;
        data["read_alias"] = this.read_alias;
        data["rotate_policy"] = this.rotate_policy;
        data["age_threshold"] = this.age_threshold;
        data["size_threshold"] = this.size_threshold;
        data["index_number"] = this.index_number;
        data["doc_number"] = this.doc_number;
        data["store_size"] = this.store_size;
        data["id"] = this.id;
        return data; 
    }
}

/** 数据集列表的Dto YSLog.WebManagement.DataSet.Entities.YSLogDataSetObject */
export interface IInternalYSLogDataSetObjectListDto {
    /** 关联的数据集Id */
    cluster_id: number;
    cluster: YSLogESClusterObject;
    /** 数据集名称 */
    name: string | undefined;
    /** 数据集描述 */
    description: string | undefined;
    /** 该数据集中所包含的数据类型的SchemaName */
    schema_name: string | undefined;
    schema_name_pair: KeyValuePairOfStringString;
    match_mode: IndexMatchMode;
    /** 对应“ByAlias”模式的读索引别名 */
    read_alias: string | undefined;
    rotate_policy: InternalRotatePolicy;
    /** 索引更替策略中的时间阈值
单位为天 */
    age_threshold: number;
    /** 索引更替策略中的容量阈值
单位为GB */
    size_threshold: number;
    /** 该数据集包含的索引数量 */
    index_number: number;
    /** 该数据集索引包含的文档数量 */
    doc_number: number;
    /** 该数据集索引的存储空间 */
    store_size: string | undefined;
    id: number;
}

/** 更新/编辑数据集对象的模板Dto */
export class GetInternalYSLogDataSetObjectForEditOutput implements IGetInternalYSLogDataSetObjectForEditOutput {
    data_set!: InternalYSLogDataSetObjectEditDto;
    schema_name_enum!: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetInternalYSLogDataSetObjectForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data_set = _data["data_set"] ? InternalYSLogDataSetObjectEditDto.fromJS(_data["data_set"]) : <any>undefined;
            if (Array.isArray(_data["schema_name_enum"])) {
                this.schema_name_enum = [] as any;
                for (let item of _data["schema_name_enum"])
                    this.schema_name_enum!.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetInternalYSLogDataSetObjectForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetInternalYSLogDataSetObjectForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data_set"] = this.data_set ? this.data_set.toJSON() : <any>undefined;
        if (Array.isArray(this.schema_name_enum)) {
            data["schema_name_enum"] = [];
            for (let item of this.schema_name_enum)
                data["schema_name_enum"].push(item.toJSON());
        }
        return data; 
    }
}

/** 更新/编辑数据集对象的模板Dto */
export interface IGetInternalYSLogDataSetObjectForEditOutput {
    data_set: InternalYSLogDataSetObjectEditDto;
    schema_name_enum: KeyValuePairOfStringString[] | undefined;
}

export class PagedResultDtoOfInternalYSLogDataSetObjectListDto implements IPagedResultDtoOfInternalYSLogDataSetObjectListDto {
    totalCount!: number;
    items!: InternalYSLogDataSetObjectListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfInternalYSLogDataSetObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InternalYSLogDataSetObjectListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfInternalYSLogDataSetObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfInternalYSLogDataSetObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfInternalYSLogDataSetObjectListDto {
    totalCount: number;
    items: InternalYSLogDataSetObjectListDto[] | undefined;
}

export class LanguageEditDto implements ILanguageEditDto {
    id!: number | undefined;
    name!: string;
    icon!: string | undefined;
    isEnabled!: boolean;

    constructor(data?: ILanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.icon = _data["icon"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): LanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }
}

export interface ILanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language!: LanguageEditDto;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new LanguageEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"] ? LanguageEditDto.fromJS(_data["language"]) : new LanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: LanguageEditDto;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.displayText = _data["displayText"];
            this.isSelected = _data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language!: LanguageEditDto;
    /** 所有的语言名称 */
    languageNames!: ComboboxItemDto[] | undefined;
    /** 所有的国旗 */
    flags!: ComboboxItemDto[] | undefined;

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"] ? LanguageEditDto.fromJS(_data["language"]) : <any>undefined;
            if (Array.isArray(_data["languageNames"])) {
                this.languageNames = [] as any;
                for (let item of _data["languageNames"])
                    this.languageNames!.push(ComboboxItemDto.fromJS(item));
            }
            if (Array.isArray(_data["flags"])) {
                this.flags = [] as any;
                for (let item of _data["flags"])
                    this.flags!.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (Array.isArray(this.languageNames)) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (Array.isArray(this.flags)) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguageForEditOutput {
    language: LanguageEditDto;
    /** 所有的语言名称 */
    languageNames: ComboboxItemDto[] | undefined;
    /** 所有的国旗 */
    flags: ComboboxItemDto[] | undefined;
}

export class LanguageListDto implements ILanguageListDto {
    tenantId!: number | undefined;
    /** 名称 */
    name!: string | undefined;
    /** 显示名称 */
    displayName!: string | undefined;
    /** 图标 */
    icon!: string | undefined;
    isDisabled!: boolean;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ILanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.icon = _data["icon"];
            this.isDisabled = _data["isDisabled"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILanguageListDto {
    tenantId: number | undefined;
    /** 名称 */
    name: string | undefined;
    /** 显示名称 */
    displayName: string | undefined;
    /** 图标 */
    icon: string | undefined;
    isDisabled: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    /** 默认语言名称 */
    defaultLanguageName!: string | undefined;
    items!: LanguageListDto[] | undefined;

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultLanguageName = _data["defaultLanguageName"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguagesOutput {
    /** 默认语言名称 */
    defaultLanguageName: string | undefined;
    items: LanguageListDto[] | undefined;
}

export class LanguageTextListDto implements ILanguageTextListDto {
    /** 键 */
    key!: string | undefined;
    /** 原始值 */
    baseValue!: string | undefined;
    /** 目标值 */
    targetValue!: string | undefined;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.baseValue = _data["baseValue"];
            this.targetValue = _data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data; 
    }
}

export interface ILanguageTextListDto {
    /** 键 */
    key: string | undefined;
    /** 原始值 */
    baseValue: string | undefined;
    /** 目标值 */
    targetValue: string | undefined;
}

export class PagedResultDtoOfLanguageTextListDto implements IPagedResultDtoOfLanguageTextListDto {
    totalCount!: number;
    items!: LanguageTextListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLanguageTextListDto {
    totalCount: number;
    items: LanguageTextListDto[] | undefined;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name!: string;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ISetDefaultLanguageInput {
    name: string;
}

/** 更新语言输入信息 */
export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    languageName!: string;
    sourceName!: string;
    /** 键 */
    key!: string;
    /** 值 */
    value!: string;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
            this.sourceName = _data["sourceName"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

/** 更新语言输入信息 */
export interface IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    /** 键 */
    key: string;
    /** 值 */
    value: string;
}

export class BackupNetworkSettingsListDto implements IBackupNetworkSettingsListDto {
    interfaceName!: string | undefined;
    displayName!: string | undefined;
    ipAddress!: string | undefined;
    networkMask!: string | undefined;
    gateway!: string | undefined;
    dnsAddress!: string | undefined;

    constructor(data?: IBackupNetworkSettingsListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.interfaceName = _data["interfaceName"];
            this.displayName = _data["displayName"];
            this.ipAddress = _data["ipAddress"];
            this.networkMask = _data["networkMask"];
            this.gateway = _data["gateway"];
            this.dnsAddress = _data["dnsAddress"];
        }
    }

    static fromJS(data: any): BackupNetworkSettingsListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BackupNetworkSettingsListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["interfaceName"] = this.interfaceName;
        data["displayName"] = this.displayName;
        data["ipAddress"] = this.ipAddress;
        data["networkMask"] = this.networkMask;
        data["gateway"] = this.gateway;
        data["dnsAddress"] = this.dnsAddress;
        return data; 
    }
}

export interface IBackupNetworkSettingsListDto {
    interfaceName: string | undefined;
    displayName: string | undefined;
    ipAddress: string | undefined;
    networkMask: string | undefined;
    gateway: string | undefined;
    dnsAddress: string | undefined;
}

export class NetworkSettingsListDto implements INetworkSettingsListDto {
    displayName!: string | undefined;
    ipAddress!: string | undefined;
    networkMask!: string | undefined;
    gateway!: string | undefined;
    dnsAddress!: string | undefined;

    constructor(data?: INetworkSettingsListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.ipAddress = _data["ipAddress"];
            this.networkMask = _data["networkMask"];
            this.gateway = _data["gateway"];
            this.dnsAddress = _data["dnsAddress"];
        }
    }

    static fromJS(data: any): NetworkSettingsListDto {
        data = typeof data === 'object' ? data : {};
        let result = new NetworkSettingsListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["ipAddress"] = this.ipAddress;
        data["networkMask"] = this.networkMask;
        data["gateway"] = this.gateway;
        data["dnsAddress"] = this.dnsAddress;
        return data; 
    }
}

export interface INetworkSettingsListDto {
    displayName: string | undefined;
    ipAddress: string | undefined;
    networkMask: string | undefined;
    gateway: string | undefined;
    dnsAddress: string | undefined;
}

export class NetworkSettingsEditDto implements INetworkSettingsEditDto {
    ipAddress!: string;
    networkMask!: string;
    gateway!: string;
    dnsAddress!: string;

    constructor(data?: INetworkSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ipAddress = _data["ipAddress"];
            this.networkMask = _data["networkMask"];
            this.gateway = _data["gateway"];
            this.dnsAddress = _data["dnsAddress"];
        }
    }

    static fromJS(data: any): NetworkSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new NetworkSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ipAddress"] = this.ipAddress;
        data["networkMask"] = this.networkMask;
        data["gateway"] = this.gateway;
        data["dnsAddress"] = this.dnsAddress;
        return data; 
    }
}

export interface INetworkSettingsEditDto {
    ipAddress: string;
    networkMask: string;
    gateway: string;
    dnsAddress: string;
}

export class NetworkSettingsResultDto implements INetworkSettingsResultDto {
    needRefresh!: boolean;
    newSettings!: NetworkSettingsListDto;

    constructor(data?: INetworkSettingsResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.needRefresh = _data["needRefresh"];
            this.newSettings = _data["newSettings"] ? NetworkSettingsListDto.fromJS(_data["newSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NetworkSettingsResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NetworkSettingsResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["needRefresh"] = this.needRefresh;
        data["newSettings"] = this.newSettings ? this.newSettings.toJSON() : <any>undefined;
        return data; 
    }
}

export interface INetworkSettingsResultDto {
    needRefresh: boolean;
    newSettings: NetworkSettingsListDto;
}

export class SecurityLoginSettingsDto implements ISecurityLoginSettingsDto {
    enableCapthaOnLogin!: boolean | undefined;
    enableLockOutForNewUsers!: boolean | undefined;
    enableLockOutForClientIp!: boolean | undefined;
    userLockOutThreshold!: number | undefined;
    clientIpLockOutThreshold!: number | undefined;
    userLockOutDuration!: number | undefined;
    clientIpLockOutDuration!: number | undefined;
    maxLoginOutDuration!: number | undefined;

    constructor(data?: ISecurityLoginSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enableCapthaOnLogin = _data["enableCapthaOnLogin"];
            this.enableLockOutForNewUsers = _data["enableLockOutForNewUsers"];
            this.enableLockOutForClientIp = _data["enableLockOutForClientIp"];
            this.userLockOutThreshold = _data["userLockOutThreshold"];
            this.clientIpLockOutThreshold = _data["clientIpLockOutThreshold"];
            this.userLockOutDuration = _data["userLockOutDuration"];
            this.clientIpLockOutDuration = _data["clientIpLockOutDuration"];
            this.maxLoginOutDuration = _data["maxLoginOutDuration"];
        }
    }

    static fromJS(data: any): SecurityLoginSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityLoginSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enableCapthaOnLogin"] = this.enableCapthaOnLogin;
        data["enableLockOutForNewUsers"] = this.enableLockOutForNewUsers;
        data["enableLockOutForClientIp"] = this.enableLockOutForClientIp;
        data["userLockOutThreshold"] = this.userLockOutThreshold;
        data["clientIpLockOutThreshold"] = this.clientIpLockOutThreshold;
        data["userLockOutDuration"] = this.userLockOutDuration;
        data["clientIpLockOutDuration"] = this.clientIpLockOutDuration;
        data["maxLoginOutDuration"] = this.maxLoginOutDuration;
        return data; 
    }
}

export interface ISecurityLoginSettingsDto {
    enableCapthaOnLogin: boolean | undefined;
    enableLockOutForNewUsers: boolean | undefined;
    enableLockOutForClientIp: boolean | undefined;
    userLockOutThreshold: number | undefined;
    clientIpLockOutThreshold: number | undefined;
    userLockOutDuration: number | undefined;
    clientIpLockOutDuration: number | undefined;
    maxLoginOutDuration: number | undefined;
}

export class SecurityPasswordSettingsDto implements ISecurityPasswordSettingsDto {
    requireDigit!: boolean | undefined;
    requireUpperCase!: boolean | undefined;
    requireLowerCase!: boolean | undefined;
    requireNonAlphanumeric!: boolean | undefined;
    minimumLength!: number | undefined;

    constructor(data?: ISecurityPasswordSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requireDigit = _data["requireDigit"];
            this.requireUpperCase = _data["requireUpperCase"];
            this.requireLowerCase = _data["requireLowerCase"];
            this.requireNonAlphanumeric = _data["requireNonAlphanumeric"];
            this.minimumLength = _data["minimumLength"];
        }
    }

    static fromJS(data: any): SecurityPasswordSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityPasswordSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireDigit"] = this.requireDigit;
        data["requireUpperCase"] = this.requireUpperCase;
        data["requireLowerCase"] = this.requireLowerCase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["minimumLength"] = this.minimumLength;
        return data; 
    }
}

export interface ISecurityPasswordSettingsDto {
    requireDigit: boolean | undefined;
    requireUpperCase: boolean | undefined;
    requireLowerCase: boolean | undefined;
    requireNonAlphanumeric: boolean | undefined;
    minimumLength: number | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    needToChangeThePassword!: boolean;
    id!: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.needToChangeThePassword = _data["needToChangeThePassword"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["needToChangeThePassword"] = this.needToChangeThePassword;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    needToChangeThePassword: boolean;
    id: number;
}

export class ContactInfo implements IContactInfo {
    contactName!: string | undefined;
    companyName!: string | undefined;
    country!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    postCode!: string | undefined;
    phoneNumber!: string | undefined;
    emailAddress!: string | undefined;
    addressDetail!: string | undefined;

    constructor(data?: IContactInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactName = _data["contactName"];
            this.companyName = _data["companyName"];
            this.country = _data["country"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.postCode = _data["postCode"];
            this.phoneNumber = _data["phoneNumber"];
            this.emailAddress = _data["emailAddress"];
            this.addressDetail = _data["addressDetail"];
        }
    }

    static fromJS(data: any): ContactInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactName"] = this.contactName;
        data["companyName"] = this.companyName;
        data["country"] = this.country;
        data["province"] = this.province;
        data["city"] = this.city;
        data["postCode"] = this.postCode;
        data["phoneNumber"] = this.phoneNumber;
        data["emailAddress"] = this.emailAddress;
        data["addressDetail"] = this.addressDetail;
        return data; 
    }
}

export interface IContactInfo {
    contactName: string | undefined;
    companyName: string | undefined;
    country: string | undefined;
    province: string | undefined;
    city: string | undefined;
    postCode: string | undefined;
    phoneNumber: string | undefined;
    emailAddress: string | undefined;
    addressDetail: string | undefined;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    contactInfo!: ContactInfo;
    creationTime!: moment.Moment;
    creationTimeString!: string | undefined;
    id!: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.contactInfo = _data["contactInfo"] ? ContactInfo.fromJS(_data["contactInfo"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creationTimeString = _data["creationTimeString"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["contactInfo"] = this.contactInfo ? this.contactInfo.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creationTimeString"] = this.creationTimeString;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    contactInfo: ContactInfo;
    creationTime: moment.Moment;
    creationTimeString: string | undefined;
    id: number;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version!: string | undefined;
    releaseDate!: moment.Moment;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user!: UserLoginInfoDto;
    tenant!: TenantLoginInfoDto;
    application!: ApplicationInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
    application: ApplicationInfoDto;
}

export enum MultiTenancySides {
    Tenant = "Tenant",
    Host = "Host",
}

export class AbpMultiTenancySidesConfigDto implements IAbpMultiTenancySidesConfigDto {
    host!: MultiTenancySides;
    tenant!: MultiTenancySides;

    constructor(data?: IAbpMultiTenancySidesConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.host = _data["host"];
            this.tenant = _data["tenant"];
        }
    }

    static fromJS(data: any): AbpMultiTenancySidesConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpMultiTenancySidesConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["host"] = this.host;
        data["tenant"] = this.tenant;
        return data; 
    }
}

export interface IAbpMultiTenancySidesConfigDto {
    host: MultiTenancySides;
    tenant: MultiTenancySides;
}

export class AbpMultiTenancyConfigDto implements IAbpMultiTenancyConfigDto {
    isEnabled!: boolean;
    ignoreFeatureCheckForHostUsers!: boolean;
    sides!: AbpMultiTenancySidesConfigDto;

    constructor(data?: IAbpMultiTenancyConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
            this.ignoreFeatureCheckForHostUsers = _data["ignoreFeatureCheckForHostUsers"];
            this.sides = _data["sides"] ? AbpMultiTenancySidesConfigDto.fromJS(_data["sides"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AbpMultiTenancyConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpMultiTenancyConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["ignoreFeatureCheckForHostUsers"] = this.ignoreFeatureCheckForHostUsers;
        data["sides"] = this.sides ? this.sides.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAbpMultiTenancyConfigDto {
    isEnabled: boolean;
    ignoreFeatureCheckForHostUsers: boolean;
    sides: AbpMultiTenancySidesConfigDto;
}

export class AbpUserSessionConfigDto implements IAbpUserSessionConfigDto {
    userId!: number | undefined;
    tenantId!: number | undefined;
    impersonatorUserId!: number | undefined;
    impersonatorTenantId!: number | undefined;
    multiTenancySide!: MultiTenancySides;

    constructor(data?: IAbpUserSessionConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.impersonatorUserId = _data["impersonatorUserId"];
            this.impersonatorTenantId = _data["impersonatorTenantId"];
            this.multiTenancySide = _data["multiTenancySide"];
        }
    }

    static fromJS(data: any): AbpUserSessionConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserSessionConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["multiTenancySide"] = this.multiTenancySide;
        return data; 
    }
}

export interface IAbpUserSessionConfigDto {
    userId: number | undefined;
    tenantId: number | undefined;
    impersonatorUserId: number | undefined;
    impersonatorTenantId: number | undefined;
    multiTenancySide: MultiTenancySides;
}

export class AbpUserCurrentCultureConfigDto implements IAbpUserCurrentCultureConfigDto {
    name!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IAbpUserCurrentCultureConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): AbpUserCurrentCultureConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserCurrentCultureConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAbpUserCurrentCultureConfigDto {
    name: string | undefined;
    displayName: string | undefined;
}

export class LanguageInfo implements ILanguageInfo {
    name!: string | undefined;
    displayName!: string | undefined;
    icon!: string | undefined;
    isDefault!: boolean;
    isDisabled!: boolean;
    readonly isRightToLeft!: boolean;

    constructor(data?: ILanguageInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.icon = _data["icon"];
            this.isDefault = _data["isDefault"];
            this.isDisabled = _data["isDisabled"];
            (<any>this).isRightToLeft = _data["isRightToLeft"];
        }
    }

    static fromJS(data: any): LanguageInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDefault"] = this.isDefault;
        data["isDisabled"] = this.isDisabled;
        data["isRightToLeft"] = this.isRightToLeft;
        return data; 
    }
}

export interface ILanguageInfo {
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDefault: boolean;
    isDisabled: boolean;
    isRightToLeft: boolean;
}

export class AbpLocalizationSourceDto implements IAbpLocalizationSourceDto {
    name!: string | undefined;
    type!: string | undefined;

    constructor(data?: IAbpLocalizationSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): AbpLocalizationSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpLocalizationSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        return data; 
    }
}

export interface IAbpLocalizationSourceDto {
    name: string | undefined;
    type: string | undefined;
}

export class AbpUserLocalizationConfigDto implements IAbpUserLocalizationConfigDto {
    currentCulture!: AbpUserCurrentCultureConfigDto;
    languages!: LanguageInfo[] | undefined;
    currentLanguage!: LanguageInfo;
    sources!: AbpLocalizationSourceDto[] | undefined;
    values!: { [key: string]: { [key: string]: string; }; } | undefined;

    constructor(data?: IAbpUserLocalizationConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentCulture = _data["currentCulture"] ? AbpUserCurrentCultureConfigDto.fromJS(_data["currentCulture"]) : <any>undefined;
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(LanguageInfo.fromJS(item));
            }
            this.currentLanguage = _data["currentLanguage"] ? LanguageInfo.fromJS(_data["currentLanguage"]) : <any>undefined;
            if (Array.isArray(_data["sources"])) {
                this.sources = [] as any;
                for (let item of _data["sources"])
                    this.sources!.push(AbpLocalizationSourceDto.fromJS(item));
            }
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        this.values![key] = _data["values"][key] !== undefined ? _data["values"][key] : {};
                }
            }
        }
    }

    static fromJS(data: any): AbpUserLocalizationConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserLocalizationConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentCulture"] = this.currentCulture ? this.currentCulture.toJSON() : <any>undefined;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        data["currentLanguage"] = this.currentLanguage ? this.currentLanguage.toJSON() : <any>undefined;
        if (Array.isArray(this.sources)) {
            data["sources"] = [];
            for (let item of this.sources)
                data["sources"].push(item.toJSON());
        }
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    data["values"][key] = this.values[key];
            }
        }
        return data; 
    }
}

export interface IAbpUserLocalizationConfigDto {
    currentCulture: AbpUserCurrentCultureConfigDto;
    languages: LanguageInfo[] | undefined;
    currentLanguage: LanguageInfo;
    sources: AbpLocalizationSourceDto[] | undefined;
    values: { [key: string]: { [key: string]: string; }; } | undefined;
}

export class AbpStringValueDto implements IAbpStringValueDto {
    value!: string | undefined;

    constructor(data?: IAbpStringValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): AbpStringValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpStringValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data; 
    }
}

export interface IAbpStringValueDto {
    value: string | undefined;
}

export class AbpUserFeatureConfigDto implements IAbpUserFeatureConfigDto {
    allFeatures!: { [key: string]: AbpStringValueDto; } | undefined;

    constructor(data?: IAbpUserFeatureConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["allFeatures"]) {
                this.allFeatures = {} as any;
                for (let key in _data["allFeatures"]) {
                    if (_data["allFeatures"].hasOwnProperty(key))
                        this.allFeatures![key] = _data["allFeatures"][key] ? AbpStringValueDto.fromJS(_data["allFeatures"][key]) : new AbpStringValueDto();
                }
            }
        }
    }

    static fromJS(data: any): AbpUserFeatureConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserFeatureConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.allFeatures) {
            data["allFeatures"] = {};
            for (let key in this.allFeatures) {
                if (this.allFeatures.hasOwnProperty(key))
                    data["allFeatures"][key] = this.allFeatures[key] ? this.allFeatures[key].toJSON() : <any>undefined;
            }
        }
        return data; 
    }
}

export interface IAbpUserFeatureConfigDto {
    allFeatures: { [key: string]: AbpStringValueDto; } | undefined;
}

export class AbpUserAuthConfigDto implements IAbpUserAuthConfigDto {
    allPermissions!: { [key: string]: string; } | undefined;
    grantedPermissions!: { [key: string]: string; } | undefined;

    constructor(data?: IAbpUserAuthConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["allPermissions"]) {
                this.allPermissions = {} as any;
                for (let key in _data["allPermissions"]) {
                    if (_data["allPermissions"].hasOwnProperty(key))
                        this.allPermissions![key] = _data["allPermissions"][key];
                }
            }
            if (_data["grantedPermissions"]) {
                this.grantedPermissions = {} as any;
                for (let key in _data["grantedPermissions"]) {
                    if (_data["grantedPermissions"].hasOwnProperty(key))
                        this.grantedPermissions![key] = _data["grantedPermissions"][key];
                }
            }
        }
    }

    static fromJS(data: any): AbpUserAuthConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserAuthConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.allPermissions) {
            data["allPermissions"] = {};
            for (let key in this.allPermissions) {
                if (this.allPermissions.hasOwnProperty(key))
                    data["allPermissions"][key] = this.allPermissions[key];
            }
        }
        if (this.grantedPermissions) {
            data["grantedPermissions"] = {};
            for (let key in this.grantedPermissions) {
                if (this.grantedPermissions.hasOwnProperty(key))
                    data["grantedPermissions"][key] = this.grantedPermissions[key];
            }
        }
        return data; 
    }
}

export interface IAbpUserAuthConfigDto {
    allPermissions: { [key: string]: string; } | undefined;
    grantedPermissions: { [key: string]: string; } | undefined;
}

export class UserMenuItem implements IUserMenuItem {
    name!: string | undefined;
    icon!: string | undefined;
    displayName!: string | undefined;
    order!: number;
    url!: string | undefined;
    customData!: any | undefined;
    target!: string | undefined;
    isEnabled!: boolean;
    isVisible!: boolean;
    items!: UserMenuItem[] | undefined;

    constructor(data?: IUserMenuItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.icon = _data["icon"];
            this.displayName = _data["displayName"];
            this.order = _data["order"];
            this.url = _data["url"];
            this.customData = _data["customData"];
            this.target = _data["target"];
            this.isEnabled = _data["isEnabled"];
            this.isVisible = _data["isVisible"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserMenuItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserMenuItem {
        data = typeof data === 'object' ? data : {};
        let result = new UserMenuItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["displayName"] = this.displayName;
        data["order"] = this.order;
        data["url"] = this.url;
        data["customData"] = this.customData;
        data["target"] = this.target;
        data["isEnabled"] = this.isEnabled;
        data["isVisible"] = this.isVisible;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserMenuItem {
    name: string | undefined;
    icon: string | undefined;
    displayName: string | undefined;
    order: number;
    url: string | undefined;
    customData: any | undefined;
    target: string | undefined;
    isEnabled: boolean;
    isVisible: boolean;
    items: UserMenuItem[] | undefined;
}

export class UserMenu implements IUserMenu {
    name!: string | undefined;
    displayName!: string | undefined;
    customData!: any | undefined;
    items!: UserMenuItem[] | undefined;

    constructor(data?: IUserMenu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.customData = _data["customData"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserMenuItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserMenu {
        data = typeof data === 'object' ? data : {};
        let result = new UserMenu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["customData"] = this.customData;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserMenu {
    name: string | undefined;
    displayName: string | undefined;
    customData: any | undefined;
    items: UserMenuItem[] | undefined;
}

export class AbpUserNavConfigDto implements IAbpUserNavConfigDto {
    menus!: { [key: string]: UserMenu; } | undefined;

    constructor(data?: IAbpUserNavConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["menus"]) {
                this.menus = {} as any;
                for (let key in _data["menus"]) {
                    if (_data["menus"].hasOwnProperty(key))
                        this.menus![key] = _data["menus"][key] ? UserMenu.fromJS(_data["menus"][key]) : new UserMenu();
                }
            }
        }
    }

    static fromJS(data: any): AbpUserNavConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserNavConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.menus) {
            data["menus"] = {};
            for (let key in this.menus) {
                if (this.menus.hasOwnProperty(key))
                    data["menus"][key] = this.menus[key] ? this.menus[key].toJSON() : <any>undefined;
            }
        }
        return data; 
    }
}

export interface IAbpUserNavConfigDto {
    menus: { [key: string]: UserMenu; } | undefined;
}

export class AbpUserSettingConfigDto implements IAbpUserSettingConfigDto {
    values!: { [key: string]: string; } | undefined;

    constructor(data?: IAbpUserSettingConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        this.values![key] = _data["values"][key];
                }
            }
        }
    }

    static fromJS(data: any): AbpUserSettingConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserSettingConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    data["values"][key] = this.values[key];
            }
        }
        return data; 
    }
}

export interface IAbpUserSettingConfigDto {
    values: { [key: string]: string; } | undefined;
}

export class AbpUserClockConfigDto implements IAbpUserClockConfigDto {
    provider!: string | undefined;

    constructor(data?: IAbpUserClockConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.provider = _data["provider"];
        }
    }

    static fromJS(data: any): AbpUserClockConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserClockConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provider"] = this.provider;
        return data; 
    }
}

export interface IAbpUserClockConfigDto {
    provider: string | undefined;
}

export class AbpUserWindowsTimeZoneConfigDto implements IAbpUserWindowsTimeZoneConfigDto {
    timeZoneId!: string | undefined;
    baseUtcOffsetInMilliseconds!: number;
    currentUtcOffsetInMilliseconds!: number;
    isDaylightSavingTimeNow!: boolean;

    constructor(data?: IAbpUserWindowsTimeZoneConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeZoneId = _data["timeZoneId"];
            this.baseUtcOffsetInMilliseconds = _data["baseUtcOffsetInMilliseconds"];
            this.currentUtcOffsetInMilliseconds = _data["currentUtcOffsetInMilliseconds"];
            this.isDaylightSavingTimeNow = _data["isDaylightSavingTimeNow"];
        }
    }

    static fromJS(data: any): AbpUserWindowsTimeZoneConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserWindowsTimeZoneConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneId"] = this.timeZoneId;
        data["baseUtcOffsetInMilliseconds"] = this.baseUtcOffsetInMilliseconds;
        data["currentUtcOffsetInMilliseconds"] = this.currentUtcOffsetInMilliseconds;
        data["isDaylightSavingTimeNow"] = this.isDaylightSavingTimeNow;
        return data; 
    }
}

export interface IAbpUserWindowsTimeZoneConfigDto {
    timeZoneId: string | undefined;
    baseUtcOffsetInMilliseconds: number;
    currentUtcOffsetInMilliseconds: number;
    isDaylightSavingTimeNow: boolean;
}

export class AbpUserIanaTimeZoneConfigDto implements IAbpUserIanaTimeZoneConfigDto {
    timeZoneId!: string | undefined;

    constructor(data?: IAbpUserIanaTimeZoneConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeZoneId = _data["timeZoneId"];
        }
    }

    static fromJS(data: any): AbpUserIanaTimeZoneConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserIanaTimeZoneConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneId"] = this.timeZoneId;
        return data; 
    }
}

export interface IAbpUserIanaTimeZoneConfigDto {
    timeZoneId: string | undefined;
}

export class AbpUserTimeZoneConfigDto implements IAbpUserTimeZoneConfigDto {
    windows!: AbpUserWindowsTimeZoneConfigDto;
    iana!: AbpUserIanaTimeZoneConfigDto;

    constructor(data?: IAbpUserTimeZoneConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.windows = _data["windows"] ? AbpUserWindowsTimeZoneConfigDto.fromJS(_data["windows"]) : <any>undefined;
            this.iana = _data["iana"] ? AbpUserIanaTimeZoneConfigDto.fromJS(_data["iana"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AbpUserTimeZoneConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserTimeZoneConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["windows"] = this.windows ? this.windows.toJSON() : <any>undefined;
        data["iana"] = this.iana ? this.iana.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAbpUserTimeZoneConfigDto {
    windows: AbpUserWindowsTimeZoneConfigDto;
    iana: AbpUserIanaTimeZoneConfigDto;
}

export class AbpUserTimingConfigDto implements IAbpUserTimingConfigDto {
    timeZoneInfo!: AbpUserTimeZoneConfigDto;

    constructor(data?: IAbpUserTimingConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeZoneInfo = _data["timeZoneInfo"] ? AbpUserTimeZoneConfigDto.fromJS(_data["timeZoneInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AbpUserTimingConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserTimingConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneInfo"] = this.timeZoneInfo ? this.timeZoneInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAbpUserTimingConfigDto {
    timeZoneInfo: AbpUserTimeZoneConfigDto;
}

export class AbpUserAntiForgeryConfigDto implements IAbpUserAntiForgeryConfigDto {
    tokenCookieName!: string | undefined;
    tokenHeaderName!: string | undefined;

    constructor(data?: IAbpUserAntiForgeryConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tokenCookieName = _data["tokenCookieName"];
            this.tokenHeaderName = _data["tokenHeaderName"];
        }
    }

    static fromJS(data: any): AbpUserAntiForgeryConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserAntiForgeryConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tokenCookieName"] = this.tokenCookieName;
        data["tokenHeaderName"] = this.tokenHeaderName;
        return data; 
    }
}

export interface IAbpUserAntiForgeryConfigDto {
    tokenCookieName: string | undefined;
    tokenHeaderName: string | undefined;
}

export class AbpUserSecurityConfigDto implements IAbpUserSecurityConfigDto {
    antiForgery!: AbpUserAntiForgeryConfigDto;

    constructor(data?: IAbpUserSecurityConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.antiForgery = _data["antiForgery"] ? AbpUserAntiForgeryConfigDto.fromJS(_data["antiForgery"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AbpUserSecurityConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserSecurityConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["antiForgery"] = this.antiForgery ? this.antiForgery.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAbpUserSecurityConfigDto {
    antiForgery: AbpUserAntiForgeryConfigDto;
}

export class AbpUserConfigurationDto implements IAbpUserConfigurationDto {
    multiTenancy!: AbpMultiTenancyConfigDto;
    session!: AbpUserSessionConfigDto;
    localization!: AbpUserLocalizationConfigDto;
    features!: AbpUserFeatureConfigDto;
    auth!: AbpUserAuthConfigDto;
    nav!: AbpUserNavConfigDto;
    setting!: AbpUserSettingConfigDto;
    clock!: AbpUserClockConfigDto;
    timing!: AbpUserTimingConfigDto;
    security!: AbpUserSecurityConfigDto;
    custom!: { [key: string]: any; } | undefined;

    constructor(data?: IAbpUserConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.multiTenancy = _data["multiTenancy"] ? AbpMultiTenancyConfigDto.fromJS(_data["multiTenancy"]) : <any>undefined;
            this.session = _data["session"] ? AbpUserSessionConfigDto.fromJS(_data["session"]) : <any>undefined;
            this.localization = _data["localization"] ? AbpUserLocalizationConfigDto.fromJS(_data["localization"]) : <any>undefined;
            this.features = _data["features"] ? AbpUserFeatureConfigDto.fromJS(_data["features"]) : <any>undefined;
            this.auth = _data["auth"] ? AbpUserAuthConfigDto.fromJS(_data["auth"]) : <any>undefined;
            this.nav = _data["nav"] ? AbpUserNavConfigDto.fromJS(_data["nav"]) : <any>undefined;
            this.setting = _data["setting"] ? AbpUserSettingConfigDto.fromJS(_data["setting"]) : <any>undefined;
            this.clock = _data["clock"] ? AbpUserClockConfigDto.fromJS(_data["clock"]) : <any>undefined;
            this.timing = _data["timing"] ? AbpUserTimingConfigDto.fromJS(_data["timing"]) : <any>undefined;
            this.security = _data["security"] ? AbpUserSecurityConfigDto.fromJS(_data["security"]) : <any>undefined;
            if (_data["custom"]) {
                this.custom = {} as any;
                for (let key in _data["custom"]) {
                    if (_data["custom"].hasOwnProperty(key))
                        this.custom![key] = _data["custom"][key];
                }
            }
        }
    }

    static fromJS(data: any): AbpUserConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["multiTenancy"] = this.multiTenancy ? this.multiTenancy.toJSON() : <any>undefined;
        data["session"] = this.session ? this.session.toJSON() : <any>undefined;
        data["localization"] = this.localization ? this.localization.toJSON() : <any>undefined;
        data["features"] = this.features ? this.features.toJSON() : <any>undefined;
        data["auth"] = this.auth ? this.auth.toJSON() : <any>undefined;
        data["nav"] = this.nav ? this.nav.toJSON() : <any>undefined;
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        data["clock"] = this.clock ? this.clock.toJSON() : <any>undefined;
        data["timing"] = this.timing ? this.timing.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        if (this.custom) {
            data["custom"] = {};
            for (let key in this.custom) {
                if (this.custom.hasOwnProperty(key))
                    data["custom"][key] = this.custom[key];
            }
        }
        return data; 
    }
}

export interface IAbpUserConfigurationDto {
    multiTenancy: AbpMultiTenancyConfigDto;
    session: AbpUserSessionConfigDto;
    localization: AbpUserLocalizationConfigDto;
    features: AbpUserFeatureConfigDto;
    auth: AbpUserAuthConfigDto;
    nav: AbpUserNavConfigDto;
    setting: AbpUserSettingConfigDto;
    clock: AbpUserClockConfigDto;
    timing: AbpUserTimingConfigDto;
    security: AbpUserSecurityConfigDto;
    custom: { [key: string]: any; } | undefined;
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken!: string | undefined;
    encodedUserId!: string | undefined;
    encodedTenantId!: string | undefined;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.signInToken = _data["signInToken"];
            this.encodedUserId = _data["encodedUserId"];
            this.encodedTenantId = _data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data; 
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;
}

export class SmtpSettingsDto implements ISmtpSettingsDto {
    /** 默认发件人邮箱地址 */
    defaultFromAddress!: string | undefined;
    /** 邮箱显示名称 */
    defaultFromDisplayName!: string | undefined;
    /** 发件人邮箱SMTP服务器Host */
    smtpHost!: string | undefined;
    /** 发件人邮箱SMTP服务器端口 */
    smtpPort!: number | undefined;
    /** 发件人校验名称
如果SMTP服务器需要进行身份认证，请在此输入该邮箱的用户名 */
    smtpUserName!: string | undefined;
    /** 发件人校验密码
如果SMTP服务器需要进行身份认证，请在此输入该邮箱的密码/授权码
目前QQ邮箱需要使用授权码，不能直接使用密码 */
    smtpPassword!: string | undefined;
    /** 发件人 */
    smtpDomain!: string | undefined;
    /** 是否使用ssl加密模式
设置为true，表示开启ssl加密模式，会对邮件内容进行加密发送，但前提是SMTP服务器端口支持ssl
默认为false */
    smtpEnableSsl!: boolean | undefined;
    /** 是否使用默认网络凭据
默认网络凭据是一个用户身份认证凭据，当前系统未指定，因此默认网络凭据为null
设置为true，表示使用默认网络凭据进行身份认证
设置为false，表示使用SmtpUserName、SmtpPassword进行身份认证
默认为true */
    smtpUseDefaultCredentials!: boolean | undefined;

    constructor(data?: ISmtpSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
            this.smtpHost = _data["smtpHost"];
            this.smtpPort = _data["smtpPort"];
            this.smtpUserName = _data["smtpUserName"];
            this.smtpPassword = _data["smtpPassword"];
            this.smtpDomain = _data["smtpDomain"];
            this.smtpEnableSsl = _data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): SmtpSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SmtpSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }
}

export interface ISmtpSettingsDto {
    /** 默认发件人邮箱地址 */
    defaultFromAddress: string | undefined;
    /** 邮箱显示名称 */
    defaultFromDisplayName: string | undefined;
    /** 发件人邮箱SMTP服务器Host */
    smtpHost: string | undefined;
    /** 发件人邮箱SMTP服务器端口 */
    smtpPort: number | undefined;
    /** 发件人校验名称
如果SMTP服务器需要进行身份认证，请在此输入该邮箱的用户名 */
    smtpUserName: string | undefined;
    /** 发件人校验密码
如果SMTP服务器需要进行身份认证，请在此输入该邮箱的密码/授权码
目前QQ邮箱需要使用授权码，不能直接使用密码 */
    smtpPassword: string | undefined;
    /** 发件人 */
    smtpDomain: string | undefined;
    /** 是否使用ssl加密模式
设置为true，表示开启ssl加密模式，会对邮件内容进行加密发送，但前提是SMTP服务器端口支持ssl
默认为false */
    smtpEnableSsl: boolean | undefined;
    /** 是否使用默认网络凭据
默认网络凭据是一个用户身份认证凭据，当前系统未指定，因此默认网络凭据为null
设置为true，表示使用默认网络凭据进行身份认证
设置为false，表示使用SmtpUserName、SmtpPassword进行身份认证
默认为true */
    smtpUseDefaultCredentials: boolean | undefined;
}

export class SystemAlertSettingsDto implements ISystemAlertSettingsDto {
    /** 启用ES集群磁盘容量告警 */
    enableESClusterDiskAlert!: boolean | undefined;
    /** ES集群磁盘容量告警邮件接收者，以“;”分隔多个电子邮件 */
    esClusterDiskAlertEmailReciever!: string | undefined;
    /** 启用登录失败告警 */
    enableLoginFailureAlert!: boolean | undefined;
    /** 登录失败告警邮件接收者，以“;”分隔多个电子邮件 */
    loginFailureAlertEmailReciever!: string | undefined;

    constructor(data?: ISystemAlertSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enableESClusterDiskAlert = _data["enableESClusterDiskAlert"];
            this.esClusterDiskAlertEmailReciever = _data["esClusterDiskAlertEmailReciever"];
            this.enableLoginFailureAlert = _data["enableLoginFailureAlert"];
            this.loginFailureAlertEmailReciever = _data["loginFailureAlertEmailReciever"];
        }
    }

    static fromJS(data: any): SystemAlertSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SystemAlertSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enableESClusterDiskAlert"] = this.enableESClusterDiskAlert;
        data["esClusterDiskAlertEmailReciever"] = this.esClusterDiskAlertEmailReciever;
        data["enableLoginFailureAlert"] = this.enableLoginFailureAlert;
        data["loginFailureAlertEmailReciever"] = this.loginFailureAlertEmailReciever;
        return data; 
    }
}

export interface ISystemAlertSettingsDto {
    /** 启用ES集群磁盘容量告警 */
    enableESClusterDiskAlert: boolean | undefined;
    /** ES集群磁盘容量告警邮件接收者，以“;”分隔多个电子邮件 */
    esClusterDiskAlertEmailReciever: string | undefined;
    /** 启用登录失败告警 */
    enableLoginFailureAlert: boolean | undefined;
    /** 登录失败告警邮件接收者，以“;”分隔多个电子邮件 */
    loginFailureAlertEmailReciever: string | undefined;
}

export enum MemberTypes {
    Constructor = "Constructor",
    Event = "Event",
    Field = "Field",
    Method = "Method",
    Property = "Property",
    TypeInfo = "TypeInfo",
    Custom = "Custom",
    NestedType = "NestedType",
    All = "All",
}

export enum ParameterAttributes {
    None = "None",
    In = "In",
    Out = "Out",
    Lcid = "Lcid",
    Retval = "Retval",
    Optional = "Optional",
    HasDefault = "HasDefault",
    HasFieldMarshal = "HasFieldMarshal",
    Reserved3 = "Reserved3",
    Reserved4 = "Reserved4",
    ReservedMask = "ReservedMask",
}

export enum MethodAttributes {
    ReuseSlot = "MemberAccessMask",
    PrivateScope = "PrivateScope",
    Private = "Private",
    FamANDAssem = "FamANDAssem",
    Assembly = "Assembly",
    Family = "Family",
    FamORAssem = "FamORAssem",
    Public = "Public",
    MemberAccessMask = "Static",
    UnmanagedExport = "Final",
    Static = "Virtual",
    Final = "HideBySig",
    Virtual = "CheckAccessOnOverride",
    HideBySig = "VtableLayoutMask",
    NewSlot = "ReuseSlot",
    VtableLayoutMask = "NewSlot",
    CheckAccessOnOverride = "Abstract",
    Abstract = "SpecialName",
    SpecialName = "PinvokeImpl",
    RTSpecialName = "UnmanagedExport",
    PinvokeImpl = "RTSpecialName",
    HasSecurity = "HasSecurity",
    RequireSecObject = "RequireSecObject",
    ReservedMask = "ReservedMask",
}

export enum MethodImplAttributes {
    IL = "CodeTypeMask",
    Managed = "IL",
    Native = "Native",
    OPTIL = "OPTIL",
    Runtime = "Runtime",
    CodeTypeMask = "ManagedMask",
    Unmanaged = "Unmanaged",
    ManagedMask = "Managed",
    NoInlining = "ForwardRef",
    ForwardRef = "PreserveSig",
    Synchronized = "InternalCall",
    NoOptimization = "Synchronized",
    PreserveSig = "NoInlining",
    AggressiveInlining = "AggressiveInlining",
    AggressiveOptimization = "NoOptimization",
    InternalCall = "AggressiveOptimization",
    MaxMethodImplVal = "MaxMethodImplVal",
}

export enum CallingConventions {
    Standard = "Standard",
    VarArgs = "VarArgs",
    Any = "Any",
    HasThis = "HasThis",
    ExplicitThis = "ExplicitThis",
}

export class RuntimeMethodHandle implements IRuntimeMethodHandle {
    readonly value!: any;

    constructor(data?: IRuntimeMethodHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).value = _data["value"];
        }
    }

    static fromJS(data: any): RuntimeMethodHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeMethodHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data; 
    }
}

export interface IRuntimeMethodHandle {
    value: any;
}

export class ConstructorInfo implements IConstructorInfo {
    memberType!: MemberTypes;
    attributes!: MethodAttributes;
    methodImplementationFlags!: MethodImplAttributes;
    callingConvention!: CallingConventions;
    readonly isAbstract!: boolean;
    readonly isConstructor!: boolean;
    readonly isFinal!: boolean;
    readonly isHideBySig!: boolean;
    readonly isSpecialName!: boolean;
    readonly isStatic!: boolean;
    readonly isVirtual!: boolean;
    readonly isAssembly!: boolean;
    readonly isFamily!: boolean;
    readonly isFamilyAndAssembly!: boolean;
    readonly isFamilyOrAssembly!: boolean;
    readonly isPrivate!: boolean;
    readonly isPublic!: boolean;
    readonly isConstructedGenericMethod!: boolean;
    readonly isGenericMethod!: boolean;
    readonly isGenericMethodDefinition!: boolean;
    readonly containsGenericParameters!: boolean;
    methodHandle!: RuntimeMethodHandle;
    readonly isSecurityCritical!: boolean;
    readonly isSecuritySafeCritical!: boolean;
    readonly isSecurityTransparent!: boolean;
    readonly name!: string | undefined;
    readonly declaringType!: string | undefined;
    readonly reflectedType!: string | undefined;
    module!: Module;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly isCollectible!: boolean;
    readonly metadataToken!: number;

    constructor(data?: IConstructorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            this.attributes = _data["attributes"];
            this.methodImplementationFlags = _data["methodImplementationFlags"];
            this.callingConvention = _data["callingConvention"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isConstructor = _data["isConstructor"];
            (<any>this).isFinal = _data["isFinal"];
            (<any>this).isHideBySig = _data["isHideBySig"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isVirtual = _data["isVirtual"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isConstructedGenericMethod = _data["isConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["isGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["isGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            this.methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            (<any>this).name = _data["name"];
            (<any>this).declaringType = _data["declaringType"];
            (<any>this).reflectedType = _data["reflectedType"];
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): ConstructorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ConstructorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["attributes"] = this.attributes;
        data["methodImplementationFlags"] = this.methodImplementationFlags;
        data["callingConvention"] = this.callingConvention;
        data["isAbstract"] = this.isAbstract;
        data["isConstructor"] = this.isConstructor;
        data["isFinal"] = this.isFinal;
        data["isHideBySig"] = this.isHideBySig;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isVirtual"] = this.isVirtual;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["isGenericMethod"] = this.isGenericMethod;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType;
        data["reflectedType"] = this.reflectedType;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data; 
    }
}

export interface IConstructorInfo {
    memberType: MemberTypes;
    attributes: MethodAttributes;
    methodImplementationFlags: MethodImplAttributes;
    callingConvention: CallingConventions;
    isAbstract: boolean;
    isConstructor: boolean;
    isFinal: boolean;
    isHideBySig: boolean;
    isSpecialName: boolean;
    isStatic: boolean;
    isVirtual: boolean;
    isAssembly: boolean;
    isFamily: boolean;
    isFamilyAndAssembly: boolean;
    isFamilyOrAssembly: boolean;
    isPrivate: boolean;
    isPublic: boolean;
    isConstructedGenericMethod: boolean;
    isGenericMethod: boolean;
    isGenericMethodDefinition: boolean;
    containsGenericParameters: boolean;
    methodHandle: RuntimeMethodHandle;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
    name: string | undefined;
    declaringType: string | undefined;
    reflectedType: string | undefined;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export class CustomAttributeTypedArgument implements ICustomAttributeTypedArgument {
    argumentType!: string | undefined;
    value!: any | undefined;

    constructor(data?: ICustomAttributeTypedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.argumentType = _data["argumentType"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CustomAttributeTypedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeTypedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["argumentType"] = this.argumentType;
        data["value"] = this.value;
        return data; 
    }
}

export interface ICustomAttributeTypedArgument {
    argumentType: string | undefined;
    value: any | undefined;
}

export class CustomAttributeNamedArgument implements ICustomAttributeNamedArgument {
    memberInfo!: MemberInfo;
    typedValue!: CustomAttributeTypedArgument;
    readonly memberName!: string | undefined;
    readonly isField!: boolean;

    constructor(data?: ICustomAttributeNamedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberInfo = _data["memberInfo"] ? MemberInfo.fromJS(_data["memberInfo"]) : <any>undefined;
            this.typedValue = _data["typedValue"] ? CustomAttributeTypedArgument.fromJS(_data["typedValue"]) : <any>undefined;
            (<any>this).memberName = _data["memberName"];
            (<any>this).isField = _data["isField"];
        }
    }

    static fromJS(data: any): CustomAttributeNamedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeNamedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberInfo"] = this.memberInfo ? this.memberInfo.toJSON() : <any>undefined;
        data["typedValue"] = this.typedValue ? this.typedValue.toJSON() : <any>undefined;
        data["memberName"] = this.memberName;
        data["isField"] = this.isField;
        return data; 
    }
}

export interface ICustomAttributeNamedArgument {
    memberInfo: MemberInfo;
    typedValue: CustomAttributeTypedArgument;
    memberName: string | undefined;
    isField: boolean;
}

export class CustomAttributeData implements ICustomAttributeData {
    readonly attributeType!: string | undefined;
    constructor_!: ConstructorInfo;
    readonly constructorArguments!: CustomAttributeTypedArgument[] | undefined;
    readonly namedArguments!: CustomAttributeNamedArgument[] | undefined;

    constructor(data?: ICustomAttributeData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).attributeType = _data["attributeType"];
            this.constructor_ = _data["constructor"] ? ConstructorInfo.fromJS(_data["constructor"]) : <any>undefined;
            if (Array.isArray(_data["constructorArguments"])) {
                (<any>this).constructorArguments = [] as any;
                for (let item of _data["constructorArguments"])
                    (<any>this).constructorArguments!.push(CustomAttributeTypedArgument.fromJS(item));
            }
            if (Array.isArray(_data["namedArguments"])) {
                (<any>this).namedArguments = [] as any;
                for (let item of _data["namedArguments"])
                    (<any>this).namedArguments!.push(CustomAttributeNamedArgument.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomAttributeData {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeType"] = this.attributeType;
        data["constructor"] = this.constructor_ ? this.constructor_.toJSON() : <any>undefined;
        if (Array.isArray(this.constructorArguments)) {
            data["constructorArguments"] = [];
            for (let item of this.constructorArguments)
                data["constructorArguments"].push(item.toJSON());
        }
        if (Array.isArray(this.namedArguments)) {
            data["namedArguments"] = [];
            for (let item of this.namedArguments)
                data["namedArguments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICustomAttributeData {
    attributeType: string | undefined;
    constructor_: ConstructorInfo;
    constructorArguments: CustomAttributeTypedArgument[] | undefined;
    namedArguments: CustomAttributeNamedArgument[] | undefined;
}

export enum SecurityRuleSet {
    None = "None",
    Level1 = "Level1",
    Level2 = "Level2",
}

export class Assembly implements IAssembly {
    readonly definedTypes!: string[] | undefined;
    readonly exportedTypes!: string[] | undefined;
    readonly codeBase!: string | undefined;
    entryPoint!: MethodInfo;
    readonly fullName!: string | undefined;
    readonly imageRuntimeVersion!: string | undefined;
    readonly isDynamic!: boolean;
    readonly location!: string | undefined;
    readonly reflectionOnly!: boolean;
    readonly isCollectible!: boolean;
    readonly isFullyTrusted!: boolean;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly escapedCodeBase!: string | undefined;
    manifestModule!: Module;
    readonly modules!: Module[] | undefined;
    readonly globalAssemblyCache!: boolean;
    readonly hostContext!: number;
    securityRuleSet!: SecurityRuleSet;

    constructor(data?: IAssembly) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["definedTypes"])) {
                (<any>this).definedTypes = [] as any;
                for (let item of _data["definedTypes"])
                    (<any>this).definedTypes!.push(item);
            }
            if (Array.isArray(_data["exportedTypes"])) {
                (<any>this).exportedTypes = [] as any;
                for (let item of _data["exportedTypes"])
                    (<any>this).exportedTypes!.push(item);
            }
            (<any>this).codeBase = _data["codeBase"];
            this.entryPoint = _data["entryPoint"] ? MethodInfo.fromJS(_data["entryPoint"]) : <any>undefined;
            (<any>this).fullName = _data["fullName"];
            (<any>this).imageRuntimeVersion = _data["imageRuntimeVersion"];
            (<any>this).isDynamic = _data["isDynamic"];
            (<any>this).location = _data["location"];
            (<any>this).reflectionOnly = _data["reflectionOnly"];
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).isFullyTrusted = _data["isFullyTrusted"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).escapedCodeBase = _data["escapedCodeBase"];
            this.manifestModule = _data["manifestModule"] ? Module.fromJS(_data["manifestModule"]) : <any>undefined;
            if (Array.isArray(_data["modules"])) {
                (<any>this).modules = [] as any;
                for (let item of _data["modules"])
                    (<any>this).modules!.push(Module.fromJS(item));
            }
            (<any>this).globalAssemblyCache = _data["globalAssemblyCache"];
            (<any>this).hostContext = _data["hostContext"];
            this.securityRuleSet = _data["securityRuleSet"];
        }
    }

    static fromJS(data: any): Assembly {
        data = typeof data === 'object' ? data : {};
        let result = new Assembly();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.definedTypes)) {
            data["definedTypes"] = [];
            for (let item of this.definedTypes)
                data["definedTypes"].push(item);
        }
        if (Array.isArray(this.exportedTypes)) {
            data["exportedTypes"] = [];
            for (let item of this.exportedTypes)
                data["exportedTypes"].push(item);
        }
        data["codeBase"] = this.codeBase;
        data["entryPoint"] = this.entryPoint ? this.entryPoint.toJSON() : <any>undefined;
        data["fullName"] = this.fullName;
        data["imageRuntimeVersion"] = this.imageRuntimeVersion;
        data["isDynamic"] = this.isDynamic;
        data["location"] = this.location;
        data["reflectionOnly"] = this.reflectionOnly;
        data["isCollectible"] = this.isCollectible;
        data["isFullyTrusted"] = this.isFullyTrusted;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["escapedCodeBase"] = this.escapedCodeBase;
        data["manifestModule"] = this.manifestModule ? this.manifestModule.toJSON() : <any>undefined;
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        data["globalAssemblyCache"] = this.globalAssemblyCache;
        data["hostContext"] = this.hostContext;
        data["securityRuleSet"] = this.securityRuleSet;
        return data; 
    }
}

export interface IAssembly {
    definedTypes: string[] | undefined;
    exportedTypes: string[] | undefined;
    codeBase: string | undefined;
    entryPoint: MethodInfo;
    fullName: string | undefined;
    imageRuntimeVersion: string | undefined;
    isDynamic: boolean;
    location: string | undefined;
    reflectionOnly: boolean;
    isCollectible: boolean;
    isFullyTrusted: boolean;
    customAttributes: CustomAttributeData[] | undefined;
    escapedCodeBase: string | undefined;
    manifestModule: Module;
    modules: Module[] | undefined;
    globalAssemblyCache: boolean;
    hostContext: number;
    securityRuleSet: SecurityRuleSet;
}

export class ModuleHandle implements IModuleHandle {
    readonly mdStreamVersion!: number;

    constructor(data?: IModuleHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).mdStreamVersion = _data["mdStreamVersion"];
        }
    }

    static fromJS(data: any): ModuleHandle {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mdStreamVersion"] = this.mdStreamVersion;
        return data; 
    }
}

export interface IModuleHandle {
    mdStreamVersion: number;
}

export class Module implements IModule {
    assembly!: Assembly;
    readonly fullyQualifiedName!: string | undefined;
    readonly name!: string | undefined;
    readonly mdStreamVersion!: number;
    readonly moduleVersionId!: string;
    readonly scopeName!: string | undefined;
    moduleHandle!: ModuleHandle;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly metadataToken!: number;

    constructor(data?: IModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assembly = _data["assembly"] ? Assembly.fromJS(_data["assembly"]) : <any>undefined;
            (<any>this).fullyQualifiedName = _data["fullyQualifiedName"];
            (<any>this).name = _data["name"];
            (<any>this).mdStreamVersion = _data["mdStreamVersion"];
            (<any>this).moduleVersionId = _data["moduleVersionId"];
            (<any>this).scopeName = _data["scopeName"];
            this.moduleHandle = _data["moduleHandle"] ? ModuleHandle.fromJS(_data["moduleHandle"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): Module {
        data = typeof data === 'object' ? data : {};
        let result = new Module();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["fullyQualifiedName"] = this.fullyQualifiedName;
        data["name"] = this.name;
        data["mdStreamVersion"] = this.mdStreamVersion;
        data["moduleVersionId"] = this.moduleVersionId;
        data["scopeName"] = this.scopeName;
        data["moduleHandle"] = this.moduleHandle ? this.moduleHandle.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["metadataToken"] = this.metadataToken;
        return data; 
    }
}

export interface IModule {
    assembly: Assembly;
    fullyQualifiedName: string | undefined;
    name: string | undefined;
    mdStreamVersion: number;
    moduleVersionId: string;
    scopeName: string | undefined;
    moduleHandle: ModuleHandle;
    customAttributes: CustomAttributeData[] | undefined;
    metadataToken: number;
}

export class MemberInfo implements IMemberInfo {
    memberType!: MemberTypes;
    readonly name!: string | undefined;
    readonly declaringType!: string | undefined;
    readonly reflectedType!: string | undefined;
    module!: Module;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly isCollectible!: boolean;
    readonly metadataToken!: number;

    constructor(data?: IMemberInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            (<any>this).name = _data["name"];
            (<any>this).declaringType = _data["declaringType"];
            (<any>this).reflectedType = _data["reflectedType"];
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): MemberInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MemberInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType;
        data["reflectedType"] = this.reflectedType;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data; 
    }
}

export interface IMemberInfo {
    memberType: MemberTypes;
    name: string | undefined;
    declaringType: string | undefined;
    reflectedType: string | undefined;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export class ParameterInfo implements IParameterInfo {
    attributes!: ParameterAttributes;
    member!: MemberInfo;
    readonly name!: string | undefined;
    readonly parameterType!: string | undefined;
    readonly position!: number;
    readonly isIn!: boolean;
    readonly isLcid!: boolean;
    readonly isOptional!: boolean;
    readonly isOut!: boolean;
    readonly isRetval!: boolean;
    readonly defaultValue!: any | undefined;
    readonly rawDefaultValue!: any | undefined;
    readonly hasDefaultValue!: boolean;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly metadataToken!: number;

    constructor(data?: IParameterInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributes = _data["attributes"];
            this.member = _data["member"] ? MemberInfo.fromJS(_data["member"]) : <any>undefined;
            (<any>this).name = _data["name"];
            (<any>this).parameterType = _data["parameterType"];
            (<any>this).position = _data["position"];
            (<any>this).isIn = _data["isIn"];
            (<any>this).isLcid = _data["isLcid"];
            (<any>this).isOptional = _data["isOptional"];
            (<any>this).isOut = _data["isOut"];
            (<any>this).isRetval = _data["isRetval"];
            (<any>this).defaultValue = _data["defaultValue"];
            (<any>this).rawDefaultValue = _data["rawDefaultValue"];
            (<any>this).hasDefaultValue = _data["hasDefaultValue"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): ParameterInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributes"] = this.attributes;
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["parameterType"] = this.parameterType;
        data["position"] = this.position;
        data["isIn"] = this.isIn;
        data["isLcid"] = this.isLcid;
        data["isOptional"] = this.isOptional;
        data["isOut"] = this.isOut;
        data["isRetval"] = this.isRetval;
        data["defaultValue"] = this.defaultValue;
        data["rawDefaultValue"] = this.rawDefaultValue;
        data["hasDefaultValue"] = this.hasDefaultValue;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["metadataToken"] = this.metadataToken;
        return data; 
    }
}

export interface IParameterInfo {
    attributes: ParameterAttributes;
    member: MemberInfo;
    name: string | undefined;
    parameterType: string | undefined;
    position: number;
    isIn: boolean;
    isLcid: boolean;
    isOptional: boolean;
    isOut: boolean;
    isRetval: boolean;
    defaultValue: any | undefined;
    rawDefaultValue: any | undefined;
    hasDefaultValue: boolean;
    customAttributes: CustomAttributeData[] | undefined;
    metadataToken: number;
}

export class ICustomAttributeProvider implements IICustomAttributeProvider {

    constructor(data?: IICustomAttributeProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ICustomAttributeProvider {
        data = typeof data === 'object' ? data : {};
        let result = new ICustomAttributeProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IICustomAttributeProvider {
}

export class MethodInfo implements IMethodInfo {
    memberType!: MemberTypes;
    returnParameter!: ParameterInfo;
    readonly returnType!: string | undefined;
    returnTypeCustomAttributes!: ICustomAttributeProvider;
    attributes!: MethodAttributes;
    methodImplementationFlags!: MethodImplAttributes;
    callingConvention!: CallingConventions;
    readonly isAbstract!: boolean;
    readonly isConstructor!: boolean;
    readonly isFinal!: boolean;
    readonly isHideBySig!: boolean;
    readonly isSpecialName!: boolean;
    readonly isStatic!: boolean;
    readonly isVirtual!: boolean;
    readonly isAssembly!: boolean;
    readonly isFamily!: boolean;
    readonly isFamilyAndAssembly!: boolean;
    readonly isFamilyOrAssembly!: boolean;
    readonly isPrivate!: boolean;
    readonly isPublic!: boolean;
    readonly isConstructedGenericMethod!: boolean;
    readonly isGenericMethod!: boolean;
    readonly isGenericMethodDefinition!: boolean;
    readonly containsGenericParameters!: boolean;
    methodHandle!: RuntimeMethodHandle;
    readonly isSecurityCritical!: boolean;
    readonly isSecuritySafeCritical!: boolean;
    readonly isSecurityTransparent!: boolean;
    readonly name!: string | undefined;
    readonly declaringType!: string | undefined;
    readonly reflectedType!: string | undefined;
    module!: Module;
    readonly customAttributes!: CustomAttributeData[] | undefined;
    readonly isCollectible!: boolean;
    readonly metadataToken!: number;

    constructor(data?: IMethodInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            this.returnParameter = _data["returnParameter"] ? ParameterInfo.fromJS(_data["returnParameter"]) : <any>undefined;
            (<any>this).returnType = _data["returnType"];
            this.returnTypeCustomAttributes = _data["returnTypeCustomAttributes"] ? ICustomAttributeProvider.fromJS(_data["returnTypeCustomAttributes"]) : <any>undefined;
            this.attributes = _data["attributes"];
            this.methodImplementationFlags = _data["methodImplementationFlags"];
            this.callingConvention = _data["callingConvention"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isConstructor = _data["isConstructor"];
            (<any>this).isFinal = _data["isFinal"];
            (<any>this).isHideBySig = _data["isHideBySig"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isVirtual = _data["isVirtual"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isConstructedGenericMethod = _data["isConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["isGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["isGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            this.methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            (<any>this).name = _data["name"];
            (<any>this).declaringType = _data["declaringType"];
            (<any>this).reflectedType = _data["reflectedType"];
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): MethodInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MethodInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["returnParameter"] = this.returnParameter ? this.returnParameter.toJSON() : <any>undefined;
        data["returnType"] = this.returnType;
        data["returnTypeCustomAttributes"] = this.returnTypeCustomAttributes ? this.returnTypeCustomAttributes.toJSON() : <any>undefined;
        data["attributes"] = this.attributes;
        data["methodImplementationFlags"] = this.methodImplementationFlags;
        data["callingConvention"] = this.callingConvention;
        data["isAbstract"] = this.isAbstract;
        data["isConstructor"] = this.isConstructor;
        data["isFinal"] = this.isFinal;
        data["isHideBySig"] = this.isHideBySig;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isVirtual"] = this.isVirtual;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["isGenericMethod"] = this.isGenericMethod;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType;
        data["reflectedType"] = this.reflectedType;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data; 
    }
}

export interface IMethodInfo {
    memberType: MemberTypes;
    returnParameter: ParameterInfo;
    returnType: string | undefined;
    returnTypeCustomAttributes: ICustomAttributeProvider;
    attributes: MethodAttributes;
    methodImplementationFlags: MethodImplAttributes;
    callingConvention: CallingConventions;
    isAbstract: boolean;
    isConstructor: boolean;
    isFinal: boolean;
    isHideBySig: boolean;
    isSpecialName: boolean;
    isStatic: boolean;
    isVirtual: boolean;
    isAssembly: boolean;
    isFamily: boolean;
    isFamilyAndAssembly: boolean;
    isFamilyOrAssembly: boolean;
    isPrivate: boolean;
    isPublic: boolean;
    isConstructedGenericMethod: boolean;
    isGenericMethod: boolean;
    isGenericMethodDefinition: boolean;
    containsGenericParameters: boolean;
    methodHandle: RuntimeMethodHandle;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
    name: string | undefined;
    declaringType: string | undefined;
    reflectedType: string | undefined;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export class Job implements IJob {
    type!: string | undefined;
    method!: MethodInfo;
    args!: any[] | undefined;
    arguments!: string[] | undefined;

    constructor(data?: IJob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.method = _data["method"] ? MethodInfo.fromJS(_data["method"]) : <any>undefined;
            if (Array.isArray(_data["args"])) {
                this.args = [] as any;
                for (let item of _data["args"])
                    this.args!.push(item);
            }
            if (Array.isArray(_data["arguments"])) {
                this.arguments = [] as any;
                for (let item of _data["arguments"])
                    this.arguments!.push(item);
            }
        }
    }

    static fromJS(data: any): Job {
        data = typeof data === 'object' ? data : {};
        let result = new Job();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["method"] = this.method ? this.method.toJSON() : <any>undefined;
        if (Array.isArray(this.args)) {
            data["args"] = [];
            for (let item of this.args)
                data["args"].push(item);
        }
        if (Array.isArray(this.arguments)) {
            data["arguments"] = [];
            for (let item of this.arguments)
                data["arguments"].push(item);
        }
        return data; 
    }
}

export interface IJob {
    type: string | undefined;
    method: MethodInfo;
    args: any[] | undefined;
    arguments: string[] | undefined;
}

export class JobData implements IJobData {
    state!: string | undefined;
    job!: Job;
    createdAt!: moment.Moment;
    loadException!: any | undefined;

    constructor(data?: IJobData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.job = _data["job"] ? Job.fromJS(_data["job"]) : <any>undefined;
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.loadException = _data["loadException"];
        }
    }

    static fromJS(data: any): JobData {
        data = typeof data === 'object' ? data : {};
        let result = new JobData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["job"] = this.job ? this.job.toJSON() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["loadException"] = this.loadException;
        return data; 
    }
}

export interface IJobData {
    state: string | undefined;
    job: Job;
    createdAt: moment.Moment;
    loadException: any | undefined;
}

export class NullableIdDtoOfInt64 implements INullableIdDtoOfInt64 {
    id!: number | undefined;

    constructor(data?: INullableIdDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NullableIdDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new NullableIdDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface INullableIdDtoOfInt64 {
    id: number | undefined;
}

export enum SettingScopes {
    Application = "Application",
    Tenant = "Tenant",
    User = "User",
    All = "All",
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
    items!: NameValueDto[] | undefined;

    constructor(data?: IListResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;
}

/** 网站日志Dto */
export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines!: string[] | undefined;

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["latestWebLogLines"])) {
                this.latestWebLogLines = [] as any;
                for (let item of _data["latestWebLogLines"])
                    this.latestWebLogLines!.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.latestWebLogLines)) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data; 
    }
}

/** 网站日志Dto */
export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;
}

export enum AlertEventType {
    VPNUserLoginFailureCount = "VPNUserLoginFailureCount",
    VPNSrcIPLoginFailureCount = "VPNSrcIPLoginFailureCount",
    VPNUserAccessIntranetHostCount = "VPNUserAccessIntranetHostCount",
}

/** 告警任务的列表DTO YSLog.WebManagement.DataAlert.YSLogDataAlertObject */
export class YSLogDataAlertObjectEditDto implements IYSLogDataAlertObjectEditDto {
    /** Id */
    id!: number | undefined;
    /** 名称 */
    name!: string;
    /** 描述 */
    description!: string | undefined;
    alert_event_type!: AlertEventType;
    /** 阈值 */
    threshold!: number;
    /** 数据类型 */
    schema_name!: string | undefined;
    /** 关联数据集 */
    related_dataset_id!: number;
    /** 执行频率 */
    detection_frequency!: number;
    /** 告警邮件接收者 */
    alert_reciever_email!: string;

    constructor(data?: IYSLogDataAlertObjectEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.alert_event_type = _data["alert_event_type"];
            this.threshold = _data["threshold"];
            this.schema_name = _data["schema_name"];
            this.related_dataset_id = _data["related_dataset_id"];
            this.detection_frequency = _data["detection_frequency"];
            this.alert_reciever_email = _data["alert_reciever_email"];
        }
    }

    static fromJS(data: any): YSLogDataAlertObjectEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogDataAlertObjectEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["alert_event_type"] = this.alert_event_type;
        data["threshold"] = this.threshold;
        data["schema_name"] = this.schema_name;
        data["related_dataset_id"] = this.related_dataset_id;
        data["detection_frequency"] = this.detection_frequency;
        data["alert_reciever_email"] = this.alert_reciever_email;
        return data; 
    }
}

/** 告警任务的列表DTO YSLog.WebManagement.DataAlert.YSLogDataAlertObject */
export interface IYSLogDataAlertObjectEditDto {
    /** Id */
    id: number | undefined;
    /** 名称 */
    name: string;
    /** 描述 */
    description: string | undefined;
    alert_event_type: AlertEventType;
    /** 阈值 */
    threshold: number;
    /** 数据类型 */
    schema_name: string | undefined;
    /** 关联数据集 */
    related_dataset_id: number;
    /** 执行频率 */
    detection_frequency: number;
    /** 告警邮件接收者 */
    alert_reciever_email: string;
}

export class CreateOrUpdateYSLogDataAlertObjectInput implements ICreateOrUpdateYSLogDataAlertObjectInput {
    alert!: YSLogDataAlertObjectEditDto;

    constructor(data?: ICreateOrUpdateYSLogDataAlertObjectInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.alert = new YSLogDataAlertObjectEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alert = _data["alert"] ? YSLogDataAlertObjectEditDto.fromJS(_data["alert"]) : new YSLogDataAlertObjectEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateYSLogDataAlertObjectInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateYSLogDataAlertObjectInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alert"] = this.alert ? this.alert.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateOrUpdateYSLogDataAlertObjectInput {
    alert: YSLogDataAlertObjectEditDto;
}

export class YSLogDataEngineObject implements IYSLogDataEngineObject {
    /** 采集引擎名称 */
    name!: string | undefined;
    /** 采集引擎描述信息 */
    description!: string | undefined;
    /** 传输协议：http或者https */
    schema!: string | undefined;
    /** IP地址/主机名称 */
    host!: string | undefined;
    /** 通信端口 */
    port!: number;
    /** apikey */
    apikey!: string | undefined;
    /** 采集引擎唯一标识符Guid */
    guid!: string;
    id!: number;

    constructor(data?: IYSLogDataEngineObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.schema = _data["schema"];
            this.host = _data["host"];
            this.port = _data["port"];
            this.apikey = _data["apikey"];
            this.guid = _data["guid"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): YSLogDataEngineObject {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogDataEngineObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["schema"] = this.schema;
        data["host"] = this.host;
        data["port"] = this.port;
        data["apikey"] = this.apikey;
        data["guid"] = this.guid;
        data["id"] = this.id;
        return data; 
    }
}

export interface IYSLogDataEngineObject {
    /** 采集引擎名称 */
    name: string | undefined;
    /** 采集引擎描述信息 */
    description: string | undefined;
    /** 传输协议：http或者https */
    schema: string | undefined;
    /** IP地址/主机名称 */
    host: string | undefined;
    /** 通信端口 */
    port: number;
    /** apikey */
    apikey: string | undefined;
    /** 采集引擎唯一标识符Guid */
    guid: string;
    id: number;
}

/** 管理平台记录用户配置/注册的数据集的信息 注意这个同时适用于内部数据集和外部数据集 实际上两者并没有本质上的区别，因此目前未设置字段表示内外类型 */
export class YSLogDataSetObject implements IYSLogDataSetObject {
    cluster!: YSLogESClusterObject;
    engine!: YSLogDataEngineObject;
    /** 数据集的可识别名字，短 */
    name!: string | undefined;
    /** 数据集的描述内容，长 */
    description!: string | undefined;
    /** 该数据集中所包含的数据类型的SchemaName */
    schema_name!: string | undefined;
    match_mode!: IndexMatchMode;
    /** 对应“ByPattern”模式的索引名称表达式
也可以是包含通配符的（类似 logstash-*） */
    pattern!: string | undefined;
    /** 对应“ByAlias”模式的读索引别名 */
    read_alias!: string | undefined;
    /** 写索引别名 */
    write_alias!: string | undefined;
    /** 由管理平台创建的索引  的分片数
目前不允许修改分片数，只能使用系统规定的默认值 */
    shard_count!: number;
    /** 由管理平台创建的索引  的分片数
目前不允许修改分片数，只能使用系统规定的默认值 */
    duplicate_count!: number;
    /** 新索引刷新间隔（秒） */
    hot_index_refresh_interval!: number;
    /** 旧索引刷新间隔（秒） */
    cold_index_refresh_interval!: number;
    rotate_policy!: InternalRotatePolicy;
    /** 索引更替策略中的时间阈值
单位为天 */
    age_threshold!: number;
    /** 索引更替策略中的容量阈值
单位为GB */
    size_threshold!: number;
    /** 表示当前数据集是否可用
由于必须在为数据集创建索引之前先创建数据集实体到数据库中
所以在索引未完成创建时设置未true表示不可用
待索引创建成功后将其修改为true */
    ready!: boolean;
    /** 下一个更替轮次Id
用于记录接下来索引更替时新索引的轮次 */
    next_cycle_id!: number;
    /** 当前索引名称 */
    current_index_name!: string | undefined;
    id!: number;

    constructor(data?: IYSLogDataSetObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cluster = _data["cluster"] ? YSLogESClusterObject.fromJS(_data["cluster"]) : <any>undefined;
            this.engine = _data["engine"] ? YSLogDataEngineObject.fromJS(_data["engine"]) : <any>undefined;
            this.name = _data["name"];
            this.description = _data["description"];
            this.schema_name = _data["schema_name"];
            this.match_mode = _data["match_mode"];
            this.pattern = _data["pattern"];
            this.read_alias = _data["read_alias"];
            this.write_alias = _data["write_alias"];
            this.shard_count = _data["shard_count"];
            this.duplicate_count = _data["duplicate_count"];
            this.hot_index_refresh_interval = _data["hot_index_refresh_interval"];
            this.cold_index_refresh_interval = _data["cold_index_refresh_interval"];
            this.rotate_policy = _data["rotate_policy"];
            this.age_threshold = _data["age_threshold"];
            this.size_threshold = _data["size_threshold"];
            this.ready = _data["ready"];
            this.next_cycle_id = _data["next_cycle_id"];
            this.current_index_name = _data["current_index_name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): YSLogDataSetObject {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogDataSetObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cluster"] = this.cluster ? this.cluster.toJSON() : <any>undefined;
        data["engine"] = this.engine ? this.engine.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        data["schema_name"] = this.schema_name;
        data["match_mode"] = this.match_mode;
        data["pattern"] = this.pattern;
        data["read_alias"] = this.read_alias;
        data["write_alias"] = this.write_alias;
        data["shard_count"] = this.shard_count;
        data["duplicate_count"] = this.duplicate_count;
        data["hot_index_refresh_interval"] = this.hot_index_refresh_interval;
        data["cold_index_refresh_interval"] = this.cold_index_refresh_interval;
        data["rotate_policy"] = this.rotate_policy;
        data["age_threshold"] = this.age_threshold;
        data["size_threshold"] = this.size_threshold;
        data["ready"] = this.ready;
        data["next_cycle_id"] = this.next_cycle_id;
        data["current_index_name"] = this.current_index_name;
        data["id"] = this.id;
        return data; 
    }
}

/** 管理平台记录用户配置/注册的数据集的信息 注意这个同时适用于内部数据集和外部数据集 实际上两者并没有本质上的区别，因此目前未设置字段表示内外类型 */
export interface IYSLogDataSetObject {
    cluster: YSLogESClusterObject;
    engine: YSLogDataEngineObject;
    /** 数据集的可识别名字，短 */
    name: string | undefined;
    /** 数据集的描述内容，长 */
    description: string | undefined;
    /** 该数据集中所包含的数据类型的SchemaName */
    schema_name: string | undefined;
    match_mode: IndexMatchMode;
    /** 对应“ByPattern”模式的索引名称表达式
也可以是包含通配符的（类似 logstash-*） */
    pattern: string | undefined;
    /** 对应“ByAlias”模式的读索引别名 */
    read_alias: string | undefined;
    /** 写索引别名 */
    write_alias: string | undefined;
    /** 由管理平台创建的索引  的分片数
目前不允许修改分片数，只能使用系统规定的默认值 */
    shard_count: number;
    /** 由管理平台创建的索引  的分片数
目前不允许修改分片数，只能使用系统规定的默认值 */
    duplicate_count: number;
    /** 新索引刷新间隔（秒） */
    hot_index_refresh_interval: number;
    /** 旧索引刷新间隔（秒） */
    cold_index_refresh_interval: number;
    rotate_policy: InternalRotatePolicy;
    /** 索引更替策略中的时间阈值
单位为天 */
    age_threshold: number;
    /** 索引更替策略中的容量阈值
单位为GB */
    size_threshold: number;
    /** 表示当前数据集是否可用
由于必须在为数据集创建索引之前先创建数据集实体到数据库中
所以在索引未完成创建时设置未true表示不可用
待索引创建成功后将其修改为true */
    ready: boolean;
    /** 下一个更替轮次Id
用于记录接下来索引更替时新索引的轮次 */
    next_cycle_id: number;
    /** 当前索引名称 */
    current_index_name: string | undefined;
    id: number;
}

/** 告警任务的列表DTO YSLog.WebManagement.DataAlert.YSLogDataAlertObject */
export class YSLogDataAlertObjectListDto implements IYSLogDataAlertObjectListDto {
    /** 名称 */
    name!: string;
    /** 描述 */
    description!: string | undefined;
    alert_event_type!: AlertEventType;
    alert_event_type_pair!: KeyValuePairOfStringString;
    /** 阈值 */
    threshold!: number;
    /** 数据类型 */
    schema_name!: string;
    schema_name_pair!: KeyValuePairOfStringString;
    related_dataset!: YSLogDataSetObject;
    /** 执行频率 */
    detection_frequency!: number;
    /** 告警邮件接收者 */
    alert_reciever_email!: string;
    id!: number;

    constructor(data?: IYSLogDataAlertObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.related_dataset = new YSLogDataSetObject();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.alert_event_type = _data["alert_event_type"];
            this.alert_event_type_pair = _data["alert_event_type_pair"] ? KeyValuePairOfStringString.fromJS(_data["alert_event_type_pair"]) : <any>undefined;
            this.threshold = _data["threshold"];
            this.schema_name = _data["schema_name"];
            this.schema_name_pair = _data["schema_name_pair"] ? KeyValuePairOfStringString.fromJS(_data["schema_name_pair"]) : <any>undefined;
            this.related_dataset = _data["related_dataset"] ? YSLogDataSetObject.fromJS(_data["related_dataset"]) : new YSLogDataSetObject();
            this.detection_frequency = _data["detection_frequency"];
            this.alert_reciever_email = _data["alert_reciever_email"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): YSLogDataAlertObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogDataAlertObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["alert_event_type"] = this.alert_event_type;
        data["alert_event_type_pair"] = this.alert_event_type_pair ? this.alert_event_type_pair.toJSON() : <any>undefined;
        data["threshold"] = this.threshold;
        data["schema_name"] = this.schema_name;
        data["schema_name_pair"] = this.schema_name_pair ? this.schema_name_pair.toJSON() : <any>undefined;
        data["related_dataset"] = this.related_dataset ? this.related_dataset.toJSON() : <any>undefined;
        data["detection_frequency"] = this.detection_frequency;
        data["alert_reciever_email"] = this.alert_reciever_email;
        data["id"] = this.id;
        return data; 
    }
}

/** 告警任务的列表DTO YSLog.WebManagement.DataAlert.YSLogDataAlertObject */
export interface IYSLogDataAlertObjectListDto {
    /** 名称 */
    name: string;
    /** 描述 */
    description: string | undefined;
    alert_event_type: AlertEventType;
    alert_event_type_pair: KeyValuePairOfStringString;
    /** 阈值 */
    threshold: number;
    /** 数据类型 */
    schema_name: string;
    schema_name_pair: KeyValuePairOfStringString;
    related_dataset: YSLogDataSetObject;
    /** 执行频率 */
    detection_frequency: number;
    /** 告警邮件接收者 */
    alert_reciever_email: string;
    id: number;
}

export class AlertHistoryInstance implements IAlertHistoryInstance {
    log!: string | undefined;
    detectionTime!: moment.Moment;
    id!: number;

    constructor(data?: IAlertHistoryInstance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.log = _data["log"];
            this.detectionTime = _data["detectionTime"] ? moment(_data["detectionTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AlertHistoryInstance {
        data = typeof data === 'object' ? data : {};
        let result = new AlertHistoryInstance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["log"] = this.log;
        data["detectionTime"] = this.detectionTime ? this.detectionTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAlertHistoryInstance {
    log: string | undefined;
    detectionTime: moment.Moment;
    id: number;
}

/** 读取可编辑告警任务的Dto */
export class GetYSLogDataAlertObjectForEditOutput implements IGetYSLogDataAlertObjectForEditOutput {
    alert!: YSLogDataAlertObjectEditDto;
    schema_name_enum!: KeyValuePairOfStringString[] | undefined;
    alert_event_type_enum!: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetYSLogDataAlertObjectForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alert = _data["alert"] ? YSLogDataAlertObjectEditDto.fromJS(_data["alert"]) : <any>undefined;
            if (Array.isArray(_data["schema_name_enum"])) {
                this.schema_name_enum = [] as any;
                for (let item of _data["schema_name_enum"])
                    this.schema_name_enum!.push(KeyValuePairOfStringString.fromJS(item));
            }
            if (Array.isArray(_data["alert_event_type_enum"])) {
                this.alert_event_type_enum = [] as any;
                for (let item of _data["alert_event_type_enum"])
                    this.alert_event_type_enum!.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetYSLogDataAlertObjectForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetYSLogDataAlertObjectForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alert"] = this.alert ? this.alert.toJSON() : <any>undefined;
        if (Array.isArray(this.schema_name_enum)) {
            data["schema_name_enum"] = [];
            for (let item of this.schema_name_enum)
                data["schema_name_enum"].push(item.toJSON());
        }
        if (Array.isArray(this.alert_event_type_enum)) {
            data["alert_event_type_enum"] = [];
            for (let item of this.alert_event_type_enum)
                data["alert_event_type_enum"].push(item.toJSON());
        }
        return data; 
    }
}

/** 读取可编辑告警任务的Dto */
export interface IGetYSLogDataAlertObjectForEditOutput {
    alert: YSLogDataAlertObjectEditDto;
    schema_name_enum: KeyValuePairOfStringString[] | undefined;
    alert_event_type_enum: KeyValuePairOfStringString[] | undefined;
}

export class PagedResultDtoOfYSLogDataAlertObjectListDto implements IPagedResultDtoOfYSLogDataAlertObjectListDto {
    totalCount!: number;
    items!: YSLogDataAlertObjectListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfYSLogDataAlertObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(YSLogDataAlertObjectListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfYSLogDataAlertObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfYSLogDataAlertObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfYSLogDataAlertObjectListDto {
    totalCount: number;
    items: YSLogDataAlertObjectListDto[] | undefined;
}

export enum JobType {
    RecurringJob = "RecurringJob",
    BackgroundJob = "BackgroundJob",
}

/** 的列表DTO YSLog.WebManagement.DataAnalyze.YSLogDataAnalyzeObject */
export class YSLogDataAnalyzeObjectEditDto implements IYSLogDataAnalyzeObjectEditDto {
    /** Id */
    id!: number | undefined;
    /** 名称 */
    name!: string;
    /** 描述 */
    description!: string | undefined;
    /** 月份偏移量 */
    time_offset!: string;
    /** 数据类型 */
    schema_name!: string;
    /** 关联数据集 */
    related_dataset!: number;
    job_type!: JobType;
    /** Corn表达式 */
    corn_expression!: string | undefined;

    constructor(data?: IYSLogDataAnalyzeObjectEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.time_offset = _data["time_offset"];
            this.schema_name = _data["schema_name"];
            this.related_dataset = _data["related_dataset"];
            this.job_type = _data["job_type"];
            this.corn_expression = _data["corn_expression"];
        }
    }

    static fromJS(data: any): YSLogDataAnalyzeObjectEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogDataAnalyzeObjectEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["time_offset"] = this.time_offset;
        data["schema_name"] = this.schema_name;
        data["related_dataset"] = this.related_dataset;
        data["job_type"] = this.job_type;
        data["corn_expression"] = this.corn_expression;
        return data; 
    }
}

/** 的列表DTO YSLog.WebManagement.DataAnalyze.YSLogDataAnalyzeObject */
export interface IYSLogDataAnalyzeObjectEditDto {
    /** Id */
    id: number | undefined;
    /** 名称 */
    name: string;
    /** 描述 */
    description: string | undefined;
    /** 月份偏移量 */
    time_offset: string;
    /** 数据类型 */
    schema_name: string;
    /** 关联数据集 */
    related_dataset: number;
    job_type: JobType;
    /** Corn表达式 */
    corn_expression: string | undefined;
}

export class CreateOrUpdateYSLogDataAnalyzeObjectInput implements ICreateOrUpdateYSLogDataAnalyzeObjectInput {
    ysLogDataAnalyzeObject!: YSLogDataAnalyzeObjectEditDto;

    constructor(data?: ICreateOrUpdateYSLogDataAnalyzeObjectInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ysLogDataAnalyzeObject = new YSLogDataAnalyzeObjectEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ysLogDataAnalyzeObject = _data["ysLogDataAnalyzeObject"] ? YSLogDataAnalyzeObjectEditDto.fromJS(_data["ysLogDataAnalyzeObject"]) : new YSLogDataAnalyzeObjectEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateYSLogDataAnalyzeObjectInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateYSLogDataAnalyzeObjectInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ysLogDataAnalyzeObject"] = this.ysLogDataAnalyzeObject ? this.ysLogDataAnalyzeObject.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateOrUpdateYSLogDataAnalyzeObjectInput {
    ysLogDataAnalyzeObject: YSLogDataAnalyzeObjectEditDto;
}

/** 的列表DTO YSLog.WebManagement.DataAnalyze.YSLogDataAnalyzeObject */
export class YSLogDataAnalyzeObjectListDto implements IYSLogDataAnalyzeObjectListDto {
    /** 名称 */
    name!: string;
    /** 描述 */
    description!: string | undefined;
    /** 月份偏移量 */
    time_offset!: string;
    time_offset_pair!: KeyValuePairOfStringString;
    /** 数据类型 */
    schema_name!: string;
    schema_name_pair!: KeyValuePairOfStringString;
    related_dataset!: YSLogDataSetObject;
    job_type!: JobType;
    /** corn表达式 */
    corn_expression!: string | undefined;
    /** 最近一次报表任务是否生成成功 */
    generated!: boolean;
    /** 报表生成成功的总次数 */
    success_count!: number;
    /** 报表生成的总次数 */
    total_count!: number;
    id!: number;

    constructor(data?: IYSLogDataAnalyzeObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.related_dataset = new YSLogDataSetObject();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.time_offset = _data["time_offset"];
            this.time_offset_pair = _data["time_offset_pair"] ? KeyValuePairOfStringString.fromJS(_data["time_offset_pair"]) : <any>undefined;
            this.schema_name = _data["schema_name"];
            this.schema_name_pair = _data["schema_name_pair"] ? KeyValuePairOfStringString.fromJS(_data["schema_name_pair"]) : <any>undefined;
            this.related_dataset = _data["related_dataset"] ? YSLogDataSetObject.fromJS(_data["related_dataset"]) : new YSLogDataSetObject();
            this.job_type = _data["job_type"];
            this.corn_expression = _data["corn_expression"];
            this.generated = _data["generated"];
            this.success_count = _data["success_count"];
            this.total_count = _data["total_count"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): YSLogDataAnalyzeObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogDataAnalyzeObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["time_offset"] = this.time_offset;
        data["time_offset_pair"] = this.time_offset_pair ? this.time_offset_pair.toJSON() : <any>undefined;
        data["schema_name"] = this.schema_name;
        data["schema_name_pair"] = this.schema_name_pair ? this.schema_name_pair.toJSON() : <any>undefined;
        data["related_dataset"] = this.related_dataset ? this.related_dataset.toJSON() : <any>undefined;
        data["job_type"] = this.job_type;
        data["corn_expression"] = this.corn_expression;
        data["generated"] = this.generated;
        data["success_count"] = this.success_count;
        data["total_count"] = this.total_count;
        data["id"] = this.id;
        return data; 
    }
}

/** 的列表DTO YSLog.WebManagement.DataAnalyze.YSLogDataAnalyzeObject */
export interface IYSLogDataAnalyzeObjectListDto {
    /** 名称 */
    name: string;
    /** 描述 */
    description: string | undefined;
    /** 月份偏移量 */
    time_offset: string;
    time_offset_pair: KeyValuePairOfStringString;
    /** 数据类型 */
    schema_name: string;
    schema_name_pair: KeyValuePairOfStringString;
    related_dataset: YSLogDataSetObject;
    job_type: JobType;
    /** corn表达式 */
    corn_expression: string | undefined;
    /** 最近一次报表任务是否生成成功 */
    generated: boolean;
    /** 报表生成成功的总次数 */
    success_count: number;
    /** 报表生成的总次数 */
    total_count: number;
    id: number;
}

/** 读取可编辑的Dto */
export class GetYSLogDataAnalyzeObjectForEditOutput implements IGetYSLogDataAnalyzeObjectForEditOutput {
    data_analyze!: YSLogDataAnalyzeObjectEditDto;
    time_offset_enum!: KeyValuePairOfStringString[] | undefined;
    schema_name_enum!: KeyValuePairOfStringString[] | undefined;
    job_type_enum!: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetYSLogDataAnalyzeObjectForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data_analyze = _data["data_analyze"] ? YSLogDataAnalyzeObjectEditDto.fromJS(_data["data_analyze"]) : <any>undefined;
            if (Array.isArray(_data["time_offset_enum"])) {
                this.time_offset_enum = [] as any;
                for (let item of _data["time_offset_enum"])
                    this.time_offset_enum!.push(KeyValuePairOfStringString.fromJS(item));
            }
            if (Array.isArray(_data["schema_name_enum"])) {
                this.schema_name_enum = [] as any;
                for (let item of _data["schema_name_enum"])
                    this.schema_name_enum!.push(KeyValuePairOfStringString.fromJS(item));
            }
            if (Array.isArray(_data["job_type_enum"])) {
                this.job_type_enum = [] as any;
                for (let item of _data["job_type_enum"])
                    this.job_type_enum!.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetYSLogDataAnalyzeObjectForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetYSLogDataAnalyzeObjectForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data_analyze"] = this.data_analyze ? this.data_analyze.toJSON() : <any>undefined;
        if (Array.isArray(this.time_offset_enum)) {
            data["time_offset_enum"] = [];
            for (let item of this.time_offset_enum)
                data["time_offset_enum"].push(item.toJSON());
        }
        if (Array.isArray(this.schema_name_enum)) {
            data["schema_name_enum"] = [];
            for (let item of this.schema_name_enum)
                data["schema_name_enum"].push(item.toJSON());
        }
        if (Array.isArray(this.job_type_enum)) {
            data["job_type_enum"] = [];
            for (let item of this.job_type_enum)
                data["job_type_enum"].push(item.toJSON());
        }
        return data; 
    }
}

/** 读取可编辑的Dto */
export interface IGetYSLogDataAnalyzeObjectForEditOutput {
    data_analyze: YSLogDataAnalyzeObjectEditDto;
    time_offset_enum: KeyValuePairOfStringString[] | undefined;
    schema_name_enum: KeyValuePairOfStringString[] | undefined;
    job_type_enum: KeyValuePairOfStringString[] | undefined;
}

export class ReportHistoryInstanceListDto implements IReportHistoryInstanceListDto {
    /** 任务开始执行时间 */
    start_time!: moment.Moment;
    /** 任务结束执行时间 */
    end_time!: moment.Moment;
    /** 执行日志 */
    log!: string | undefined;
    /** 执行结果 */
    success!: boolean;
    id!: number;

    constructor(data?: IReportHistoryInstanceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start_time = _data["start_time"] ? moment(_data["start_time"].toString()) : <any>undefined;
            this.end_time = _data["end_time"] ? moment(_data["end_time"].toString()) : <any>undefined;
            this.log = _data["log"];
            this.success = _data["success"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ReportHistoryInstanceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportHistoryInstanceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start_time"] = this.start_time ? this.start_time.toISOString() : <any>undefined;
        data["end_time"] = this.end_time ? this.end_time.toISOString() : <any>undefined;
        data["log"] = this.log;
        data["success"] = this.success;
        data["id"] = this.id;
        return data; 
    }
}

export interface IReportHistoryInstanceListDto {
    /** 任务开始执行时间 */
    start_time: moment.Moment;
    /** 任务结束执行时间 */
    end_time: moment.Moment;
    /** 执行日志 */
    log: string | undefined;
    /** 执行结果 */
    success: boolean;
    id: number;
}

export class PagedResultDtoOfYSLogDataAnalyzeObjectListDto implements IPagedResultDtoOfYSLogDataAnalyzeObjectListDto {
    totalCount!: number;
    items!: YSLogDataAnalyzeObjectListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfYSLogDataAnalyzeObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(YSLogDataAnalyzeObjectListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfYSLogDataAnalyzeObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfYSLogDataAnalyzeObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfYSLogDataAnalyzeObjectListDto {
    totalCount: number;
    items: YSLogDataAnalyzeObjectListDto[] | undefined;
}

export enum BackupJobType {
    RecurringJob = "RecurringJob",
    BackgroundJob = "BackgroundJob",
}

/** 的列表DTO YSLog.WebManagement.DataBackup.Entities.YSLogDataBackupObject */
export class YSLogDataBackupObjectEditDto implements IYSLogDataBackupObjectEditDto {
    /** Id */
    id!: number | undefined;
    /** Name */
    name!: string;
    /** Description */
    description!: string | undefined;
    /** Indices */
    indices!: string[];
    /** MountPointId */
    mountPointId!: number;
    /** DataSetId */
    dataSetId!: number;
    jobType!: BackupJobType;
    /** Corn表达式 */
    cornExpression!: string | undefined;
    /** 数据类型 SchemaName */
    schemaName!: string;

    constructor(data?: IYSLogDataBackupObjectEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.indices = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["indices"])) {
                this.indices = [] as any;
                for (let item of _data["indices"])
                    this.indices!.push(item);
            }
            this.mountPointId = _data["mountPointId"];
            this.dataSetId = _data["dataSetId"];
            this.jobType = _data["jobType"];
            this.cornExpression = _data["cornExpression"];
            this.schemaName = _data["schemaName"];
        }
    }

    static fromJS(data: any): YSLogDataBackupObjectEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogDataBackupObjectEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.indices)) {
            data["indices"] = [];
            for (let item of this.indices)
                data["indices"].push(item);
        }
        data["mountPointId"] = this.mountPointId;
        data["dataSetId"] = this.dataSetId;
        data["jobType"] = this.jobType;
        data["cornExpression"] = this.cornExpression;
        data["schemaName"] = this.schemaName;
        return data; 
    }
}

/** 的列表DTO YSLog.WebManagement.DataBackup.Entities.YSLogDataBackupObject */
export interface IYSLogDataBackupObjectEditDto {
    /** Id */
    id: number | undefined;
    /** Name */
    name: string;
    /** Description */
    description: string | undefined;
    /** Indices */
    indices: string[];
    /** MountPointId */
    mountPointId: number;
    /** DataSetId */
    dataSetId: number;
    jobType: BackupJobType;
    /** Corn表达式 */
    cornExpression: string | undefined;
    /** 数据类型 SchemaName */
    schemaName: string;
}

export class CreateOrUpdateYSLogDataBackupObjectInput implements ICreateOrUpdateYSLogDataBackupObjectInput {
    ysLogDataBackupObject!: YSLogDataBackupObjectEditDto;

    constructor(data?: ICreateOrUpdateYSLogDataBackupObjectInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ysLogDataBackupObject = new YSLogDataBackupObjectEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ysLogDataBackupObject = _data["ysLogDataBackupObject"] ? YSLogDataBackupObjectEditDto.fromJS(_data["ysLogDataBackupObject"]) : new YSLogDataBackupObjectEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateYSLogDataBackupObjectInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateYSLogDataBackupObjectInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ysLogDataBackupObject"] = this.ysLogDataBackupObject ? this.ysLogDataBackupObject.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateOrUpdateYSLogDataBackupObjectInput {
    ysLogDataBackupObject: YSLogDataBackupObjectEditDto;
}

export enum MountProtocol {
    SMB = "SMB",
    NFS = "NFS",
}

export class YSLogMountPointObject implements IYSLogMountPointObject {
    name!: string | undefined;
    mount_type!: MountProtocol;
    source!: string | undefined;
    mount_point_configuration!: { [key: string]: string; } | undefined;
    id!: number;

    constructor(data?: IYSLogMountPointObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.mount_type = _data["mount_type"];
            this.source = _data["source"];
            if (_data["mount_point_configuration"]) {
                this.mount_point_configuration = {} as any;
                for (let key in _data["mount_point_configuration"]) {
                    if (_data["mount_point_configuration"].hasOwnProperty(key))
                        this.mount_point_configuration![key] = _data["mount_point_configuration"][key];
                }
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): YSLogMountPointObject {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogMountPointObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["mount_type"] = this.mount_type;
        data["source"] = this.source;
        if (this.mount_point_configuration) {
            data["mount_point_configuration"] = {};
            for (let key in this.mount_point_configuration) {
                if (this.mount_point_configuration.hasOwnProperty(key))
                    data["mount_point_configuration"][key] = this.mount_point_configuration[key];
            }
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface IYSLogMountPointObject {
    name: string | undefined;
    mount_type: MountProtocol;
    source: string | undefined;
    mount_point_configuration: { [key: string]: string; } | undefined;
    id: number;
}

/** 的列表DTO YSLog.WebManagement.DataBackup.Entities.YSLogDataBackupObject */
export class YSLogDataBackupObjectListDto implements IYSLogDataBackupObjectListDto {
    /** Name */
    name!: string;
    /** Description */
    description!: string | undefined;
    /** Indices */
    indices!: string[];
    /** MountPointId */
    mountPointId!: number;
    mountPoint!: YSLogMountPointObject;
    /** DataSetId */
    dataSetId!: number;
    jobType!: BackupJobType;
    /** Corn表达式 */
    cornExpression!: string | undefined;
    /** 备份进度 */
    progress!: string | undefined;
    dataSet!: YSLogDataSetObject;
    /** 数据类型 SchemaName */
    schemaName!: string;
    id!: number;

    constructor(data?: IYSLogDataBackupObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.indices = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["indices"])) {
                this.indices = [] as any;
                for (let item of _data["indices"])
                    this.indices!.push(item);
            }
            this.mountPointId = _data["mountPointId"];
            this.mountPoint = _data["mountPoint"] ? YSLogMountPointObject.fromJS(_data["mountPoint"]) : <any>undefined;
            this.dataSetId = _data["dataSetId"];
            this.jobType = _data["jobType"];
            this.cornExpression = _data["cornExpression"];
            this.progress = _data["progress"];
            this.dataSet = _data["dataSet"] ? YSLogDataSetObject.fromJS(_data["dataSet"]) : <any>undefined;
            this.schemaName = _data["schemaName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): YSLogDataBackupObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogDataBackupObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.indices)) {
            data["indices"] = [];
            for (let item of this.indices)
                data["indices"].push(item);
        }
        data["mountPointId"] = this.mountPointId;
        data["mountPoint"] = this.mountPoint ? this.mountPoint.toJSON() : <any>undefined;
        data["dataSetId"] = this.dataSetId;
        data["jobType"] = this.jobType;
        data["cornExpression"] = this.cornExpression;
        data["progress"] = this.progress;
        data["dataSet"] = this.dataSet ? this.dataSet.toJSON() : <any>undefined;
        data["schemaName"] = this.schemaName;
        data["id"] = this.id;
        return data; 
    }
}

/** 的列表DTO YSLog.WebManagement.DataBackup.Entities.YSLogDataBackupObject */
export interface IYSLogDataBackupObjectListDto {
    /** Name */
    name: string;
    /** Description */
    description: string | undefined;
    /** Indices */
    indices: string[];
    /** MountPointId */
    mountPointId: number;
    mountPoint: YSLogMountPointObject;
    /** DataSetId */
    dataSetId: number;
    jobType: BackupJobType;
    /** Corn表达式 */
    cornExpression: string | undefined;
    /** 备份进度 */
    progress: string | undefined;
    dataSet: YSLogDataSetObject;
    /** 数据类型 SchemaName */
    schemaName: string;
    id: number;
}

export class BackupHistoryInstance implements IBackupHistoryInstance {
    logger!: string | undefined;
    backupName!: string | undefined;
    timeStamp!: string | undefined;
    id!: number;

    constructor(data?: IBackupHistoryInstance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.logger = _data["logger"];
            this.backupName = _data["backupName"];
            this.timeStamp = _data["timeStamp"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BackupHistoryInstance {
        data = typeof data === 'object' ? data : {};
        let result = new BackupHistoryInstance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["logger"] = this.logger;
        data["backupName"] = this.backupName;
        data["timeStamp"] = this.timeStamp;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBackupHistoryInstance {
    logger: string | undefined;
    backupName: string | undefined;
    timeStamp: string | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetYSLogDataBackupObjectForEditOutput implements IGetYSLogDataBackupObjectForEditOutput {
    ysLogDataBackupObject!: YSLogDataBackupObjectEditDto;
    backupJobTypeTypeEnum!: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetYSLogDataBackupObjectForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ysLogDataBackupObject = _data["ysLogDataBackupObject"] ? YSLogDataBackupObjectEditDto.fromJS(_data["ysLogDataBackupObject"]) : <any>undefined;
            if (Array.isArray(_data["backupJobTypeTypeEnum"])) {
                this.backupJobTypeTypeEnum = [] as any;
                for (let item of _data["backupJobTypeTypeEnum"])
                    this.backupJobTypeTypeEnum!.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetYSLogDataBackupObjectForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetYSLogDataBackupObjectForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ysLogDataBackupObject"] = this.ysLogDataBackupObject ? this.ysLogDataBackupObject.toJSON() : <any>undefined;
        if (Array.isArray(this.backupJobTypeTypeEnum)) {
            data["backupJobTypeTypeEnum"] = [];
            for (let item of this.backupJobTypeTypeEnum)
                data["backupJobTypeTypeEnum"].push(item.toJSON());
        }
        return data; 
    }
}

/** 读取可编辑的Dto */
export interface IGetYSLogDataBackupObjectForEditOutput {
    ysLogDataBackupObject: YSLogDataBackupObjectEditDto;
    backupJobTypeTypeEnum: KeyValuePairOfStringString[] | undefined;
}

export class PagedResultDtoOfYSLogDataBackupObjectListDto implements IPagedResultDtoOfYSLogDataBackupObjectListDto {
    totalCount!: number;
    items!: YSLogDataBackupObjectListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfYSLogDataBackupObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(YSLogDataBackupObjectListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfYSLogDataBackupObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfYSLogDataBackupObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfYSLogDataBackupObjectListDto {
    totalCount: number;
    items: YSLogDataBackupObjectListDto[] | undefined;
}

export class ConflictClientDto implements IConflictClientDto {
    ip!: string | undefined;
    host_name!: string | undefined;

    constructor(data?: IConflictClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ip = _data["ip"];
            this.host_name = _data["host_name"];
        }
    }

    static fromJS(data: any): ConflictClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConflictClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ip"] = this.ip;
        data["host_name"] = this.host_name;
        return data; 
    }
}

export interface IConflictClientDto {
    ip: string | undefined;
    host_name: string | undefined;
}

export enum EngineStatus {
    Not_Created = "Not_Created",
    Created_Not_Running = "Created_Not_Running",
    Running = "Running",
}

/** 采集任务列表Dto */
export class RelatedCollectorDto implements IRelatedCollectorDto {
    /** 采集任务名称 */
    name!: string | undefined;
    /** shipper类型 */
    schema_name!: string | undefined;
    schema_name_pair!: KeyValuePairOfStringString;
    actual_status!: EngineStatus;

    constructor(data?: IRelatedCollectorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.schema_name = _data["schema_name"];
            this.schema_name_pair = _data["schema_name_pair"] ? KeyValuePairOfStringString.fromJS(_data["schema_name_pair"]) : <any>undefined;
            this.actual_status = _data["actual_status"];
        }
    }

    static fromJS(data: any): RelatedCollectorDto {
        data = typeof data === 'object' ? data : {};
        let result = new RelatedCollectorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["schema_name"] = this.schema_name;
        data["schema_name_pair"] = this.schema_name_pair ? this.schema_name_pair.toJSON() : <any>undefined;
        data["actual_status"] = this.actual_status;
        return data; 
    }
}

/** 采集任务列表Dto */
export interface IRelatedCollectorDto {
    /** 采集任务名称 */
    name: string | undefined;
    /** shipper类型 */
    schema_name: string | undefined;
    schema_name_pair: KeyValuePairOfStringString;
    actual_status: EngineStatus;
}

export enum OnlineStatus {
    Online = "Online",
    Offline = "Offline",
}

/** 的列表DTO YSLog.WebManagement.DataClient.Entities.YSLogDataClientObject */
export class YSLogDataClientObjectListDto implements IYSLogDataClientObjectListDto {
    /** 名称 */
    name!: string | undefined;
    /** 描述 */
    description!: string | undefined;
    /** 关联的客户端Guid/客户端新的Guid */
    related_client_guid!: string;
    engine!: YSLogDataEngineObject;
    /** 已注册客户端主机IP */
    ip!: string | undefined;
    /** 冲突客户端列表 */
    conflict_clients!: ConflictClientDto[] | undefined;
    /** 采集任务列表 */
    collectors!: RelatedCollectorDto[] | undefined;
    /** 已注册客户端主机名称 */
    host_name!: string | undefined;
    /** 最近一次心跳时间 */
    last_heartbeat_time!: moment.Moment;
    status!: OnlineStatus;
    id!: number;

    constructor(data?: IYSLogDataClientObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.related_client_guid = _data["related_client_guid"];
            this.engine = _data["engine"] ? YSLogDataEngineObject.fromJS(_data["engine"]) : <any>undefined;
            this.ip = _data["ip"];
            if (Array.isArray(_data["conflict_clients"])) {
                this.conflict_clients = [] as any;
                for (let item of _data["conflict_clients"])
                    this.conflict_clients!.push(ConflictClientDto.fromJS(item));
            }
            if (Array.isArray(_data["collectors"])) {
                this.collectors = [] as any;
                for (let item of _data["collectors"])
                    this.collectors!.push(RelatedCollectorDto.fromJS(item));
            }
            this.host_name = _data["host_name"];
            this.last_heartbeat_time = _data["last_heartbeat_time"] ? moment(_data["last_heartbeat_time"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): YSLogDataClientObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogDataClientObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["related_client_guid"] = this.related_client_guid;
        data["engine"] = this.engine ? this.engine.toJSON() : <any>undefined;
        data["ip"] = this.ip;
        if (Array.isArray(this.conflict_clients)) {
            data["conflict_clients"] = [];
            for (let item of this.conflict_clients)
                data["conflict_clients"].push(item.toJSON());
        }
        if (Array.isArray(this.collectors)) {
            data["collectors"] = [];
            for (let item of this.collectors)
                data["collectors"].push(item.toJSON());
        }
        data["host_name"] = this.host_name;
        data["last_heartbeat_time"] = this.last_heartbeat_time ? this.last_heartbeat_time.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }
}

/** 的列表DTO YSLog.WebManagement.DataClient.Entities.YSLogDataClientObject */
export interface IYSLogDataClientObjectListDto {
    /** 名称 */
    name: string | undefined;
    /** 描述 */
    description: string | undefined;
    /** 关联的客户端Guid/客户端新的Guid */
    related_client_guid: string;
    engine: YSLogDataEngineObject;
    /** 已注册客户端主机IP */
    ip: string | undefined;
    /** 冲突客户端列表 */
    conflict_clients: ConflictClientDto[] | undefined;
    /** 采集任务列表 */
    collectors: RelatedCollectorDto[] | undefined;
    /** 已注册客户端主机名称 */
    host_name: string | undefined;
    /** 最近一次心跳时间 */
    last_heartbeat_time: moment.Moment;
    status: OnlineStatus;
    id: number;
}

/** 的列表DTO YSLog.WebManagement.DataClient.Entities.YSLogDataClientObject */
export class YSLogDataClientObjectEditDto implements IYSLogDataClientObjectEditDto {
    /** Id */
    id!: number | undefined;
    /** 名称 */
    name!: string;
    /** 描述 */
    description!: string | undefined;
    /** 关联的采集引擎服务器 */
    related_engine_id!: number;
    /** 客户端原有Guid */
    old_client_guid!: string;
    /** 客户端主机IP */
    ip!: string;
    /** 客户端主机名称 */
    host_name!: string;

    constructor(data?: IYSLogDataClientObjectEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.related_engine_id = _data["related_engine_id"];
            this.old_client_guid = _data["old_client_guid"];
            this.ip = _data["ip"];
            this.host_name = _data["host_name"];
        }
    }

    static fromJS(data: any): YSLogDataClientObjectEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogDataClientObjectEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["related_engine_id"] = this.related_engine_id;
        data["old_client_guid"] = this.old_client_guid;
        data["ip"] = this.ip;
        data["host_name"] = this.host_name;
        return data; 
    }
}

/** 的列表DTO YSLog.WebManagement.DataClient.Entities.YSLogDataClientObject */
export interface IYSLogDataClientObjectEditDto {
    /** Id */
    id: number | undefined;
    /** 名称 */
    name: string;
    /** 描述 */
    description: string | undefined;
    /** 关联的采集引擎服务器 */
    related_engine_id: number;
    /** 客户端原有Guid */
    old_client_guid: string;
    /** 客户端主机IP */
    ip: string;
    /** 客户端主机名称 */
    host_name: string;
}

/** 读取可编辑的Dto */
export class GetYSLogDataClientObjectForEditOutput implements IGetYSLogDataClientObjectForEditOutput {
    ysLogDataClientObject!: YSLogDataClientObjectEditDto;

    constructor(data?: IGetYSLogDataClientObjectForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ysLogDataClientObject = _data["ysLogDataClientObject"] ? YSLogDataClientObjectEditDto.fromJS(_data["ysLogDataClientObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetYSLogDataClientObjectForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetYSLogDataClientObjectForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ysLogDataClientObject"] = this.ysLogDataClientObject ? this.ysLogDataClientObject.toJSON() : <any>undefined;
        return data; 
    }
}

/** 读取可编辑的Dto */
export interface IGetYSLogDataClientObjectForEditOutput {
    ysLogDataClientObject: YSLogDataClientObjectEditDto;
}

export class PagedResultDtoOfYSLogDataClientObjectListDto implements IPagedResultDtoOfYSLogDataClientObjectListDto {
    totalCount!: number;
    items!: YSLogDataClientObjectListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfYSLogDataClientObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(YSLogDataClientObjectListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfYSLogDataClientObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfYSLogDataClientObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfYSLogDataClientObjectListDto {
    totalCount: number;
    items: YSLogDataClientObjectListDto[] | undefined;
}

export class UnRegisteredDataClientDto implements IUnRegisteredDataClientDto {
    /** 客户端原本的Guid */
    old_client_guid!: string;
    engine!: YSLogDataEngineObject;
    /** 客户端主机IP */
    ip!: string;
    /** 客户端主机名称 */
    host_name!: string;

    constructor(data?: IUnRegisteredDataClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.engine = new YSLogDataEngineObject();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.old_client_guid = _data["old_client_guid"];
            this.engine = _data["engine"] ? YSLogDataEngineObject.fromJS(_data["engine"]) : new YSLogDataEngineObject();
            this.ip = _data["ip"];
            this.host_name = _data["host_name"];
        }
    }

    static fromJS(data: any): UnRegisteredDataClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnRegisteredDataClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["old_client_guid"] = this.old_client_guid;
        data["engine"] = this.engine ? this.engine.toJSON() : <any>undefined;
        data["ip"] = this.ip;
        data["host_name"] = this.host_name;
        return data; 
    }
}

export interface IUnRegisteredDataClientDto {
    /** 客户端原本的Guid */
    old_client_guid: string;
    engine: YSLogDataEngineObject;
    /** 客户端主机IP */
    ip: string;
    /** 客户端主机名称 */
    host_name: string;
}

export class CreateOrUpdateYSLogDataClientObjectInput implements ICreateOrUpdateYSLogDataClientObjectInput {
    ysLogDataClientObject!: YSLogDataClientObjectEditDto;

    constructor(data?: ICreateOrUpdateYSLogDataClientObjectInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ysLogDataClientObject = new YSLogDataClientObjectEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ysLogDataClientObject = _data["ysLogDataClientObject"] ? YSLogDataClientObjectEditDto.fromJS(_data["ysLogDataClientObject"]) : new YSLogDataClientObjectEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateYSLogDataClientObjectInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateYSLogDataClientObjectInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ysLogDataClientObject"] = this.ysLogDataClientObject ? this.ysLogDataClientObject.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateOrUpdateYSLogDataClientObjectInput {
    ysLogDataClientObject: YSLogDataClientObjectEditDto;
}

export class SolveConflictDataClientDto implements ISolveConflictDataClientDto {
    /** 原本的客户端Guid */
    related_client_guid!: string;
    /** 冲突客户端列表 */
    conflict_clients!: ConflictClientDto[] | undefined;
    id!: number;

    constructor(data?: ISolveConflictDataClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.related_client_guid = _data["related_client_guid"];
            if (Array.isArray(_data["conflict_clients"])) {
                this.conflict_clients = [] as any;
                for (let item of _data["conflict_clients"])
                    this.conflict_clients!.push(ConflictClientDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SolveConflictDataClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new SolveConflictDataClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["related_client_guid"] = this.related_client_guid;
        if (Array.isArray(this.conflict_clients)) {
            data["conflict_clients"] = [];
            for (let item of this.conflict_clients)
                data["conflict_clients"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface ISolveConflictDataClientDto {
    /** 原本的客户端Guid */
    related_client_guid: string;
    /** 冲突客户端列表 */
    conflict_clients: ConflictClientDto[] | undefined;
    id: number;
}

/** 采集任务的列表DTO YSLog.WebManagement.DataCollectTask.Entities.YSLogDataCollectorObject */
export class YSLogDataCollectorObjectEditDto implements IYSLogDataCollectorObjectEditDto {
    /** Id */
    id!: number | undefined;
    /** 名称 */
    name!: string;
    /** 描述 */
    description!: string | undefined;
    /** 关联客户端Guid数组 */
    related_client_ids!: number[] | undefined;
    /** 日志的数据类型 */
    log_type!: string | undefined;
    /** shipper类型 */
    schema_name!: string;
    /** shipper配置项 */
    shipper_configuration!: string;
    /** 数据过滤配置项 */
    filter_configuration!: string | undefined;
    /** 编码转换配置项 */
    code_configuration!: string | undefined;
    /** 多行合并配置项 */
    multiline_configuration!: string | undefined;
    /** 其他杂项配置 */
    misc_configuration!: string | undefined;
    /** 关联解析组件 */
    related_formatter_id!: number | undefined;
    /** 关联数据集 */
    related_dataset_id!: number;

    constructor(data?: IYSLogDataCollectorObjectEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["related_client_ids"])) {
                this.related_client_ids = [] as any;
                for (let item of _data["related_client_ids"])
                    this.related_client_ids!.push(item);
            }
            this.log_type = _data["log_type"];
            this.schema_name = _data["schema_name"];
            this.shipper_configuration = _data["shipper_configuration"];
            this.filter_configuration = _data["filter_configuration"];
            this.code_configuration = _data["code_configuration"];
            this.multiline_configuration = _data["multiline_configuration"];
            this.misc_configuration = _data["misc_configuration"];
            this.related_formatter_id = _data["related_formatter_id"];
            this.related_dataset_id = _data["related_dataset_id"];
        }
    }

    static fromJS(data: any): YSLogDataCollectorObjectEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogDataCollectorObjectEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.related_client_ids)) {
            data["related_client_ids"] = [];
            for (let item of this.related_client_ids)
                data["related_client_ids"].push(item);
        }
        data["log_type"] = this.log_type;
        data["schema_name"] = this.schema_name;
        data["shipper_configuration"] = this.shipper_configuration;
        data["filter_configuration"] = this.filter_configuration;
        data["code_configuration"] = this.code_configuration;
        data["multiline_configuration"] = this.multiline_configuration;
        data["misc_configuration"] = this.misc_configuration;
        data["related_formatter_id"] = this.related_formatter_id;
        data["related_dataset_id"] = this.related_dataset_id;
        return data; 
    }
}

/** 采集任务的列表DTO YSLog.WebManagement.DataCollectTask.Entities.YSLogDataCollectorObject */
export interface IYSLogDataCollectorObjectEditDto {
    /** Id */
    id: number | undefined;
    /** 名称 */
    name: string;
    /** 描述 */
    description: string | undefined;
    /** 关联客户端Guid数组 */
    related_client_ids: number[] | undefined;
    /** 日志的数据类型 */
    log_type: string | undefined;
    /** shipper类型 */
    schema_name: string;
    /** shipper配置项 */
    shipper_configuration: string;
    /** 数据过滤配置项 */
    filter_configuration: string | undefined;
    /** 编码转换配置项 */
    code_configuration: string | undefined;
    /** 多行合并配置项 */
    multiline_configuration: string | undefined;
    /** 其他杂项配置 */
    misc_configuration: string | undefined;
    /** 关联解析组件 */
    related_formatter_id: number | undefined;
    /** 关联数据集 */
    related_dataset_id: number;
}

export class CreateOrUpdateYSLogDataCollectorObjectInput implements ICreateOrUpdateYSLogDataCollectorObjectInput {
    collector!: YSLogDataCollectorObjectEditDto;

    constructor(data?: ICreateOrUpdateYSLogDataCollectorObjectInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.collector = new YSLogDataCollectorObjectEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.collector = _data["collector"] ? YSLogDataCollectorObjectEditDto.fromJS(_data["collector"]) : new YSLogDataCollectorObjectEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateYSLogDataCollectorObjectInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateYSLogDataCollectorObjectInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collector"] = this.collector ? this.collector.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateOrUpdateYSLogDataCollectorObjectInput {
    collector: YSLogDataCollectorObjectEditDto;
}

export class YSLogDataClientObject implements IYSLogDataClientObject {
    /** 客户端名称 */
    name!: string | undefined;
    /** 客户端描述 */
    description!: string | undefined;
    /** 该客户端记录在采集引擎上关联的客户端Guid */
    related_client_guid!: string;
    engine!: YSLogDataEngineObject;
    /** 客户端的主机IP */
    ip!: string | undefined;
    /** 客户端的主机名称 */
    host_name!: string | undefined;
    status!: OnlineStatus;
    /** 客户端最近一次心跳时间 */
    last_heartbeat_time!: moment.Moment;
    id!: number;

    constructor(data?: IYSLogDataClientObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.related_client_guid = _data["related_client_guid"];
            this.engine = _data["engine"] ? YSLogDataEngineObject.fromJS(_data["engine"]) : <any>undefined;
            this.ip = _data["ip"];
            this.host_name = _data["host_name"];
            this.status = _data["status"];
            this.last_heartbeat_time = _data["last_heartbeat_time"] ? moment(_data["last_heartbeat_time"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): YSLogDataClientObject {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogDataClientObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["related_client_guid"] = this.related_client_guid;
        data["engine"] = this.engine ? this.engine.toJSON() : <any>undefined;
        data["ip"] = this.ip;
        data["host_name"] = this.host_name;
        data["status"] = this.status;
        data["last_heartbeat_time"] = this.last_heartbeat_time ? this.last_heartbeat_time.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IYSLogDataClientObject {
    /** 客户端名称 */
    name: string | undefined;
    /** 客户端描述 */
    description: string | undefined;
    /** 该客户端记录在采集引擎上关联的客户端Guid */
    related_client_guid: string;
    engine: YSLogDataEngineObject;
    /** 客户端的主机IP */
    ip: string | undefined;
    /** 客户端的主机名称 */
    host_name: string | undefined;
    status: OnlineStatus;
    /** 客户端最近一次心跳时间 */
    last_heartbeat_time: moment.Moment;
    id: number;
}

export enum SyncResult {
    Success = "Success",
    Failed = "Failed",
}

export class YSLogDataCacheObject implements IYSLogDataCacheObject {
    /** 在采集引擎上关联的Cache的Guid */
    cache_guid!: string;
    engine!: YSLogDataEngineObject;
    /** 缓存类型 */
    schema_name!: string | undefined;
    /** 容量上限 */
    max_size!: number;
    /** Cache主要配置项 */
    cache_configuration!: string | undefined;
    /** 配置是否同步 */
    is_configuration_synced!: boolean;
    last_sync_result!: SyncResult;
    /** 是否软删除 */
    is_deleted!: boolean;
    id!: number;

    constructor(data?: IYSLogDataCacheObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cache_guid = _data["cache_guid"];
            this.engine = _data["engine"] ? YSLogDataEngineObject.fromJS(_data["engine"]) : <any>undefined;
            this.schema_name = _data["schema_name"];
            this.max_size = _data["max_size"];
            this.cache_configuration = _data["cache_configuration"];
            this.is_configuration_synced = _data["is_configuration_synced"];
            this.last_sync_result = _data["last_sync_result"];
            this.is_deleted = _data["is_deleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): YSLogDataCacheObject {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogDataCacheObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cache_guid"] = this.cache_guid;
        data["engine"] = this.engine ? this.engine.toJSON() : <any>undefined;
        data["schema_name"] = this.schema_name;
        data["max_size"] = this.max_size;
        data["cache_configuration"] = this.cache_configuration;
        data["is_configuration_synced"] = this.is_configuration_synced;
        data["last_sync_result"] = this.last_sync_result;
        data["is_deleted"] = this.is_deleted;
        data["id"] = this.id;
        return data; 
    }
}

export interface IYSLogDataCacheObject {
    /** 在采集引擎上关联的Cache的Guid */
    cache_guid: string;
    engine: YSLogDataEngineObject;
    /** 缓存类型 */
    schema_name: string | undefined;
    /** 容量上限 */
    max_size: number;
    /** Cache主要配置项 */
    cache_configuration: string | undefined;
    /** 配置是否同步 */
    is_configuration_synced: boolean;
    last_sync_result: SyncResult;
    /** 是否软删除 */
    is_deleted: boolean;
    id: number;
}

export enum ComponentType {
    Default = "Default",
    Custom = "Custom",
}

export class FormatterInstance implements IFormatterInstance {
    relatedIndexerGuid!: string;
    actuslStatus!: EngineStatus;
    isDeleted!: boolean;
    id!: number;

    constructor(data?: IFormatterInstance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.relatedIndexerGuid = _data["relatedIndexerGuid"];
            this.actuslStatus = _data["actuslStatus"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormatterInstance {
        data = typeof data === 'object' ? data : {};
        let result = new FormatterInstance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["relatedIndexerGuid"] = this.relatedIndexerGuid;
        data["actuslStatus"] = this.actuslStatus;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data; 
    }
}

export interface IFormatterInstance {
    relatedIndexerGuid: string;
    actuslStatus: EngineStatus;
    isDeleted: boolean;
    id: number;
}

export class StorageAdapterInstance implements IStorageAdapterInstance {
    relatedExporterGuid!: string;
    actuslStatus!: EngineStatus;
    isDeleted!: boolean;
    id!: number;

    constructor(data?: IStorageAdapterInstance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.relatedExporterGuid = _data["relatedExporterGuid"];
            this.actuslStatus = _data["actuslStatus"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StorageAdapterInstance {
        data = typeof data === 'object' ? data : {};
        let result = new StorageAdapterInstance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["relatedExporterGuid"] = this.relatedExporterGuid;
        data["actuslStatus"] = this.actuslStatus;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data; 
    }
}

export interface IStorageAdapterInstance {
    relatedExporterGuid: string;
    actuslStatus: EngineStatus;
    isDeleted: boolean;
    id: number;
}

export class YSLogDataStorageAdapterObject implements IYSLogDataStorageAdapterObject {
    /** 名称 */
    name!: string | undefined;
    /** 描述 */
    description!: string | undefined;
    cache!: YSLogDataCacheObject;
    engine!: YSLogDataEngineObject;
    type!: ComponentType;
    /** Exporter类型 */
    schema_name!: string | undefined;
    /** Exporter主要配置项 */
    exporter_configuration!: string | undefined;
    /** Exporter高级配置项 */
    misc_configuartion!: string | undefined;
    /** 关联的一组Exporter实例 */
    instances!: StorageAdapterInstance[] | undefined;
    /** 期望的Exporter实例个数 */
    instances_count!: number;
    /** 处于运行状态的Exporter实例个数 */
    running_instances_count!: number;
    /** 配置是否同步 */
    is_configuration_synced!: boolean;
    last_sync_result!: SyncResult;
    /** 是否软删除 */
    is_deleted!: boolean;
    id!: number;

    constructor(data?: IYSLogDataStorageAdapterObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.cache = _data["cache"] ? YSLogDataCacheObject.fromJS(_data["cache"]) : <any>undefined;
            this.engine = _data["engine"] ? YSLogDataEngineObject.fromJS(_data["engine"]) : <any>undefined;
            this.type = _data["type"];
            this.schema_name = _data["schema_name"];
            this.exporter_configuration = _data["exporter_configuration"];
            this.misc_configuartion = _data["misc_configuartion"];
            if (Array.isArray(_data["instances"])) {
                this.instances = [] as any;
                for (let item of _data["instances"])
                    this.instances!.push(StorageAdapterInstance.fromJS(item));
            }
            this.instances_count = _data["instances_count"];
            this.running_instances_count = _data["running_instances_count"];
            this.is_configuration_synced = _data["is_configuration_synced"];
            this.last_sync_result = _data["last_sync_result"];
            this.is_deleted = _data["is_deleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): YSLogDataStorageAdapterObject {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogDataStorageAdapterObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["cache"] = this.cache ? this.cache.toJSON() : <any>undefined;
        data["engine"] = this.engine ? this.engine.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["schema_name"] = this.schema_name;
        data["exporter_configuration"] = this.exporter_configuration;
        data["misc_configuartion"] = this.misc_configuartion;
        if (Array.isArray(this.instances)) {
            data["instances"] = [];
            for (let item of this.instances)
                data["instances"].push(item.toJSON());
        }
        data["instances_count"] = this.instances_count;
        data["running_instances_count"] = this.running_instances_count;
        data["is_configuration_synced"] = this.is_configuration_synced;
        data["last_sync_result"] = this.last_sync_result;
        data["is_deleted"] = this.is_deleted;
        data["id"] = this.id;
        return data; 
    }
}

export interface IYSLogDataStorageAdapterObject {
    /** 名称 */
    name: string | undefined;
    /** 描述 */
    description: string | undefined;
    cache: YSLogDataCacheObject;
    engine: YSLogDataEngineObject;
    type: ComponentType;
    /** Exporter类型 */
    schema_name: string | undefined;
    /** Exporter主要配置项 */
    exporter_configuration: string | undefined;
    /** Exporter高级配置项 */
    misc_configuartion: string | undefined;
    /** 关联的一组Exporter实例 */
    instances: StorageAdapterInstance[] | undefined;
    /** 期望的Exporter实例个数 */
    instances_count: number;
    /** 处于运行状态的Exporter实例个数 */
    running_instances_count: number;
    /** 配置是否同步 */
    is_configuration_synced: boolean;
    last_sync_result: SyncResult;
    /** 是否软删除 */
    is_deleted: boolean;
    id: number;
}

export class YSLogDataFormatterObject implements IYSLogDataFormatterObject {
    /** 名称 */
    name!: string | undefined;
    /** 描述 */
    description!: string | undefined;
    cache!: YSLogDataCacheObject;
    engine!: YSLogDataEngineObject;
    type!: ComponentType;
    /** Indexer类型 */
    schema_name!: string | undefined;
    /** Indexer主要配置项 */
    indexer_configuration!: string | undefined;
    /** Indexer高级配置项 */
    misc_configuration!: string | undefined;
    /** 关联的一组Indexer实例 */
    instances!: FormatterInstance[] | undefined;
    /** 期望的Indexer实例个数 */
    desired_instances_count!: number;
    storage_adapter!: YSLogDataStorageAdapterObject;
    /** 处于运行状态的Indexer实例个数 */
    running_instance_count!: number;
    /** 配置是否同步 */
    is_configuration_synced!: boolean;
    last_sync_result!: SyncResult;
    /** 是否软删除 */
    is_deleted!: boolean;
    id!: number;

    constructor(data?: IYSLogDataFormatterObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.cache = _data["cache"] ? YSLogDataCacheObject.fromJS(_data["cache"]) : <any>undefined;
            this.engine = _data["engine"] ? YSLogDataEngineObject.fromJS(_data["engine"]) : <any>undefined;
            this.type = _data["type"];
            this.schema_name = _data["schema_name"];
            this.indexer_configuration = _data["indexer_configuration"];
            this.misc_configuration = _data["misc_configuration"];
            if (Array.isArray(_data["instances"])) {
                this.instances = [] as any;
                for (let item of _data["instances"])
                    this.instances!.push(FormatterInstance.fromJS(item));
            }
            this.desired_instances_count = _data["desired_instances_count"];
            this.storage_adapter = _data["storage_adapter"] ? YSLogDataStorageAdapterObject.fromJS(_data["storage_adapter"]) : <any>undefined;
            this.running_instance_count = _data["running_instance_count"];
            this.is_configuration_synced = _data["is_configuration_synced"];
            this.last_sync_result = _data["last_sync_result"];
            this.is_deleted = _data["is_deleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): YSLogDataFormatterObject {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogDataFormatterObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["cache"] = this.cache ? this.cache.toJSON() : <any>undefined;
        data["engine"] = this.engine ? this.engine.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["schema_name"] = this.schema_name;
        data["indexer_configuration"] = this.indexer_configuration;
        data["misc_configuration"] = this.misc_configuration;
        if (Array.isArray(this.instances)) {
            data["instances"] = [];
            for (let item of this.instances)
                data["instances"].push(item.toJSON());
        }
        data["desired_instances_count"] = this.desired_instances_count;
        data["storage_adapter"] = this.storage_adapter ? this.storage_adapter.toJSON() : <any>undefined;
        data["running_instance_count"] = this.running_instance_count;
        data["is_configuration_synced"] = this.is_configuration_synced;
        data["last_sync_result"] = this.last_sync_result;
        data["is_deleted"] = this.is_deleted;
        data["id"] = this.id;
        return data; 
    }
}

export interface IYSLogDataFormatterObject {
    /** 名称 */
    name: string | undefined;
    /** 描述 */
    description: string | undefined;
    cache: YSLogDataCacheObject;
    engine: YSLogDataEngineObject;
    type: ComponentType;
    /** Indexer类型 */
    schema_name: string | undefined;
    /** Indexer主要配置项 */
    indexer_configuration: string | undefined;
    /** Indexer高级配置项 */
    misc_configuration: string | undefined;
    /** 关联的一组Indexer实例 */
    instances: FormatterInstance[] | undefined;
    /** 期望的Indexer实例个数 */
    desired_instances_count: number;
    storage_adapter: YSLogDataStorageAdapterObject;
    /** 处于运行状态的Indexer实例个数 */
    running_instance_count: number;
    /** 配置是否同步 */
    is_configuration_synced: boolean;
    last_sync_result: SyncResult;
    /** 是否软删除 */
    is_deleted: boolean;
    id: number;
}

/** 采集任务的列表DTO YSLog.WebManagement.DataCollectTask.Entities.YSLogDataCollectorObject */
export class YSLogDataCollectorObjectListDto implements IYSLogDataCollectorObjectListDto {
    /** 名称 */
    name!: string;
    /** 描述 */
    description!: string | undefined;
    client!: YSLogDataClientObject;
    /** shipper类型 */
    schema_name!: string;
    schema_name_pair!: KeyValuePairOfStringString;
    /** 日志的数据类型 */
    log_type!: string | undefined;
    log_type_pair!: KeyValuePairOfStringString;
    /** shipper配置项 */
    shipper_configuration!: string;
    /** 数据过滤配置项 */
    filter_configuration!: string | undefined;
    /** 编码转换配置项 */
    code_configuration!: string | undefined;
    /** 多行合并配置项 */
    multiline_configuration!: string | undefined;
    /** 其他杂项配置 */
    misc_configuration!: string | undefined;
    actual_status!: EngineStatus;
    desired_status!: EngineStatus;
    formatter!: YSLogDataFormatterObject;
    dataset!: YSLogDataSetObject;
    /** 配置是否同步 */
    is_configuration_synced!: boolean;
    last_sync_result!: SyncResult;
    id!: number;

    constructor(data?: IYSLogDataCollectorObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.client = _data["client"] ? YSLogDataClientObject.fromJS(_data["client"]) : <any>undefined;
            this.schema_name = _data["schema_name"];
            this.schema_name_pair = _data["schema_name_pair"] ? KeyValuePairOfStringString.fromJS(_data["schema_name_pair"]) : <any>undefined;
            this.log_type = _data["log_type"];
            this.log_type_pair = _data["log_type_pair"] ? KeyValuePairOfStringString.fromJS(_data["log_type_pair"]) : <any>undefined;
            this.shipper_configuration = _data["shipper_configuration"];
            this.filter_configuration = _data["filter_configuration"];
            this.code_configuration = _data["code_configuration"];
            this.multiline_configuration = _data["multiline_configuration"];
            this.misc_configuration = _data["misc_configuration"];
            this.actual_status = _data["actual_status"];
            this.desired_status = _data["desired_status"];
            this.formatter = _data["formatter"] ? YSLogDataFormatterObject.fromJS(_data["formatter"]) : <any>undefined;
            this.dataset = _data["dataset"] ? YSLogDataSetObject.fromJS(_data["dataset"]) : <any>undefined;
            this.is_configuration_synced = _data["is_configuration_synced"];
            this.last_sync_result = _data["last_sync_result"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): YSLogDataCollectorObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogDataCollectorObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["schema_name"] = this.schema_name;
        data["schema_name_pair"] = this.schema_name_pair ? this.schema_name_pair.toJSON() : <any>undefined;
        data["log_type"] = this.log_type;
        data["log_type_pair"] = this.log_type_pair ? this.log_type_pair.toJSON() : <any>undefined;
        data["shipper_configuration"] = this.shipper_configuration;
        data["filter_configuration"] = this.filter_configuration;
        data["code_configuration"] = this.code_configuration;
        data["multiline_configuration"] = this.multiline_configuration;
        data["misc_configuration"] = this.misc_configuration;
        data["actual_status"] = this.actual_status;
        data["desired_status"] = this.desired_status;
        data["formatter"] = this.formatter ? this.formatter.toJSON() : <any>undefined;
        data["dataset"] = this.dataset ? this.dataset.toJSON() : <any>undefined;
        data["is_configuration_synced"] = this.is_configuration_synced;
        data["last_sync_result"] = this.last_sync_result;
        data["id"] = this.id;
        return data; 
    }
}

/** 采集任务的列表DTO YSLog.WebManagement.DataCollectTask.Entities.YSLogDataCollectorObject */
export interface IYSLogDataCollectorObjectListDto {
    /** 名称 */
    name: string;
    /** 描述 */
    description: string | undefined;
    client: YSLogDataClientObject;
    /** shipper类型 */
    schema_name: string;
    schema_name_pair: KeyValuePairOfStringString;
    /** 日志的数据类型 */
    log_type: string | undefined;
    log_type_pair: KeyValuePairOfStringString;
    /** shipper配置项 */
    shipper_configuration: string;
    /** 数据过滤配置项 */
    filter_configuration: string | undefined;
    /** 编码转换配置项 */
    code_configuration: string | undefined;
    /** 多行合并配置项 */
    multiline_configuration: string | undefined;
    /** 其他杂项配置 */
    misc_configuration: string | undefined;
    actual_status: EngineStatus;
    desired_status: EngineStatus;
    formatter: YSLogDataFormatterObject;
    dataset: YSLogDataSetObject;
    /** 配置是否同步 */
    is_configuration_synced: boolean;
    last_sync_result: SyncResult;
    id: number;
}

/** 读取可编辑采集任务的Dto */
export class GetYSLogDataCollectorObjectForEditOutput implements IGetYSLogDataCollectorObjectForEditOutput {
    collector!: YSLogDataCollectorObjectEditDto;
    /** Shipper的SchemaName可选值 */
    schema_name_enum!: KeyValuePairOfStringString[] | undefined;
    /** Shipper的LogType可选值 */
    log_type_enum!: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetYSLogDataCollectorObjectForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.collector = _data["collector"] ? YSLogDataCollectorObjectEditDto.fromJS(_data["collector"]) : <any>undefined;
            if (Array.isArray(_data["schema_name_enum"])) {
                this.schema_name_enum = [] as any;
                for (let item of _data["schema_name_enum"])
                    this.schema_name_enum!.push(KeyValuePairOfStringString.fromJS(item));
            }
            if (Array.isArray(_data["log_type_enum"])) {
                this.log_type_enum = [] as any;
                for (let item of _data["log_type_enum"])
                    this.log_type_enum!.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetYSLogDataCollectorObjectForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetYSLogDataCollectorObjectForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collector"] = this.collector ? this.collector.toJSON() : <any>undefined;
        if (Array.isArray(this.schema_name_enum)) {
            data["schema_name_enum"] = [];
            for (let item of this.schema_name_enum)
                data["schema_name_enum"].push(item.toJSON());
        }
        if (Array.isArray(this.log_type_enum)) {
            data["log_type_enum"] = [];
            for (let item of this.log_type_enum)
                data["log_type_enum"].push(item.toJSON());
        }
        return data; 
    }
}

/** 读取可编辑采集任务的Dto */
export interface IGetYSLogDataCollectorObjectForEditOutput {
    collector: YSLogDataCollectorObjectEditDto;
    /** Shipper的SchemaName可选值 */
    schema_name_enum: KeyValuePairOfStringString[] | undefined;
    /** Shipper的LogType可选值 */
    log_type_enum: KeyValuePairOfStringString[] | undefined;
}

export class PagedResultDtoOfYSLogDataCollectorObjectListDto implements IPagedResultDtoOfYSLogDataCollectorObjectListDto {
    totalCount!: number;
    items!: YSLogDataCollectorObjectListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfYSLogDataCollectorObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(YSLogDataCollectorObjectListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfYSLogDataCollectorObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfYSLogDataCollectorObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfYSLogDataCollectorObjectListDto {
    totalCount: number;
    items: YSLogDataCollectorObjectListDto[] | undefined;
}

/** 数据解析组件的列表DTO YSLog.WebManagement.DataCollectTask.Entities.YSLogDataFormatterObject */
export class YSLogDataFormatterObjectEditDto implements IYSLogDataFormatterObjectEditDto {
    /** Id */
    id!: number | undefined;
    /** 名称 */
    name!: string;
    /** 描述 */
    description!: string | undefined;
    /** Indexer的SchemaName */
    schema_name!: string;
    /** Indexer主要配置项 */
    indexer_configuration!: string | undefined;
    /** Indexer高级配置项 */
    misc_configuration!: string | undefined;
    /** 期望的关联实例个数 */
    desired_instances_count!: number;

    constructor(data?: IYSLogDataFormatterObjectEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.schema_name = _data["schema_name"];
            this.indexer_configuration = _data["indexer_configuration"];
            this.misc_configuration = _data["misc_configuration"];
            this.desired_instances_count = _data["desired_instances_count"];
        }
    }

    static fromJS(data: any): YSLogDataFormatterObjectEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogDataFormatterObjectEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["schema_name"] = this.schema_name;
        data["indexer_configuration"] = this.indexer_configuration;
        data["misc_configuration"] = this.misc_configuration;
        data["desired_instances_count"] = this.desired_instances_count;
        return data; 
    }
}

/** 数据解析组件的列表DTO YSLog.WebManagement.DataCollectTask.Entities.YSLogDataFormatterObject */
export interface IYSLogDataFormatterObjectEditDto {
    /** Id */
    id: number | undefined;
    /** 名称 */
    name: string;
    /** 描述 */
    description: string | undefined;
    /** Indexer的SchemaName */
    schema_name: string;
    /** Indexer主要配置项 */
    indexer_configuration: string | undefined;
    /** Indexer高级配置项 */
    misc_configuration: string | undefined;
    /** 期望的关联实例个数 */
    desired_instances_count: number;
}

export class CreateOrUpdateYSLogDataFormatterObjectInput implements ICreateOrUpdateYSLogDataFormatterObjectInput {
    formatter!: YSLogDataFormatterObjectEditDto;

    constructor(data?: ICreateOrUpdateYSLogDataFormatterObjectInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.formatter = new YSLogDataFormatterObjectEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formatter = _data["formatter"] ? YSLogDataFormatterObjectEditDto.fromJS(_data["formatter"]) : new YSLogDataFormatterObjectEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateYSLogDataFormatterObjectInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateYSLogDataFormatterObjectInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formatter"] = this.formatter ? this.formatter.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateOrUpdateYSLogDataFormatterObjectInput {
    formatter: YSLogDataFormatterObjectEditDto;
}

/** 数据解析组件的列表DTO YSLog.WebManagement.DataCollectTask.Entities.YSLogDataFormatterObject */
export class YSLogDataFormatterObjectListDto implements IYSLogDataFormatterObjectListDto {
    /** 名称 */
    name!: string | undefined;
    /** 描述 */
    description!: string | undefined;
    type!: ComponentType;
    /** Indexer的Schema */
    schema_name!: string | undefined;
    schema_name_pair!: KeyValuePairOfStringString;
    /** Indexer主要配置项 */
    indexer_configuration!: string | undefined;
    /** Indexer高级配置项 */
    misc_configuration!: string | undefined;
    /** 期望的关联实例数量 */
    desired_instances_count!: number;
    /** 运行中的实例数量 */
    running_instance_count!: number;
    /** 关联的采集任务的总量 */
    related_collector_count!: number;
    /** 运行中的采集任务的数量 */
    running_collector_count!: number;
    /** 配置是否同步 */
    is_configuration_synced!: boolean;
    last_sync_result!: SyncResult;
    id!: number;

    constructor(data?: IYSLogDataFormatterObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.type = _data["type"];
            this.schema_name = _data["schema_name"];
            this.schema_name_pair = _data["schema_name_pair"] ? KeyValuePairOfStringString.fromJS(_data["schema_name_pair"]) : <any>undefined;
            this.indexer_configuration = _data["indexer_configuration"];
            this.misc_configuration = _data["misc_configuration"];
            this.desired_instances_count = _data["desired_instances_count"];
            this.running_instance_count = _data["running_instance_count"];
            this.related_collector_count = _data["related_collector_count"];
            this.running_collector_count = _data["running_collector_count"];
            this.is_configuration_synced = _data["is_configuration_synced"];
            this.last_sync_result = _data["last_sync_result"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): YSLogDataFormatterObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogDataFormatterObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["type"] = this.type;
        data["schema_name"] = this.schema_name;
        data["schema_name_pair"] = this.schema_name_pair ? this.schema_name_pair.toJSON() : <any>undefined;
        data["indexer_configuration"] = this.indexer_configuration;
        data["misc_configuration"] = this.misc_configuration;
        data["desired_instances_count"] = this.desired_instances_count;
        data["running_instance_count"] = this.running_instance_count;
        data["related_collector_count"] = this.related_collector_count;
        data["running_collector_count"] = this.running_collector_count;
        data["is_configuration_synced"] = this.is_configuration_synced;
        data["last_sync_result"] = this.last_sync_result;
        data["id"] = this.id;
        return data; 
    }
}

/** 数据解析组件的列表DTO YSLog.WebManagement.DataCollectTask.Entities.YSLogDataFormatterObject */
export interface IYSLogDataFormatterObjectListDto {
    /** 名称 */
    name: string | undefined;
    /** 描述 */
    description: string | undefined;
    type: ComponentType;
    /** Indexer的Schema */
    schema_name: string | undefined;
    schema_name_pair: KeyValuePairOfStringString;
    /** Indexer主要配置项 */
    indexer_configuration: string | undefined;
    /** Indexer高级配置项 */
    misc_configuration: string | undefined;
    /** 期望的关联实例数量 */
    desired_instances_count: number;
    /** 运行中的实例数量 */
    running_instance_count: number;
    /** 关联的采集任务的总量 */
    related_collector_count: number;
    /** 运行中的采集任务的数量 */
    running_collector_count: number;
    /** 配置是否同步 */
    is_configuration_synced: boolean;
    last_sync_result: SyncResult;
    id: number;
}

/** 读取可编辑数据解析组件的Dto */
export class GetYSLogDataFormatterObjectForEditOutput implements IGetYSLogDataFormatterObjectForEditOutput {
    formatter!: YSLogDataFormatterObjectEditDto;
    schema_name_enum!: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetYSLogDataFormatterObjectForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formatter = _data["formatter"] ? YSLogDataFormatterObjectEditDto.fromJS(_data["formatter"]) : <any>undefined;
            if (Array.isArray(_data["schema_name_enum"])) {
                this.schema_name_enum = [] as any;
                for (let item of _data["schema_name_enum"])
                    this.schema_name_enum!.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetYSLogDataFormatterObjectForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetYSLogDataFormatterObjectForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formatter"] = this.formatter ? this.formatter.toJSON() : <any>undefined;
        if (Array.isArray(this.schema_name_enum)) {
            data["schema_name_enum"] = [];
            for (let item of this.schema_name_enum)
                data["schema_name_enum"].push(item.toJSON());
        }
        return data; 
    }
}

/** 读取可编辑数据解析组件的Dto */
export interface IGetYSLogDataFormatterObjectForEditOutput {
    formatter: YSLogDataFormatterObjectEditDto;
    schema_name_enum: KeyValuePairOfStringString[] | undefined;
}

export class PagedResultDtoOfYSLogDataFormatterObjectListDto implements IPagedResultDtoOfYSLogDataFormatterObjectListDto {
    totalCount!: number;
    items!: YSLogDataFormatterObjectListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfYSLogDataFormatterObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(YSLogDataFormatterObjectListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfYSLogDataFormatterObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfYSLogDataFormatterObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfYSLogDataFormatterObjectListDto {
    totalCount: number;
    items: YSLogDataFormatterObjectListDto[] | undefined;
}

/** 的列表DTO */
export class YSLogDataRestoreObjectEditDto implements IYSLogDataRestoreObjectEditDto {
    /** Id */
    id!: number | undefined;
    /** Name */
    name!: string;
    /** Description */
    description!: string | undefined;
    /** DataSetId */
    dataSetId!: number;
    /** MountPointId */
    mountPointId!: number;
    /** SubPath */
    subPath!: string;

    constructor(data?: IYSLogDataRestoreObjectEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.dataSetId = _data["dataSetId"];
            this.mountPointId = _data["mountPointId"];
            this.subPath = _data["subPath"];
        }
    }

    static fromJS(data: any): YSLogDataRestoreObjectEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogDataRestoreObjectEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["dataSetId"] = this.dataSetId;
        data["mountPointId"] = this.mountPointId;
        data["subPath"] = this.subPath;
        return data; 
    }
}

/** 的列表DTO */
export interface IYSLogDataRestoreObjectEditDto {
    /** Id */
    id: number | undefined;
    /** Name */
    name: string;
    /** Description */
    description: string | undefined;
    /** DataSetId */
    dataSetId: number;
    /** MountPointId */
    mountPointId: number;
    /** SubPath */
    subPath: string;
}

export class CreateOrUpdateYSLogDataRestoreObjectInput implements ICreateOrUpdateYSLogDataRestoreObjectInput {
    ysLogDataRestoreObject!: YSLogDataRestoreObjectEditDto;

    constructor(data?: ICreateOrUpdateYSLogDataRestoreObjectInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ysLogDataRestoreObject = new YSLogDataRestoreObjectEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ysLogDataRestoreObject = _data["ysLogDataRestoreObject"] ? YSLogDataRestoreObjectEditDto.fromJS(_data["ysLogDataRestoreObject"]) : new YSLogDataRestoreObjectEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateYSLogDataRestoreObjectInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateYSLogDataRestoreObjectInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ysLogDataRestoreObject"] = this.ysLogDataRestoreObject ? this.ysLogDataRestoreObject.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateOrUpdateYSLogDataRestoreObjectInput {
    ysLogDataRestoreObject: YSLogDataRestoreObjectEditDto;
}

/** 的列表DTO */
export class YSLogDataRestoreObjectListDto implements IYSLogDataRestoreObjectListDto {
    /** Name */
    name!: string;
    /** Description */
    description!: string | undefined;
    /** DataSetId */
    dataSetId!: number;
    dataSet!: YSLogDataSetObject;
    /** MountPointId */
    mountPointId!: number;
    mountPoint!: YSLogMountPointObject;
    /** SubPath */
    subPath!: string;
    /** 进度 */
    progress!: string | undefined;
    id!: number;

    constructor(data?: IYSLogDataRestoreObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.dataSetId = _data["dataSetId"];
            this.dataSet = _data["dataSet"] ? YSLogDataSetObject.fromJS(_data["dataSet"]) : <any>undefined;
            this.mountPointId = _data["mountPointId"];
            this.mountPoint = _data["mountPoint"] ? YSLogMountPointObject.fromJS(_data["mountPoint"]) : <any>undefined;
            this.subPath = _data["subPath"];
            this.progress = _data["progress"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): YSLogDataRestoreObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogDataRestoreObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["dataSetId"] = this.dataSetId;
        data["dataSet"] = this.dataSet ? this.dataSet.toJSON() : <any>undefined;
        data["mountPointId"] = this.mountPointId;
        data["mountPoint"] = this.mountPoint ? this.mountPoint.toJSON() : <any>undefined;
        data["subPath"] = this.subPath;
        data["progress"] = this.progress;
        data["id"] = this.id;
        return data; 
    }
}

/** 的列表DTO */
export interface IYSLogDataRestoreObjectListDto {
    /** Name */
    name: string;
    /** Description */
    description: string | undefined;
    /** DataSetId */
    dataSetId: number;
    dataSet: YSLogDataSetObject;
    /** MountPointId */
    mountPointId: number;
    mountPoint: YSLogMountPointObject;
    /** SubPath */
    subPath: string;
    /** 进度 */
    progress: string | undefined;
    id: number;
}

export class RestoreHistoryInstance implements IRestoreHistoryInstance {
    logger!: string | undefined;
    restoreName!: string | undefined;
    timeStamp!: string | undefined;
    id!: number;

    constructor(data?: IRestoreHistoryInstance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.logger = _data["logger"];
            this.restoreName = _data["restoreName"];
            this.timeStamp = _data["timeStamp"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RestoreHistoryInstance {
        data = typeof data === 'object' ? data : {};
        let result = new RestoreHistoryInstance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["logger"] = this.logger;
        data["restoreName"] = this.restoreName;
        data["timeStamp"] = this.timeStamp;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRestoreHistoryInstance {
    logger: string | undefined;
    restoreName: string | undefined;
    timeStamp: string | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetYSLogDataRestoreObjectForEditOutput implements IGetYSLogDataRestoreObjectForEditOutput {
    ysLogDataRestoreObject!: YSLogDataRestoreObjectEditDto;

    constructor(data?: IGetYSLogDataRestoreObjectForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ysLogDataRestoreObject = _data["ysLogDataRestoreObject"] ? YSLogDataRestoreObjectEditDto.fromJS(_data["ysLogDataRestoreObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetYSLogDataRestoreObjectForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetYSLogDataRestoreObjectForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ysLogDataRestoreObject"] = this.ysLogDataRestoreObject ? this.ysLogDataRestoreObject.toJSON() : <any>undefined;
        return data; 
    }
}

/** 读取可编辑的Dto */
export interface IGetYSLogDataRestoreObjectForEditOutput {
    ysLogDataRestoreObject: YSLogDataRestoreObjectEditDto;
}

export class PagedResultDtoOfYSLogDataRestoreObjectListDto implements IPagedResultDtoOfYSLogDataRestoreObjectListDto {
    totalCount!: number;
    items!: YSLogDataRestoreObjectListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfYSLogDataRestoreObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(YSLogDataRestoreObjectListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfYSLogDataRestoreObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfYSLogDataRestoreObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfYSLogDataRestoreObjectListDto {
    totalCount: number;
    items: YSLogDataRestoreObjectListDto[] | undefined;
}

export class YSLogDataSetObjectListDto implements IYSLogDataSetObjectListDto {
    /** 关联的数据集Id */
    cluster_id!: number;
    cluster!: YSLogESClusterObject;
    /** 数据集名称 */
    name!: string | undefined;
    /** 数据集描述 */
    description!: string | undefined;
    /** 该数据集中所包含的数据类型的SchemaName */
    schema_name!: string | undefined;
    schema_name_pair!: KeyValuePairOfStringString;
    match_mode!: IndexMatchMode;
    id!: number;

    constructor(data?: IYSLogDataSetObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cluster_id = _data["cluster_id"];
            this.cluster = _data["cluster"] ? YSLogESClusterObject.fromJS(_data["cluster"]) : <any>undefined;
            this.name = _data["name"];
            this.description = _data["description"];
            this.schema_name = _data["schema_name"];
            this.schema_name_pair = _data["schema_name_pair"] ? KeyValuePairOfStringString.fromJS(_data["schema_name_pair"]) : <any>undefined;
            this.match_mode = _data["match_mode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): YSLogDataSetObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogDataSetObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cluster_id"] = this.cluster_id;
        data["cluster"] = this.cluster ? this.cluster.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        data["schema_name"] = this.schema_name;
        data["schema_name_pair"] = this.schema_name_pair ? this.schema_name_pair.toJSON() : <any>undefined;
        data["match_mode"] = this.match_mode;
        data["id"] = this.id;
        return data; 
    }
}

export interface IYSLogDataSetObjectListDto {
    /** 关联的数据集Id */
    cluster_id: number;
    cluster: YSLogESClusterObject;
    /** 数据集名称 */
    name: string | undefined;
    /** 数据集描述 */
    description: string | undefined;
    /** 该数据集中所包含的数据类型的SchemaName */
    schema_name: string | undefined;
    schema_name_pair: KeyValuePairOfStringString;
    match_mode: IndexMatchMode;
    id: number;
}

export class IndiceInfo implements IIndiceInfo {
    name!: string | undefined;
    size!: string | undefined;
    docCount!: string | undefined;
    isWrite!: boolean;

    constructor(data?: IIndiceInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.size = _data["size"];
            this.docCount = _data["docCount"];
            this.isWrite = _data["isWrite"];
        }
    }

    static fromJS(data: any): IndiceInfo {
        data = typeof data === 'object' ? data : {};
        let result = new IndiceInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["size"] = this.size;
        data["docCount"] = this.docCount;
        data["isWrite"] = this.isWrite;
        return data; 
    }
}

export interface IIndiceInfo {
    name: string | undefined;
    size: string | undefined;
    docCount: string | undefined;
    isWrite: boolean;
}

export class PagedResultDtoOfYSLogDataSetObjectListDto implements IPagedResultDtoOfYSLogDataSetObjectListDto {
    totalCount!: number;
    items!: YSLogDataSetObjectListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfYSLogDataSetObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(YSLogDataSetObjectListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfYSLogDataSetObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfYSLogDataSetObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfYSLogDataSetObjectListDto {
    totalCount: number;
    items: YSLogDataSetObjectListDto[] | undefined;
}

/** 的列表DTO YSLog.WebManagement.MountPoint.Entities.YSLogMountPointObject */
export class YSLogMountPointObjectEditDto implements IYSLogMountPointObjectEditDto {
    /** Id */
    id!: number | undefined;
    /** Name */
    name!: string;
    mountType!: MountProtocol;
    /** Source */
    source!: string;
    /** MountPointConfiguration */
    mountPointConfiguration!: { [key: string]: string; };

    constructor(data?: IYSLogMountPointObjectEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.mountPointConfiguration = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.mountType = _data["mountType"];
            this.source = _data["source"];
            if (_data["mountPointConfiguration"]) {
                this.mountPointConfiguration = {} as any;
                for (let key in _data["mountPointConfiguration"]) {
                    if (_data["mountPointConfiguration"].hasOwnProperty(key))
                        this.mountPointConfiguration![key] = _data["mountPointConfiguration"][key];
                }
            }
        }
    }

    static fromJS(data: any): YSLogMountPointObjectEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogMountPointObjectEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["mountType"] = this.mountType;
        data["source"] = this.source;
        if (this.mountPointConfiguration) {
            data["mountPointConfiguration"] = {};
            for (let key in this.mountPointConfiguration) {
                if (this.mountPointConfiguration.hasOwnProperty(key))
                    data["mountPointConfiguration"][key] = this.mountPointConfiguration[key];
            }
        }
        return data; 
    }
}

/** 的列表DTO YSLog.WebManagement.MountPoint.Entities.YSLogMountPointObject */
export interface IYSLogMountPointObjectEditDto {
    /** Id */
    id: number | undefined;
    /** Name */
    name: string;
    mountType: MountProtocol;
    /** Source */
    source: string;
    /** MountPointConfiguration */
    mountPointConfiguration: { [key: string]: string; };
}

export class CreateOrUpdateYSLogMountPointObjectInput implements ICreateOrUpdateYSLogMountPointObjectInput {
    ysLogMountPointObject!: YSLogMountPointObjectEditDto;

    constructor(data?: ICreateOrUpdateYSLogMountPointObjectInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ysLogMountPointObject = new YSLogMountPointObjectEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ysLogMountPointObject = _data["ysLogMountPointObject"] ? YSLogMountPointObjectEditDto.fromJS(_data["ysLogMountPointObject"]) : new YSLogMountPointObjectEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateYSLogMountPointObjectInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateYSLogMountPointObjectInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ysLogMountPointObject"] = this.ysLogMountPointObject ? this.ysLogMountPointObject.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateOrUpdateYSLogMountPointObjectInput {
    ysLogMountPointObject: YSLogMountPointObjectEditDto;
}

/** 的列表DTO YSLog.WebManagement.MountPoint.Entities.YSLogMountPointObject */
export class YSLogMountPointObjectListDto implements IYSLogMountPointObjectListDto {
    /** Name */
    name!: string;
    mountType!: MountProtocol;
    /** Source */
    source!: string;
    /** MountPointConfiguration */
    mountPointConfiguration!: { [key: string]: string; };
    id!: number;

    constructor(data?: IYSLogMountPointObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.mountPointConfiguration = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.mountType = _data["mountType"];
            this.source = _data["source"];
            if (_data["mountPointConfiguration"]) {
                this.mountPointConfiguration = {} as any;
                for (let key in _data["mountPointConfiguration"]) {
                    if (_data["mountPointConfiguration"].hasOwnProperty(key))
                        this.mountPointConfiguration![key] = _data["mountPointConfiguration"][key];
                }
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): YSLogMountPointObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogMountPointObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["mountType"] = this.mountType;
        data["source"] = this.source;
        if (this.mountPointConfiguration) {
            data["mountPointConfiguration"] = {};
            for (let key in this.mountPointConfiguration) {
                if (this.mountPointConfiguration.hasOwnProperty(key))
                    data["mountPointConfiguration"][key] = this.mountPointConfiguration[key];
            }
        }
        data["id"] = this.id;
        return data; 
    }
}

/** 的列表DTO YSLog.WebManagement.MountPoint.Entities.YSLogMountPointObject */
export interface IYSLogMountPointObjectListDto {
    /** Name */
    name: string;
    mountType: MountProtocol;
    /** Source */
    source: string;
    /** MountPointConfiguration */
    mountPointConfiguration: { [key: string]: string; };
    id: number;
}

/** 读取可编辑的Dto */
export class GetYSLogMountPointObjectForEditOutput implements IGetYSLogMountPointObjectForEditOutput {
    ysLogMountPointObject!: YSLogMountPointObjectEditDto;
    eTypeTypeEnum!: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetYSLogMountPointObjectForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ysLogMountPointObject = _data["ysLogMountPointObject"] ? YSLogMountPointObjectEditDto.fromJS(_data["ysLogMountPointObject"]) : <any>undefined;
            if (Array.isArray(_data["eTypeTypeEnum"])) {
                this.eTypeTypeEnum = [] as any;
                for (let item of _data["eTypeTypeEnum"])
                    this.eTypeTypeEnum!.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetYSLogMountPointObjectForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetYSLogMountPointObjectForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ysLogMountPointObject"] = this.ysLogMountPointObject ? this.ysLogMountPointObject.toJSON() : <any>undefined;
        if (Array.isArray(this.eTypeTypeEnum)) {
            data["eTypeTypeEnum"] = [];
            for (let item of this.eTypeTypeEnum)
                data["eTypeTypeEnum"].push(item.toJSON());
        }
        return data; 
    }
}

/** 读取可编辑的Dto */
export interface IGetYSLogMountPointObjectForEditOutput {
    ysLogMountPointObject: YSLogMountPointObjectEditDto;
    eTypeTypeEnum: KeyValuePairOfStringString[] | undefined;
}

export class PagedResultDtoOfYSLogMountPointObjectListDto implements IPagedResultDtoOfYSLogMountPointObjectListDto {
    totalCount!: number;
    items!: YSLogMountPointObjectListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfYSLogMountPointObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(YSLogMountPointObjectListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfYSLogMountPointObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfYSLogMountPointObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfYSLogMountPointObjectListDto {
    totalCount: number;
    items: YSLogMountPointObjectListDto[] | undefined;
}

export class BaseQueryDefinition implements IBaseQueryDefinition {

    protected _discriminator: string;

    constructor(data?: IBaseQueryDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "BaseQueryDefinition";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): BaseQueryDefinition {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "date_range") {
            let result = new DateRangeQueryDefinition();
            result.init(data);
            return result;
        }
        if (data["type"] === "exists") {
            let result = new ExistsQueryDefinition();
            result.init(data);
            return result;
        }
        if (data["type"] === "match") {
            let result = new MatchQueryDefinition();
            result.init(data);
            return result;
        }
        if (data["type"] === "numeric_range") {
            let result = new NumericRangeQueryDefinition();
            result.init(data);
            return result;
        }
        if (data["type"] === "query_string") {
            let result = new QueryStringQueryDefinition();
            result.init(data);
            return result;
        }
        if (data["type"] === "scripted") {
            let result = new ScriptedQueryDefinition();
            result.init(data);
            return result;
        }
        if (data["type"] === "term") {
            let result = new TermQueryDefinition();
            result.init(data);
            return result;
        }
        if (data["type"] === "wildcard") {
            let result = new WildcardQueryDefinition();
            result.init(data);
            return result;
        }
        let result = new BaseQueryDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this._discriminator; 
        return data; 
    }
}

export interface IBaseQueryDefinition {
}

/** 以时间段为条件进行查询 */
export class DateRangeQueryDefinition extends BaseQueryDefinition implements IDateRangeQueryDefinition {
    readonly type!: string;
    /** 选取时间范围的字段名，必填 */
    field!: string;
    /** 用于记录前端选择的日期类型：绝对、相对、自定义
与ES查询无关 */
    date_type!: string | undefined;
    gte!: string | undefined;
    gt!: string | undefined;
    lte!: string | undefined;
    lt!: string | undefined;
    format!: string | undefined;
    time_zone!: string | undefined;
    relation!: string | undefined;

    constructor(data?: IDateRangeQueryDefinition) {
        super(data);
        if (!data) {
            this.type = "date_range";
        }
        this._discriminator = "DateRangeQueryDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "date_range";
            this.field = _data["field"];
            this.date_type = _data["date_type"];
            this.gte = _data["gte"];
            this.gt = _data["gt"];
            this.lte = _data["lte"];
            this.lt = _data["lt"];
            this.format = _data["format"];
            this.time_zone = _data["time_zone"];
            this.relation = _data["relation"];
        }
    }

    static fromJS(data: any): DateRangeQueryDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new DateRangeQueryDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["field"] = this.field;
        data["date_type"] = this.date_type;
        data["gte"] = this.gte;
        data["gt"] = this.gt;
        data["lte"] = this.lte;
        data["lt"] = this.lt;
        data["format"] = this.format;
        data["time_zone"] = this.time_zone;
        data["relation"] = this.relation;
        super.toJSON(data);
        return data; 
    }
}

/** 以时间段为条件进行查询 */
export interface IDateRangeQueryDefinition extends IBaseQueryDefinition {
    type: string;
    /** 选取时间范围的字段名，必填 */
    field: string;
    /** 用于记录前端选择的日期类型：绝对、相对、自定义
与ES查询无关 */
    date_type: string | undefined;
    gte: string | undefined;
    gt: string | undefined;
    lte: string | undefined;
    lt: string | undefined;
    format: string | undefined;
    time_zone: string | undefined;
    relation: string | undefined;
}

/** 定义一个ES搜索/查询条件（request_body中"query"中的内容） 与Aggregation无关，与如何查询（sort order、from、to等）无关 */
export class YSLogQueryObject implements IYSLogQueryObject {
    /** 默认的查询条件，对应用户在search bar中输入的lucene查询语句，简化为普通字符串。 */
    default_query!: string | undefined;
    default_date_range!: DateRangeQueryDefinition;
    must!: BaseQueryDefinition[] | undefined;
    must_not!: BaseQueryDefinition[] | undefined;
    should!: BaseQueryDefinition[] | undefined;
    filter!: BaseQueryDefinition[] | undefined;
    min_should_match!: number | undefined;

    constructor(data?: IYSLogQueryObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.default_query = _data["default_query"];
            this.default_date_range = _data["default_date_range"] ? DateRangeQueryDefinition.fromJS(_data["default_date_range"]) : <any>undefined;
            if (Array.isArray(_data["must"])) {
                this.must = [] as any;
                for (let item of _data["must"])
                    this.must!.push(BaseQueryDefinition.fromJS(item));
            }
            if (Array.isArray(_data["must_not"])) {
                this.must_not = [] as any;
                for (let item of _data["must_not"])
                    this.must_not!.push(BaseQueryDefinition.fromJS(item));
            }
            if (Array.isArray(_data["should"])) {
                this.should = [] as any;
                for (let item of _data["should"])
                    this.should!.push(BaseQueryDefinition.fromJS(item));
            }
            if (Array.isArray(_data["filter"])) {
                this.filter = [] as any;
                for (let item of _data["filter"])
                    this.filter!.push(BaseQueryDefinition.fromJS(item));
            }
            this.min_should_match = _data["min_should_match"];
        }
    }

    static fromJS(data: any): YSLogQueryObject {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogQueryObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["default_query"] = this.default_query;
        data["default_date_range"] = this.default_date_range ? this.default_date_range.toJSON() : <any>undefined;
        if (Array.isArray(this.must)) {
            data["must"] = [];
            for (let item of this.must)
                data["must"].push(item.toJSON());
        }
        if (Array.isArray(this.must_not)) {
            data["must_not"] = [];
            for (let item of this.must_not)
                data["must_not"].push(item.toJSON());
        }
        if (Array.isArray(this.should)) {
            data["should"] = [];
            for (let item of this.should)
                data["should"].push(item.toJSON());
        }
        if (Array.isArray(this.filter)) {
            data["filter"] = [];
            for (let item of this.filter)
                data["filter"].push(item.toJSON());
        }
        data["min_should_match"] = this.min_should_match;
        return data; 
    }
}

/** 定义一个ES搜索/查询条件（request_body中"query"中的内容） 与Aggregation无关，与如何查询（sort order、from、to等）无关 */
export interface IYSLogQueryObject {
    /** 默认的查询条件，对应用户在search bar中输入的lucene查询语句，简化为普通字符串。 */
    default_query: string | undefined;
    default_date_range: DateRangeQueryDefinition;
    must: BaseQueryDefinition[] | undefined;
    must_not: BaseQueryDefinition[] | undefined;
    should: BaseQueryDefinition[] | undefined;
    filter: BaseQueryDefinition[] | undefined;
    min_should_match: number | undefined;
}

export enum YSLogSortOrder {
    Ascending = "Ascending",
    Desending = "Desending",
}

/** 编辑查询对象的Dto YSLog.WebManagement.DataExplore.Entities.YSLogSearchObject */
export class YSLogSearchObjectEditDto implements IYSLogSearchObjectEditDto {
    /** Id */
    id!: number | undefined;
    /** 最小长度为1，最大长度为20 */
    name!: string;
    /** 最大长度为200 */
    desc!: string | undefined;
    /** 关联的数据集Id */
    dataset_id!: number;
    query!: YSLogQueryObject;
    /** 排序字段（仅允许一个） */
    sort_by!: string | undefined;
    sort_by_order!: YSLogSortOrder;
    /** 数据条目开始的地方 */
    from!: number | undefined;
    /** 数据条目的数量 */
    size!: number | undefined;

    constructor(data?: IYSLogSearchObjectEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.desc = _data["desc"];
            this.dataset_id = _data["dataset_id"];
            this.query = _data["query"] ? YSLogQueryObject.fromJS(_data["query"]) : <any>undefined;
            this.sort_by = _data["sort_by"];
            this.sort_by_order = _data["sort_by_order"];
            this.from = _data["from"];
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): YSLogSearchObjectEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogSearchObjectEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["desc"] = this.desc;
        data["dataset_id"] = this.dataset_id;
        data["query"] = this.query ? this.query.toJSON() : <any>undefined;
        data["sort_by"] = this.sort_by;
        data["sort_by_order"] = this.sort_by_order;
        data["from"] = this.from;
        data["size"] = this.size;
        return data; 
    }
}

/** 编辑查询对象的Dto YSLog.WebManagement.DataExplore.Entities.YSLogSearchObject */
export interface IYSLogSearchObjectEditDto {
    /** Id */
    id: number | undefined;
    /** 最小长度为1，最大长度为20 */
    name: string;
    /** 最大长度为200 */
    desc: string | undefined;
    /** 关联的数据集Id */
    dataset_id: number;
    query: YSLogQueryObject;
    /** 排序字段（仅允许一个） */
    sort_by: string | undefined;
    sort_by_order: YSLogSortOrder;
    /** 数据条目开始的地方 */
    from: number | undefined;
    /** 数据条目的数量 */
    size: number | undefined;
}

/** 更新/创建查询对象的Dto */
export class CreateOrUpdateYSLogSearchObjectInput implements ICreateOrUpdateYSLogSearchObjectInput {
    ysLogSearchObject!: YSLogSearchObjectEditDto;

    constructor(data?: ICreateOrUpdateYSLogSearchObjectInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ysLogSearchObject = new YSLogSearchObjectEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ysLogSearchObject = _data["ysLogSearchObject"] ? YSLogSearchObjectEditDto.fromJS(_data["ysLogSearchObject"]) : new YSLogSearchObjectEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateYSLogSearchObjectInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateYSLogSearchObjectInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ysLogSearchObject"] = this.ysLogSearchObject ? this.ysLogSearchObject.toJSON() : <any>undefined;
        return data; 
    }
}

/** 更新/创建查询对象的Dto */
export interface ICreateOrUpdateYSLogSearchObjectInput {
    ysLogSearchObject: YSLogSearchObjectEditDto;
}

/** 获取所有查询对象的列表DTO YSLog.WebManagement.DataExplore.Entities.YSLogSearchObject */
export class YSLogSearchObjectListDto implements IYSLogSearchObjectListDto {
    /** 名称 */
    name!: string;
    /** 描述 */
    desc!: string | undefined;
    /** 关联的数据集Id */
    dataset_id!: number;
    /** 关联的数据集名称 */
    dataSetName!: string | undefined;
    query!: YSLogQueryObject;
    /** 排序字段 */
    sort_by!: string | undefined;
    sort_by_order!: YSLogSortOrder;
    /** 数据条目开始的地方 */
    from!: number | undefined;
    /** 数据条目的数量 */
    size!: number | undefined;
    id!: number;

    constructor(data?: IYSLogSearchObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.desc = _data["desc"];
            this.dataset_id = _data["dataset_id"];
            this.dataSetName = _data["dataSetName"];
            this.query = _data["query"] ? YSLogQueryObject.fromJS(_data["query"]) : <any>undefined;
            this.sort_by = _data["sort_by"];
            this.sort_by_order = _data["sort_by_order"];
            this.from = _data["from"];
            this.size = _data["size"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): YSLogSearchObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogSearchObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["desc"] = this.desc;
        data["dataset_id"] = this.dataset_id;
        data["dataSetName"] = this.dataSetName;
        data["query"] = this.query ? this.query.toJSON() : <any>undefined;
        data["sort_by"] = this.sort_by;
        data["sort_by_order"] = this.sort_by_order;
        data["from"] = this.from;
        data["size"] = this.size;
        data["id"] = this.id;
        return data; 
    }
}

/** 获取所有查询对象的列表DTO YSLog.WebManagement.DataExplore.Entities.YSLogSearchObject */
export interface IYSLogSearchObjectListDto {
    /** 名称 */
    name: string;
    /** 描述 */
    desc: string | undefined;
    /** 关联的数据集Id */
    dataset_id: number;
    /** 关联的数据集名称 */
    dataSetName: string | undefined;
    query: YSLogQueryObject;
    /** 排序字段 */
    sort_by: string | undefined;
    sort_by_order: YSLogSortOrder;
    /** 数据条目开始的地方 */
    from: number | undefined;
    /** 数据条目的数量 */
    size: number | undefined;
    id: number;
}

/** 编辑/创建查询对象的模板Dto */
export class GetYSLogSearchObjectForEditOutput implements IGetYSLogSearchObjectForEditOutput {
    ysLogSearchObject!: YSLogSearchObjectEditDto;

    constructor(data?: IGetYSLogSearchObjectForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ysLogSearchObject = _data["ysLogSearchObject"] ? YSLogSearchObjectEditDto.fromJS(_data["ysLogSearchObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetYSLogSearchObjectForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetYSLogSearchObjectForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ysLogSearchObject"] = this.ysLogSearchObject ? this.ysLogSearchObject.toJSON() : <any>undefined;
        return data; 
    }
}

/** 编辑/创建查询对象的模板Dto */
export interface IGetYSLogSearchObjectForEditOutput {
    ysLogSearchObject: YSLogSearchObjectEditDto;
}

export class PagedResultDtoOfYSLogSearchObjectListDto implements IPagedResultDtoOfYSLogSearchObjectListDto {
    totalCount!: number;
    items!: YSLogSearchObjectListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfYSLogSearchObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(YSLogSearchObjectListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfYSLogSearchObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfYSLogSearchObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfYSLogSearchObjectListDto {
    totalCount: number;
    items: YSLogSearchObjectListDto[] | undefined;
}

/** 表示返回给前端的，一个包含查询（query）结果的数据结构 由于查询的日志数据自身的结构不能确定，因此数据是以List<JObject>的形式返回的 */
export class YSLogQueryResult implements IYSLogQueryResult {
    /** 结果是否有效，如果false则表示结果不可用 */
    valid!: boolean;
    /** 符合筛选条件的记录数量。 */
    doc_count!: number;
    /** 查询执行的时间，单位毫秒 */
    took!: number;
    hits!: any[] | undefined;

    constructor(data?: IYSLogQueryResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.valid = _data["valid"];
            this.doc_count = _data["doc_count"];
            this.took = _data["took"];
            if (Array.isArray(_data["hits"])) {
                this.hits = [] as any;
                for (let item of _data["hits"])
                    this.hits!.push(item);
            }
        }
    }

    static fromJS(data: any): YSLogQueryResult {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogQueryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["valid"] = this.valid;
        data["doc_count"] = this.doc_count;
        data["took"] = this.took;
        if (Array.isArray(this.hits)) {
            data["hits"] = [];
            for (let item of this.hits)
                data["hits"].push(item);
        }
        return data; 
    }
}

/** 表示返回给前端的，一个包含查询（query）结果的数据结构 由于查询的日志数据自身的结构不能确定，因此数据是以List<JObject>的形式返回的 */
export interface IYSLogQueryResult {
    /** 结果是否有效，如果false则表示结果不可用 */
    valid: boolean;
    /** 符合筛选条件的记录数量。 */
    doc_count: number;
    /** 查询执行的时间，单位毫秒 */
    took: number;
    hits: any[] | undefined;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.defaultValue = _data["defaultValue"];
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        return data; 
    }
}

export interface IFlatFeatureDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class CurrentTenantLicenseEditDto implements ICurrentTenantLicenseEditDto {
    /** base64编码的授权文件 */
    base64EncodedLicenseData!: string;
    /** 是否根据授权文件中的联系信息重置当前租户的联系信息 */
    resetContactInfo!: boolean;

    constructor(data?: ICurrentTenantLicenseEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.base64EncodedLicenseData = _data["base64EncodedLicenseData"];
            this.resetContactInfo = _data["resetContactInfo"];
        }
    }

    static fromJS(data: any): CurrentTenantLicenseEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentTenantLicenseEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["base64EncodedLicenseData"] = this.base64EncodedLicenseData;
        data["resetContactInfo"] = this.resetContactInfo;
        return data; 
    }
}

export interface ICurrentTenantLicenseEditDto {
    /** base64编码的授权文件 */
    base64EncodedLicenseData: string;
    /** 是否根据授权文件中的联系信息重置当前租户的联系信息 */
    resetContactInfo: boolean;
}

export class CurrentTenantProfileEditDto implements ICurrentTenantProfileEditDto {
    /** 租户的显示名称 */
    name!: string | undefined;
    contactInfo!: ContactInfo;
    id!: number;

    constructor(data?: ICurrentTenantProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.contactInfo = _data["contactInfo"] ? ContactInfo.fromJS(_data["contactInfo"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CurrentTenantProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentTenantProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["contactInfo"] = this.contactInfo ? this.contactInfo.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICurrentTenantProfileEditDto {
    /** 租户的显示名称 */
    name: string | undefined;
    contactInfo: ContactInfo;
    id: number;
}

/** 修改语言 */
export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName!: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }
}

/** 修改语言 */
export interface IChangeUserLanguageDto {
    languageName: string;
}

/** 修改密码 */
export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword!: string;
    newPassword!: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }
}

/** 修改密码 */
export interface IChangePasswordInput {
    currentPassword: string;
    newPassword: string;
}

/** 当前用户信息 */
export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    userName!: string;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    userMemo!: string | undefined;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.userMemo = _data["userMemo"];
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["userMemo"] = this.userMemo;
        return data; 
    }
}

/** 当前用户信息 */
export interface ICurrentUserProfileEditDto {
    userName: string;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    userMemo: string | undefined;
}

/** 编辑用户信息的Dto */
export class UserEditDto implements IUserEditDto {
    /** 根据id是否有值来判断是创建还是添加 */
    id!: number | undefined;
    userName!: string;
    /** 用户备注 */
    userMemo!: string | undefined;
    emailAddress!: string;
    phoneNumber!: string;
    /** 密码字段的必填限制请根据具体操作设定：创建-必填、编辑-可选 */
    password!: string | undefined;
    /** 所授权角色名称 */
    assignedRoleId!: number;
    /** 是否开启该用户连续登录失败超过五次被锁定的属性 */
    isLockoutEnabled!: boolean;
    /** 下次登录是否需要修改密码 */
    needToChangeThePassword!: boolean;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.userMemo = _data["userMemo"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
            this.assignedRoleId = _data["assignedRoleId"];
            this.isLockoutEnabled = _data["isLockoutEnabled"];
            this.needToChangeThePassword = _data["needToChangeThePassword"];
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["userMemo"] = this.userMemo;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["assignedRoleId"] = this.assignedRoleId;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["needToChangeThePassword"] = this.needToChangeThePassword;
        return data; 
    }
}

/** 编辑用户信息的Dto */
export interface IUserEditDto {
    /** 根据id是否有值来判断是创建还是添加 */
    id: number | undefined;
    userName: string;
    /** 用户备注 */
    userMemo: string | undefined;
    emailAddress: string;
    phoneNumber: string;
    /** 密码字段的必填限制请根据具体操作设定：创建-必填、编辑-可选 */
    password: string | undefined;
    /** 所授权角色名称 */
    assignedRoleId: number;
    /** 是否开启该用户连续登录失败超过五次被锁定的属性 */
    isLockoutEnabled: boolean;
    /** 下次登录是否需要修改密码 */
    needToChangeThePassword: boolean;
}

/** 创建/编辑用户的Dto */
export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    user!: UserEditDto;

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserEditDto.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

/** 创建/编辑用户的Dto */
export interface ICreateOrUpdateUserInput {
    user: UserEditDto;
}

/** 用户角色 */
export class UserRoleDto implements IUserRoleDto {
    roleId!: number;
    roleName!: string | undefined;
    roleDisplayName!: string | undefined;
    isAssigned!: boolean;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            this.roleDisplayName = _data["roleDisplayName"];
            this.isAssigned = _data["isAssigned"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        return data; 
    }
}

/** 用户角色 */
export interface IUserRoleDto {
    roleId: number;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean;
}

/** 创建/编辑用户的模板Dto */
export class GetUserForEditTreeOutput implements IGetUserForEditTreeOutput {
    user!: UserEditDto;
    roles!: UserRoleDto[] | undefined;

    constructor(data?: IGetUserForEditTreeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserEditDto.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UserRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserForEditTreeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditTreeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data; 
    }
}

/** 创建/编辑用户的模板Dto */
export interface IGetUserForEditTreeOutput {
    user: UserEditDto;
    roles: UserRoleDto[] | undefined;
}

/** 用户角色列表 */
export class UserListRoleDto implements IUserListRoleDto {
    roleId!: number;
    roleName!: string | undefined;
    roleDisplayName!: string | undefined;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            this.roleDisplayName = _data["roleDisplayName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        return data; 
    }
}

/** 用户角色列表 */
export interface IUserListRoleDto {
    roleId: number;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
}

/** 用户信息列表的Dto YSLog.WebManagement.Users.User */
export class UserListDto implements IUserListDto {
    userName!: string | undefined;
    /** 用户备注 */
    userMemo!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    lastLoginTime!: moment.Moment | undefined;
    creationTime!: moment.Moment;
    /** 用户是否被锁定 */
    isLocked!: boolean;
    role!: UserListRoleDto;
    id!: number;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.userMemo = _data["userMemo"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.lastLoginTime = _data["lastLoginTime"] ? moment(_data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.isLocked = _data["isLocked"];
            this.role = _data["role"] ? UserListRoleDto.fromJS(_data["role"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["userMemo"] = this.userMemo;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["isLocked"] = this.isLocked;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

/** 用户信息列表的Dto YSLog.WebManagement.Users.User */
export interface IUserListDto {
    userName: string | undefined;
    /** 用户备注 */
    userMemo: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    /** 用户是否被锁定 */
    isLocked: boolean;
    role: UserListRoleDto;
    id: number;
}

export class PagedResultDtoOfUserListDto implements IPagedResultDtoOfUserListDto {
    totalCount!: number;
    items!: UserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserListDto {
    totalCount: number;
    items: UserListDto[] | undefined;
}

/** 创建/编辑用户的模板Dto */
export class GetUserForEditOutput implements IGetUserForEditOutput {
    user!: UserEditDto;
    roles!: UserRoleDto[] | undefined;

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserEditDto.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UserRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data; 
    }
}

/** 创建/编辑用户的模板Dto */
export interface IGetUserForEditOutput {
    user: UserEditDto;
    roles: UserRoleDto[] | undefined;
}

/** 这里注册了所有MetricAggregation的类型 */
export class BaseMetricAggregationDefinition implements IBaseMetricAggregationDefinition {
    name!: string;
    label!: string | undefined;

    protected _discriminator: string;

    constructor(data?: IBaseMetricAggregationDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "BaseMetricAggregationDefinition";
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): BaseMetricAggregationDefinition {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "avg") {
            let result = new AverageAggregationDefinition();
            result.init(data);
            return result;
        }
        if (data["type"] === "cardinal") {
            let result = new CardinalityAggregationDefinition();
            result.init(data);
            return result;
        }
        if (data["type"] === "count") {
            let result = new CountAggregationDefinition();
            result.init(data);
            return result;
        }
        if (data["type"] === "ext_stats") {
            let result = new ExtendedStatsAggregationDefinition();
            result.init(data);
            return result;
        }
        if (data["type"] === "max") {
            let result = new MaxAggregationDefinition();
            result.init(data);
            return result;
        }
        if (data["type"] === "med_abs_dev") {
            let result = new MedianAbsoluteDeviationAggregationDefinition();
            result.init(data);
            return result;
        }
        if (data["type"] === "min") {
            let result = new MinAggregationDefinition();
            result.init(data);
            return result;
        }
        if (data["type"] === "percentile_ranks") {
            let result = new PercentileRanksAggregationDefinition();
            result.init(data);
            return result;
        }
        if (data["type"] === "percentiles") {
            let result = new PercentilesAggregationDefinition();
            result.init(data);
            return result;
        }
        if (data["type"] === "scripted_metric") {
            let result = new ScriptedMetricAggregationDefinition();
            result.init(data);
            return result;
        }
        if (data["type"] === "stats") {
            let result = new StatsAggregationDefinition();
            result.init(data);
            return result;
        }
        if (data["type"] === "sum") {
            let result = new SumAggregationDefinition();
            result.init(data);
            return result;
        }
        let result = new BaseMetricAggregationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this._discriminator; 
        data["name"] = this.name;
        data["label"] = this.label;
        return data; 
    }
}

/** 这里注册了所有MetricAggregation的类型 */
export interface IBaseMetricAggregationDefinition {
    name: string;
    label: string | undefined;
}

/** 这里注册了所有BucketAggregation */
export class BaseBucketAggregationDefinition implements IBaseBucketAggregationDefinition {
    name!: string;
    label!: string | undefined;

    protected _discriminator: string;

    constructor(data?: IBaseBucketAggregationDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "BaseBucketAggregationDefinition";
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): BaseBucketAggregationDefinition {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "date_histogram") {
            let result = new DateHistogramAggregationDefinition();
            result.init(data);
            return result;
        }
        if (data["type"] === "filters") {
            let result = new FiltersAggregationDefinition();
            result.init(data);
            return result;
        }
        if (data["type"] === "histogram") {
            let result = new HistogramAggregationDefinition();
            result.init(data);
            return result;
        }
        if (data["type"] === "ip_range") {
            let result = new IpRangeAggregationDefinition();
            result.init(data);
            return result;
        }
        if (data["type"] === "numeric_range") {
            let result = new RangeAggregationDefinition();
            result.init(data);
            return result;
        }
        if (data["type"] === "terms") {
            let result = new TermsAggregationDefinition();
            result.init(data);
            return result;
        }
        let result = new BaseBucketAggregationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this._discriminator; 
        data["name"] = this.name;
        data["label"] = this.label;
        return data; 
    }
}

/** 这里注册了所有BucketAggregation */
export interface IBaseBucketAggregationDefinition {
    name: string;
    label: string | undefined;
}

/** 定义一个ES聚类/分类统计组合（request_body中“aggs”中的内容） 与Query无关，与如何查询（sort order、from、to等）无关 */
export class YSLogAggregationObject implements IYSLogAggregationObject {
    /** 可以为空，视作包含一个CountAggregationDefinition("_count")，即只会对每个桶进行文档计数（doc_count）
若其中包含CountAggregationDefinition的定义，在构造Aggregation时会直接跳过（不需要添加任何agg）
但在处理结果时，会提取最内侧桶的doc_count并填入对应的name/label字段中。
如果MetricAggregations和BucketAggregations都为空，则Bucket和Metric的表头和内容也全部为空，前端应当展示TotalDocCount */
    metrics!: BaseMetricAggregationDefinition[] | undefined;
    /** 可以为空，视作不分桶，直接对符合Query条件的所有doc进行指标统计。
在处理结果时，Bucket相关的的表头和内容全部为空。
如果MetricAggregations和BucketAggregations都为空，则Bucket和Metric的表头和内容也全部为空，前端应当展示TotalDocCount */
    buckets!: BaseBucketAggregationDefinition[] | undefined;

    constructor(data?: IYSLogAggregationObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["metrics"])) {
                this.metrics = [] as any;
                for (let item of _data["metrics"])
                    this.metrics!.push(BaseMetricAggregationDefinition.fromJS(item));
            }
            if (Array.isArray(_data["buckets"])) {
                this.buckets = [] as any;
                for (let item of _data["buckets"])
                    this.buckets!.push(BaseBucketAggregationDefinition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): YSLogAggregationObject {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogAggregationObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.metrics)) {
            data["metrics"] = [];
            for (let item of this.metrics)
                data["metrics"].push(item.toJSON());
        }
        if (Array.isArray(this.buckets)) {
            data["buckets"] = [];
            for (let item of this.buckets)
                data["buckets"].push(item.toJSON());
        }
        return data; 
    }
}

/** 定义一个ES聚类/分类统计组合（request_body中“aggs”中的内容） 与Query无关，与如何查询（sort order、from、to等）无关 */
export interface IYSLogAggregationObject {
    /** 可以为空，视作包含一个CountAggregationDefinition("_count")，即只会对每个桶进行文档计数（doc_count）
若其中包含CountAggregationDefinition的定义，在构造Aggregation时会直接跳过（不需要添加任何agg）
但在处理结果时，会提取最内侧桶的doc_count并填入对应的name/label字段中。
如果MetricAggregations和BucketAggregations都为空，则Bucket和Metric的表头和内容也全部为空，前端应当展示TotalDocCount */
    metrics: BaseMetricAggregationDefinition[] | undefined;
    /** 可以为空，视作不分桶，直接对符合Query条件的所有doc进行指标统计。
在处理结果时，Bucket相关的的表头和内容全部为空。
如果MetricAggregations和BucketAggregations都为空，则Bucket和Metric的表头和内容也全部为空，前端应当展示TotalDocCount */
    buckets: BaseBucketAggregationDefinition[] | undefined;
}

/** 编辑可视化对象的Dto YSLog.WebManagement.DataVisualize.Entities.YSLogVisualizeObject */
export class YSLogVisualizeObjectEditDto implements IYSLogVisualizeObjectEditDto {
    /** Id */
    id!: number | undefined;
    /** 最小长度为5，最大长度为20 */
    name!: string;
    /** 描述 */
    desc!: string | undefined;
    /** 关联的数据集Id */
    dataset_id!: number;
    query!: YSLogQueryObject;
    aggregation!: YSLogAggregationObject;
    /** 图表类型 */
    chart_type!: string | undefined;
    /** 与图表相关的配置，Dictionary/hash形式 */
    chart_opts!: { [key: string]: string; } | undefined;

    constructor(data?: IYSLogVisualizeObjectEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.desc = _data["desc"];
            this.dataset_id = _data["dataset_id"];
            this.query = _data["query"] ? YSLogQueryObject.fromJS(_data["query"]) : <any>undefined;
            this.aggregation = _data["aggregation"] ? YSLogAggregationObject.fromJS(_data["aggregation"]) : <any>undefined;
            this.chart_type = _data["chart_type"];
            if (_data["chart_opts"]) {
                this.chart_opts = {} as any;
                for (let key in _data["chart_opts"]) {
                    if (_data["chart_opts"].hasOwnProperty(key))
                        this.chart_opts![key] = _data["chart_opts"][key];
                }
            }
        }
    }

    static fromJS(data: any): YSLogVisualizeObjectEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogVisualizeObjectEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["desc"] = this.desc;
        data["dataset_id"] = this.dataset_id;
        data["query"] = this.query ? this.query.toJSON() : <any>undefined;
        data["aggregation"] = this.aggregation ? this.aggregation.toJSON() : <any>undefined;
        data["chart_type"] = this.chart_type;
        if (this.chart_opts) {
            data["chart_opts"] = {};
            for (let key in this.chart_opts) {
                if (this.chart_opts.hasOwnProperty(key))
                    data["chart_opts"][key] = this.chart_opts[key];
            }
        }
        return data; 
    }
}

/** 编辑可视化对象的Dto YSLog.WebManagement.DataVisualize.Entities.YSLogVisualizeObject */
export interface IYSLogVisualizeObjectEditDto {
    /** Id */
    id: number | undefined;
    /** 最小长度为5，最大长度为20 */
    name: string;
    /** 描述 */
    desc: string | undefined;
    /** 关联的数据集Id */
    dataset_id: number;
    query: YSLogQueryObject;
    aggregation: YSLogAggregationObject;
    /** 图表类型 */
    chart_type: string | undefined;
    /** 与图表相关的配置，Dictionary/hash形式 */
    chart_opts: { [key: string]: string; } | undefined;
}

/** 创建/更新可视化对象的Dto */
export class CreateOrUpdateYSLogVisualizeObjectInput implements ICreateOrUpdateYSLogVisualizeObjectInput {
    visualize!: YSLogVisualizeObjectEditDto;

    constructor(data?: ICreateOrUpdateYSLogVisualizeObjectInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.visualize = new YSLogVisualizeObjectEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.visualize = _data["visualize"] ? YSLogVisualizeObjectEditDto.fromJS(_data["visualize"]) : new YSLogVisualizeObjectEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateYSLogVisualizeObjectInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateYSLogVisualizeObjectInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["visualize"] = this.visualize ? this.visualize.toJSON() : <any>undefined;
        return data; 
    }
}

/** 创建/更新可视化对象的Dto */
export interface ICreateOrUpdateYSLogVisualizeObjectInput {
    visualize: YSLogVisualizeObjectEditDto;
}

/** 可视化对象列表Dto YSLog.WebManagement.DataVisualize.Entities.YSLogVisualizeObject */
export class YSLogVisualizeObjectListDto implements IYSLogVisualizeObjectListDto {
    /** 名称 */
    name!: string;
    /** 描述 */
    desc!: string | undefined;
    /** 关联的数据集Id */
    dataset_id!: number;
    /** 关联的数据集名称 */
    dataset_name!: string | undefined;
    query!: YSLogQueryObject;
    aggregation!: YSLogAggregationObject;
    /** 图表类型 */
    chart_type!: string | undefined;
    /** 图表配置 */
    chart_opts!: { [key: string]: string; } | undefined;
    id!: number;

    constructor(data?: IYSLogVisualizeObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.desc = _data["desc"];
            this.dataset_id = _data["dataset_id"];
            this.dataset_name = _data["dataset_name"];
            this.query = _data["query"] ? YSLogQueryObject.fromJS(_data["query"]) : <any>undefined;
            this.aggregation = _data["aggregation"] ? YSLogAggregationObject.fromJS(_data["aggregation"]) : <any>undefined;
            this.chart_type = _data["chart_type"];
            if (_data["chart_opts"]) {
                this.chart_opts = {} as any;
                for (let key in _data["chart_opts"]) {
                    if (_data["chart_opts"].hasOwnProperty(key))
                        this.chart_opts![key] = _data["chart_opts"][key];
                }
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): YSLogVisualizeObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogVisualizeObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["desc"] = this.desc;
        data["dataset_id"] = this.dataset_id;
        data["dataset_name"] = this.dataset_name;
        data["query"] = this.query ? this.query.toJSON() : <any>undefined;
        data["aggregation"] = this.aggregation ? this.aggregation.toJSON() : <any>undefined;
        data["chart_type"] = this.chart_type;
        if (this.chart_opts) {
            data["chart_opts"] = {};
            for (let key in this.chart_opts) {
                if (this.chart_opts.hasOwnProperty(key))
                    data["chart_opts"][key] = this.chart_opts[key];
            }
        }
        data["id"] = this.id;
        return data; 
    }
}

/** 可视化对象列表Dto YSLog.WebManagement.DataVisualize.Entities.YSLogVisualizeObject */
export interface IYSLogVisualizeObjectListDto {
    /** 名称 */
    name: string;
    /** 描述 */
    desc: string | undefined;
    /** 关联的数据集Id */
    dataset_id: number;
    /** 关联的数据集名称 */
    dataset_name: string | undefined;
    query: YSLogQueryObject;
    aggregation: YSLogAggregationObject;
    /** 图表类型 */
    chart_type: string | undefined;
    /** 图表配置 */
    chart_opts: { [key: string]: string; } | undefined;
    id: number;
}

/** 读取编辑/创建可视化对象的模板Dto */
export class GetYSLogVisualizeObjectForEditOutput implements IGetYSLogVisualizeObjectForEditOutput {
    visualize!: YSLogVisualizeObjectEditDto;

    constructor(data?: IGetYSLogVisualizeObjectForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.visualize = _data["visualize"] ? YSLogVisualizeObjectEditDto.fromJS(_data["visualize"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetYSLogVisualizeObjectForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetYSLogVisualizeObjectForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["visualize"] = this.visualize ? this.visualize.toJSON() : <any>undefined;
        return data; 
    }
}

/** 读取编辑/创建可视化对象的模板Dto */
export interface IGetYSLogVisualizeObjectForEditOutput {
    visualize: YSLogVisualizeObjectEditDto;
}

export class PagedResultDtoOfYSLogVisualizeObjectListDto implements IPagedResultDtoOfYSLogVisualizeObjectListDto {
    totalCount!: number;
    items!: YSLogVisualizeObjectListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfYSLogVisualizeObjectListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(YSLogVisualizeObjectListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfYSLogVisualizeObjectListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfYSLogVisualizeObjectListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfYSLogVisualizeObjectListDto {
    totalCount: number;
    items: YSLogVisualizeObjectListDto[] | undefined;
}

/** Aggregation结果中的一部分， 表示由BucketAggregation的定义组成的表头（标题行）部分 每个BucketAggregation一个 */
export class BucketHeader implements IBucketHeader {
    /** 当前BucketAggregation的Name（不会包含.） */
    name!: string | undefined;
    /** 当前BucketAggregation的Label，完全自定义 */
    label!: string | undefined;

    constructor(data?: IBucketHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): BucketHeader {
        data = typeof data === 'object' ? data : {};
        let result = new BucketHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["label"] = this.label;
        return data; 
    }
}

/** Aggregation结果中的一部分， 表示由BucketAggregation的定义组成的表头（标题行）部分 每个BucketAggregation一个 */
export interface IBucketHeader {
    /** 当前BucketAggregation的Name（不会包含.） */
    name: string | undefined;
    /** 当前BucketAggregation的Label，完全自定义 */
    label: string | undefined;
}

/** Aggregation结果中的一部分， 表示由MetricAggregation的定义组成的表头（标题行）部分 由于部分MetricAggregation会生成多列数据（如ExtendedStats、Percentile和PercentileRank） 因此这些列名记录在SubKeys中。对于单列的Aggregation，SubKeys为Null */
export class MetricHeader implements IMetricHeader {
    /** 当前MetricAggregation的Name（不会包含.）
Name（必有）与SubKeys（可能有）共同组成了MetricData的中的Key（以“Name.SubKey”的形式） */
    name!: string | undefined;
    /** 当前MetricAggregation的Label，完全自定义 */
    label!: string | undefined;
    /** 当前MetricAggregation可能包含的次一级Key名称
可能为空，表示没有次一级Key
Name（必有）与SubKeys（可能有）共同组成了MetricData的中的Key（以“Name.SubKey”的形式） */
    subkeys!: string[] | undefined;

    constructor(data?: IMetricHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.label = _data["label"];
            if (Array.isArray(_data["subkeys"])) {
                this.subkeys = [] as any;
                for (let item of _data["subkeys"])
                    this.subkeys!.push(item);
            }
        }
    }

    static fromJS(data: any): MetricHeader {
        data = typeof data === 'object' ? data : {};
        let result = new MetricHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["label"] = this.label;
        if (Array.isArray(this.subkeys)) {
            data["subkeys"] = [];
            for (let item of this.subkeys)
                data["subkeys"].push(item);
        }
        return data; 
    }
}

/** Aggregation结果中的一部分， 表示由MetricAggregation的定义组成的表头（标题行）部分 由于部分MetricAggregation会生成多列数据（如ExtendedStats、Percentile和PercentileRank） 因此这些列名记录在SubKeys中。对于单列的Aggregation，SubKeys为Null */
export interface IMetricHeader {
    /** 当前MetricAggregation的Name（不会包含.）
Name（必有）与SubKeys（可能有）共同组成了MetricData的中的Key（以“Name.SubKey”的形式） */
    name: string | undefined;
    /** 当前MetricAggregation的Label，完全自定义 */
    label: string | undefined;
    /** 当前MetricAggregation可能包含的次一级Key名称
可能为空，表示没有次一级Key
Name（必有）与SubKeys（可能有）共同组成了MetricData的中的Key（以“Name.SubKey”的形式） */
    subkeys: string[] | undefined;
}

/** 标题行的内部结构 */
export class YSLogAggregationHeaders implements IYSLogAggregationHeaders {
    /** 由BucketAggregation生成的标题，
数量/顺序对应YSLogAggregationDefinition中的BucketAggregations
顺序1到n对应最外层agg到最内层agg */
    bucket!: BucketHeader[] | undefined;
    /** 由BucketAggregation生成的标题，
数量/顺序对应YSLogAggregationDefinition中的MetricAggregations */
    metric!: MetricHeader[] | undefined;

    constructor(data?: IYSLogAggregationHeaders) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bucket"])) {
                this.bucket = [] as any;
                for (let item of _data["bucket"])
                    this.bucket!.push(BucketHeader.fromJS(item));
            }
            if (Array.isArray(_data["metric"])) {
                this.metric = [] as any;
                for (let item of _data["metric"])
                    this.metric!.push(MetricHeader.fromJS(item));
            }
        }
    }

    static fromJS(data: any): YSLogAggregationHeaders {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogAggregationHeaders();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bucket)) {
            data["bucket"] = [];
            for (let item of this.bucket)
                data["bucket"].push(item.toJSON());
        }
        if (Array.isArray(this.metric)) {
            data["metric"] = [];
            for (let item of this.metric)
                data["metric"].push(item.toJSON());
        }
        return data; 
    }
}

/** 标题行的内部结构 */
export interface IYSLogAggregationHeaders {
    /** 由BucketAggregation生成的标题，
数量/顺序对应YSLogAggregationDefinition中的BucketAggregations
顺序1到n对应最外层agg到最内层agg */
    bucket: BucketHeader[] | undefined;
    /** 由BucketAggregation生成的标题，
数量/顺序对应YSLogAggregationDefinition中的MetricAggregations */
    metric: MetricHeader[] | undefined;
}

/** 表示每一个分类数据字段 */
export class BucketData implements IBucketData {
    /** 考虑到诸如DateHistogram等BucketAggregation会以数字形式提供key,这种数字形式的前端也会需要使用，因此使用key表示这类情况。
此外Range和IpRange这两个Aggregation会有from/to字段。因此以JObject的形式，提供结构化的、更精确的数据给前端使用，帮助前端
更好的将数据展示给用户。
如果Aggregate结果中对应的Key或者相关信息为null，则key也为null，KeyAsString为空字符串“” */
    key!: any | undefined;
    /** “安全的”/必定会有的，以string形式提供的分类标识符。具体内容受BucketAggregation定义和实际数据内容决定，不完全可控。 */
    key_as_string!: string | undefined;

    constructor(data?: IBucketData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.key_as_string = _data["key_as_string"];
        }
    }

    static fromJS(data: any): BucketData {
        data = typeof data === 'object' ? data : {};
        let result = new BucketData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["key_as_string"] = this.key_as_string;
        return data; 
    }
}

/** 表示每一个分类数据字段 */
export interface IBucketData {
    /** 考虑到诸如DateHistogram等BucketAggregation会以数字形式提供key,这种数字形式的前端也会需要使用，因此使用key表示这类情况。
此外Range和IpRange这两个Aggregation会有from/to字段。因此以JObject的形式，提供结构化的、更精确的数据给前端使用，帮助前端
更好的将数据展示给用户。
如果Aggregate结果中对应的Key或者相关信息为null，则key也为null，KeyAsString为空字符串“” */
    key: any | undefined;
    /** “安全的”/必定会有的，以string形式提供的分类标识符。具体内容受BucketAggregation定义和实际数据内容决定，不完全可控。 */
    key_as_string: string | undefined;
}

export class MetricData implements IMetricData {
    /** 与BucketData类似，value表示结构化/更精确的统计结果。前端应当根据Aggregation的类型来分别处理。
如果Aggregate结果中Value为null，则这里的Value也为null，同时ValueAsString为空字符串“” */
    value!: any | undefined;
    /** “安全的”/必定会有的，以string形式提供的统计结果。具体内容受MetricAggregation定义和实际数据内容决定，不完全可控。 */
    value_as_string!: string | undefined;

    constructor(data?: IMetricData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.value_as_string = _data["value_as_string"];
        }
    }

    static fromJS(data: any): MetricData {
        data = typeof data === 'object' ? data : {};
        let result = new MetricData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["value_as_string"] = this.value_as_string;
        return data; 
    }
}

export interface IMetricData {
    /** 与BucketData类似，value表示结构化/更精确的统计结果。前端应当根据Aggregation的类型来分别处理。
如果Aggregate结果中Value为null，则这里的Value也为null，同时ValueAsString为空字符串“” */
    value: any | undefined;
    /** “安全的”/必定会有的，以string形式提供的统计结果。具体内容受MetricAggregation定义和实际数据内容决定，不完全可控。 */
    value_as_string: string | undefined;
}

/** 数据行的内部结构 */
export class YSLogAggregationDataRow implements IYSLogAggregationDataRow {
    /** 由BucketAggregation形成的分类标识，或者说Bucket的Name/Key
key-value形式存储，每个key对应BucketAggregation的Name（非Label） */
    bucket!: { [key: string]: BucketData; } | undefined;
    /** 由MetricAggregation形成的统计结果表支，或者说Metric的Name/Key
key-value形式存储，每个key对应MetricAggregation的Name（非Label）
<remarks>
由于某些MetricAggregation可以获得多个统计结果，如ExtendedStats和PercentileRanks等，
因此对于这些MetricAggregation的统计结果，也需要多组key-value来存放。此时，key的名字
约定为 “Name”+“.”+“SubKey”，这也是为什么Name中不允许出现“.”。前端可以根据
第一个“.”来切分。SubKey通常是“安全的”（不含“.”），但并不完全可控。
</remarks> */
    metric!: { [key: string]: MetricData; } | undefined;

    constructor(data?: IYSLogAggregationDataRow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["bucket"]) {
                this.bucket = {} as any;
                for (let key in _data["bucket"]) {
                    if (_data["bucket"].hasOwnProperty(key))
                        this.bucket![key] = _data["bucket"][key] ? BucketData.fromJS(_data["bucket"][key]) : new BucketData();
                }
            }
            if (_data["metric"]) {
                this.metric = {} as any;
                for (let key in _data["metric"]) {
                    if (_data["metric"].hasOwnProperty(key))
                        this.metric![key] = _data["metric"][key] ? MetricData.fromJS(_data["metric"][key]) : new MetricData();
                }
            }
        }
    }

    static fromJS(data: any): YSLogAggregationDataRow {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogAggregationDataRow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.bucket) {
            data["bucket"] = {};
            for (let key in this.bucket) {
                if (this.bucket.hasOwnProperty(key))
                    data["bucket"][key] = this.bucket[key] ? this.bucket[key].toJSON() : <any>undefined;
            }
        }
        if (this.metric) {
            data["metric"] = {};
            for (let key in this.metric) {
                if (this.metric.hasOwnProperty(key))
                    data["metric"][key] = this.metric[key] ? this.metric[key].toJSON() : <any>undefined;
            }
        }
        return data; 
    }
}

/** 数据行的内部结构 */
export interface IYSLogAggregationDataRow {
    /** 由BucketAggregation形成的分类标识，或者说Bucket的Name/Key
key-value形式存储，每个key对应BucketAggregation的Name（非Label） */
    bucket: { [key: string]: BucketData; } | undefined;
    /** 由MetricAggregation形成的统计结果表支，或者说Metric的Name/Key
key-value形式存储，每个key对应MetricAggregation的Name（非Label）
<remarks>
由于某些MetricAggregation可以获得多个统计结果，如ExtendedStats和PercentileRanks等，
因此对于这些MetricAggregation的统计结果，也需要多组key-value来存放。此时，key的名字
约定为 “Name”+“.”+“SubKey”，这也是为什么Name中不允许出现“.”。前端可以根据
第一个“.”来切分。SubKey通常是“安全的”（不含“.”），但并不完全可控。
</remarks> */
    metric: { [key: string]: MetricData; } | undefined;
}

/** 表示返回给前端的，一个包含分类统计（aggregation）结果的复杂数据结构 前端可以以此为基础做进一步的区分/映射，以满足其构建图表的需求 */
export class YSLogAggregationResult implements IYSLogAggregationResult {
    /** 结果是否有效，如果false则表示结果不可用 */
    valid!: boolean;
    /** 符合筛选条件的记录数量。
虽然分类统计结果中不会包含符合查询条件的记录，
但考虑到整个Aggregation可能都为空（Bucket和Metric都空），
此时前端能够显示的就只有这个“总数”了。 */
    doc_count!: number;
    /** 查询执行的时间，单位毫秒 */
    took!: number;
    headers!: YSLogAggregationHeaders;
    /** 数据行信息
内容主体部分（包含分类名/对应Bucket和统计结果/对应Metric） */
    rows!: YSLogAggregationDataRow[] | undefined;

    constructor(data?: IYSLogAggregationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.valid = _data["valid"];
            this.doc_count = _data["doc_count"];
            this.took = _data["took"];
            this.headers = _data["headers"] ? YSLogAggregationHeaders.fromJS(_data["headers"]) : <any>undefined;
            if (Array.isArray(_data["rows"])) {
                this.rows = [] as any;
                for (let item of _data["rows"])
                    this.rows!.push(YSLogAggregationDataRow.fromJS(item));
            }
        }
    }

    static fromJS(data: any): YSLogAggregationResult {
        data = typeof data === 'object' ? data : {};
        let result = new YSLogAggregationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["valid"] = this.valid;
        data["doc_count"] = this.doc_count;
        data["took"] = this.took;
        data["headers"] = this.headers ? this.headers.toJSON() : <any>undefined;
        if (Array.isArray(this.rows)) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item.toJSON());
        }
        return data; 
    }
}

/** 表示返回给前端的，一个包含分类统计（aggregation）结果的复杂数据结构 前端可以以此为基础做进一步的区分/映射，以满足其构建图表的需求 */
export interface IYSLogAggregationResult {
    /** 结果是否有效，如果false则表示结果不可用 */
    valid: boolean;
    /** 符合筛选条件的记录数量。
虽然分类统计结果中不会包含符合查询条件的记录，
但考虑到整个Aggregation可能都为空（Bucket和Metric都空），
此时前端能够显示的就只有这个“总数”了。 */
    doc_count: number;
    /** 查询执行的时间，单位毫秒 */
    took: number;
    headers: YSLogAggregationHeaders;
    /** 数据行信息
内容主体部分（包含分类名/对应Bucket和统计结果/对应Metric） */
    rows: YSLogAggregationDataRow[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress!: string;
    password!: string;
    /** 验证码 */
    verificationCode!: string | undefined;
    rememberClient!: boolean | undefined;
    returnUrl!: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.verificationCode = _data["verificationCode"];
            this.rememberClient = _data["rememberClient"];
            this.returnUrl = _data["returnUrl"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["verificationCode"] = this.verificationCode;
        data["rememberClient"] = this.rememberClient;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    /** 验证码 */
    verificationCode: string | undefined;
    rememberClient: boolean | undefined;
    returnUrl: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    userId!: number;
    needToChangeThePassword!: boolean;
    returnUrl!: string | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
            this.needToChangeThePassword = _data["needToChangeThePassword"];
            this.returnUrl = _data["returnUrl"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        data["needToChangeThePassword"] = this.needToChangeThePassword;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
    needToChangeThePassword: boolean;
    returnUrl: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider!: string;
    providerKey!: string;
    providerAccessCode!: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data; 
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    waitingForActivation!: boolean;
    userId!: number;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
    userId: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name!: string | undefined;
    clientId!: string | undefined;
    additionalParams!: { [key: string]: string; } | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
            if (_data["additionalParams"]) {
                this.additionalParams = {} as any;
                for (let key in _data["additionalParams"]) {
                    if (_data["additionalParams"].hasOwnProperty(key))
                        this.additionalParams![key] = _data["additionalParams"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        if (this.additionalParams) {
            data["additionalParams"] = {};
            for (let key in this.additionalParams) {
                if (this.additionalParams.hasOwnProperty(key))
                    data["additionalParams"][key] = this.additionalParams[key];
            }
        }
        return data; 
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
    additionalParams: { [key: string]: string; } | undefined;
}

/** 图形验证码类型 */
export enum CaptchaType {
    Default = "Default",
    HostTenantRegister = "HostTenantRegister",
    HostUserLogin = "HostUserLogin",
    TenantUserRegister = "TenantUserRegister",
    TenantUserLogin = "TenantUserLogin",
    TenantUserRegisterActiveEmail = "TenantUserRegisterActiveEmail",
    TenantUserForotPassword = "TenantUserForotPassword",
    TenantUserResetPassword = "TenantUserResetPassword",
}

/** 以某个字段是否存在为条件进行查询 */
export class ExistsQueryDefinition extends BaseQueryDefinition implements IExistsQueryDefinition {
    readonly type!: string;
    /** 检查的对象字段名，必填 */
    field!: string;

    constructor(data?: IExistsQueryDefinition) {
        super(data);
        if (!data) {
            this.type = "exists";
        }
        this._discriminator = "ExistsQueryDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "exists";
            this.field = _data["field"];
        }
    }

    static fromJS(data: any): ExistsQueryDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new ExistsQueryDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["field"] = this.field;
        super.toJSON(data);
        return data; 
    }
}

/** 以某个字段是否存在为条件进行查询 */
export interface IExistsQueryDefinition extends IBaseQueryDefinition {
    type: string;
    /** 检查的对象字段名，必填 */
    field: string;
}

export class MatchQueryDefinition extends BaseQueryDefinition implements IMatchQueryDefinition {
    readonly type!: string;
    field!: string;
    query!: string;

    constructor(data?: IMatchQueryDefinition) {
        super(data);
        if (!data) {
            this.type = "match";
        }
        this._discriminator = "MatchQueryDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "match";
            this.field = _data["field"];
            this.query = _data["query"];
        }
    }

    static fromJS(data: any): MatchQueryDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new MatchQueryDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["field"] = this.field;
        data["query"] = this.query;
        super.toJSON(data);
        return data; 
    }
}

export interface IMatchQueryDefinition extends IBaseQueryDefinition {
    type: string;
    field: string;
    query: string;
}

export class NumericRangeQueryDefinition extends BaseQueryDefinition implements INumericRangeQueryDefinition {
    readonly type!: string;
    field!: string;
    gte!: number | undefined;
    gt!: number | undefined;
    lte!: number | undefined;
    lt!: number | undefined;
    relation!: string | undefined;

    constructor(data?: INumericRangeQueryDefinition) {
        super(data);
        if (!data) {
            this.type = "numeric_range";
        }
        this._discriminator = "NumericRangeQueryDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "numeric_range";
            this.field = _data["field"];
            this.gte = _data["gte"];
            this.gt = _data["gt"];
            this.lte = _data["lte"];
            this.lt = _data["lt"];
            this.relation = _data["relation"];
        }
    }

    static fromJS(data: any): NumericRangeQueryDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new NumericRangeQueryDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["field"] = this.field;
        data["gte"] = this.gte;
        data["gt"] = this.gt;
        data["lte"] = this.lte;
        data["lt"] = this.lt;
        data["relation"] = this.relation;
        super.toJSON(data);
        return data; 
    }
}

export interface INumericRangeQueryDefinition extends IBaseQueryDefinition {
    type: string;
    field: string;
    gte: number | undefined;
    gt: number | undefined;
    lte: number | undefined;
    lt: number | undefined;
    relation: string | undefined;
}

export class QueryStringQueryDefinition extends BaseQueryDefinition implements IQueryStringQueryDefinition {
    readonly type!: string;
    field!: string | undefined;
    query!: string;

    constructor(data?: IQueryStringQueryDefinition) {
        super(data);
        if (!data) {
            this.type = "query_string";
        }
        this._discriminator = "QueryStringQueryDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "query_string";
            this.field = _data["field"];
            this.query = _data["query"];
        }
    }

    static fromJS(data: any): QueryStringQueryDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new QueryStringQueryDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["field"] = this.field;
        data["query"] = this.query;
        super.toJSON(data);
        return data; 
    }
}

export interface IQueryStringQueryDefinition extends IBaseQueryDefinition {
    type: string;
    field: string | undefined;
    query: string;
}

export class ScriptedQueryDefinition extends BaseQueryDefinition implements IScriptedQueryDefinition {
    readonly type!: string;
    script!: string;
    params!: { [key: string]: any; } | undefined;

    constructor(data?: IScriptedQueryDefinition) {
        super(data);
        if (!data) {
            this.type = "scripted";
        }
        this._discriminator = "ScriptedQueryDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "scripted";
            this.script = _data["script"];
            if (_data["params"]) {
                this.params = {} as any;
                for (let key in _data["params"]) {
                    if (_data["params"].hasOwnProperty(key))
                        this.params![key] = _data["params"][key];
                }
            }
        }
    }

    static fromJS(data: any): ScriptedQueryDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new ScriptedQueryDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["script"] = this.script;
        if (this.params) {
            data["params"] = {};
            for (let key in this.params) {
                if (this.params.hasOwnProperty(key))
                    data["params"][key] = this.params[key];
            }
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IScriptedQueryDefinition extends IBaseQueryDefinition {
    type: string;
    script: string;
    params: { [key: string]: any; } | undefined;
}

export class TermQueryDefinition extends BaseQueryDefinition implements ITermQueryDefinition {
    readonly type!: string;
    /** 查询对象字段，必填 */
    field!: string;
    /** 用于查询的term（关键字） */
    value!: string;

    constructor(data?: ITermQueryDefinition) {
        super(data);
        if (!data) {
            this.type = "term";
        }
        this._discriminator = "TermQueryDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "term";
            this.field = _data["field"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): TermQueryDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new TermQueryDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["field"] = this.field;
        data["value"] = this.value;
        super.toJSON(data);
        return data; 
    }
}

export interface ITermQueryDefinition extends IBaseQueryDefinition {
    type: string;
    /** 查询对象字段，必填 */
    field: string;
    /** 用于查询的term（关键字） */
    value: string;
}

export class WildcardQueryDefinition extends BaseQueryDefinition implements IWildcardQueryDefinition {
    readonly type!: string;
    field!: string;
    value!: string;

    constructor(data?: IWildcardQueryDefinition) {
        super(data);
        if (!data) {
            this.type = "wildcard";
        }
        this._discriminator = "WildcardQueryDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "wildcard";
            this.field = _data["field"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): WildcardQueryDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new WildcardQueryDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["field"] = this.field;
        data["value"] = this.value;
        super.toJSON(data);
        return data; 
    }
}

export interface IWildcardQueryDefinition extends IBaseQueryDefinition {
    type: string;
    field: string;
    value: string;
}

export class AverageAggregationDefinition extends BaseMetricAggregationDefinition implements IAverageAggregationDefinition {
    readonly type!: string;
    field!: string;
    script!: string | undefined;
    params!: { [key: string]: any; } | undefined;
    missing_value!: number | undefined;
    name!: string;
    label!: string | undefined;

    constructor(data?: IAverageAggregationDefinition) {
        super(data);
        if (!data) {
            this.type = "avg";
        }
        this._discriminator = "AverageAggregationDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "avg";
            this.field = _data["field"];
            this.script = _data["script"];
            if (_data["params"]) {
                this.params = {} as any;
                for (let key in _data["params"]) {
                    if (_data["params"].hasOwnProperty(key))
                        this.params![key] = _data["params"][key];
                }
            }
            this.missing_value = _data["missing_value"];
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): AverageAggregationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new AverageAggregationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["field"] = this.field;
        data["script"] = this.script;
        if (this.params) {
            data["params"] = {};
            for (let key in this.params) {
                if (this.params.hasOwnProperty(key))
                    data["params"][key] = this.params[key];
            }
        }
        data["missing_value"] = this.missing_value;
        data["name"] = this.name;
        data["label"] = this.label;
        super.toJSON(data);
        return data; 
    }
}

export interface IAverageAggregationDefinition extends IBaseMetricAggregationDefinition {
    type: string;
    field: string;
    script: string | undefined;
    params: { [key: string]: any; } | undefined;
    missing_value: number | undefined;
    name: string;
    label: string | undefined;
}

export class CardinalityAggregationDefinition extends BaseMetricAggregationDefinition implements ICardinalityAggregationDefinition {
    readonly type!: string;
    field!: string;
    script!: string | undefined;
    params!: { [key: string]: any; } | undefined;
    precision_threshold!: number | undefined;
    name!: string;
    label!: string | undefined;

    constructor(data?: ICardinalityAggregationDefinition) {
        super(data);
        if (!data) {
            this.type = "cardinal";
        }
        this._discriminator = "CardinalityAggregationDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "cardinal";
            this.field = _data["field"];
            this.script = _data["script"];
            if (_data["params"]) {
                this.params = {} as any;
                for (let key in _data["params"]) {
                    if (_data["params"].hasOwnProperty(key))
                        this.params![key] = _data["params"][key];
                }
            }
            this.precision_threshold = _data["precision_threshold"];
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): CardinalityAggregationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new CardinalityAggregationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["field"] = this.field;
        data["script"] = this.script;
        if (this.params) {
            data["params"] = {};
            for (let key in this.params) {
                if (this.params.hasOwnProperty(key))
                    data["params"][key] = this.params[key];
            }
        }
        data["precision_threshold"] = this.precision_threshold;
        data["name"] = this.name;
        data["label"] = this.label;
        super.toJSON(data);
        return data; 
    }
}

export interface ICardinalityAggregationDefinition extends IBaseMetricAggregationDefinition {
    type: string;
    field: string;
    script: string | undefined;
    params: { [key: string]: any; } | undefined;
    precision_threshold: number | undefined;
    name: string;
    label: string | undefined;
}

export class CountAggregationDefinition extends BaseMetricAggregationDefinition implements ICountAggregationDefinition {
    readonly type!: string;
    name!: string;
    label!: string | undefined;

    constructor(data?: ICountAggregationDefinition) {
        super(data);
        if (!data) {
            this.type = "count";
        }
        this._discriminator = "CountAggregationDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "count";
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): CountAggregationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new CountAggregationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["name"] = this.name;
        data["label"] = this.label;
        super.toJSON(data);
        return data; 
    }
}

export interface ICountAggregationDefinition extends IBaseMetricAggregationDefinition {
    type: string;
    name: string;
    label: string | undefined;
}

export class ExtendedStatsAggregationDefinition extends BaseMetricAggregationDefinition implements IExtendedStatsAggregationDefinition {
    readonly type!: string;
    field!: string;
    script!: string | undefined;
    params!: { [key: string]: any; } | undefined;
    sigma!: number | undefined;
    missing_value!: number | undefined;
    name!: string;
    label!: string | undefined;

    constructor(data?: IExtendedStatsAggregationDefinition) {
        super(data);
        if (!data) {
            this.type = "ext_stats";
        }
        this._discriminator = "ExtendedStatsAggregationDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ext_stats";
            this.field = _data["field"];
            this.script = _data["script"];
            if (_data["params"]) {
                this.params = {} as any;
                for (let key in _data["params"]) {
                    if (_data["params"].hasOwnProperty(key))
                        this.params![key] = _data["params"][key];
                }
            }
            this.sigma = _data["sigma"];
            this.missing_value = _data["missing_value"];
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): ExtendedStatsAggregationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new ExtendedStatsAggregationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["field"] = this.field;
        data["script"] = this.script;
        if (this.params) {
            data["params"] = {};
            for (let key in this.params) {
                if (this.params.hasOwnProperty(key))
                    data["params"][key] = this.params[key];
            }
        }
        data["sigma"] = this.sigma;
        data["missing_value"] = this.missing_value;
        data["name"] = this.name;
        data["label"] = this.label;
        super.toJSON(data);
        return data; 
    }
}

export interface IExtendedStatsAggregationDefinition extends IBaseMetricAggregationDefinition {
    type: string;
    field: string;
    script: string | undefined;
    params: { [key: string]: any; } | undefined;
    sigma: number | undefined;
    missing_value: number | undefined;
    name: string;
    label: string | undefined;
}

export class MaxAggregationDefinition extends BaseMetricAggregationDefinition implements IMaxAggregationDefinition {
    readonly type!: string;
    field!: string;
    script!: string | undefined;
    params!: { [key: string]: any; } | undefined;
    missing_value!: number | undefined;
    name!: string;
    label!: string | undefined;

    constructor(data?: IMaxAggregationDefinition) {
        super(data);
        if (!data) {
            this.type = "max";
        }
        this._discriminator = "MaxAggregationDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "max";
            this.field = _data["field"];
            this.script = _data["script"];
            if (_data["params"]) {
                this.params = {} as any;
                for (let key in _data["params"]) {
                    if (_data["params"].hasOwnProperty(key))
                        this.params![key] = _data["params"][key];
                }
            }
            this.missing_value = _data["missing_value"];
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): MaxAggregationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new MaxAggregationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["field"] = this.field;
        data["script"] = this.script;
        if (this.params) {
            data["params"] = {};
            for (let key in this.params) {
                if (this.params.hasOwnProperty(key))
                    data["params"][key] = this.params[key];
            }
        }
        data["missing_value"] = this.missing_value;
        data["name"] = this.name;
        data["label"] = this.label;
        super.toJSON(data);
        return data; 
    }
}

export interface IMaxAggregationDefinition extends IBaseMetricAggregationDefinition {
    type: string;
    field: string;
    script: string | undefined;
    params: { [key: string]: any; } | undefined;
    missing_value: number | undefined;
    name: string;
    label: string | undefined;
}

export class MedianAbsoluteDeviationAggregationDefinition extends BaseMetricAggregationDefinition implements IMedianAbsoluteDeviationAggregationDefinition {
    readonly type!: string;
    field!: string;
    script!: string | undefined;
    params!: { [key: string]: any; } | undefined;
    missing_value!: number | undefined;
    name!: string;
    label!: string | undefined;

    constructor(data?: IMedianAbsoluteDeviationAggregationDefinition) {
        super(data);
        if (!data) {
            this.type = "med_abs_dev";
        }
        this._discriminator = "MedianAbsoluteDeviationAggregationDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "med_abs_dev";
            this.field = _data["field"];
            this.script = _data["script"];
            if (_data["params"]) {
                this.params = {} as any;
                for (let key in _data["params"]) {
                    if (_data["params"].hasOwnProperty(key))
                        this.params![key] = _data["params"][key];
                }
            }
            this.missing_value = _data["missing_value"];
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): MedianAbsoluteDeviationAggregationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new MedianAbsoluteDeviationAggregationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["field"] = this.field;
        data["script"] = this.script;
        if (this.params) {
            data["params"] = {};
            for (let key in this.params) {
                if (this.params.hasOwnProperty(key))
                    data["params"][key] = this.params[key];
            }
        }
        data["missing_value"] = this.missing_value;
        data["name"] = this.name;
        data["label"] = this.label;
        super.toJSON(data);
        return data; 
    }
}

export interface IMedianAbsoluteDeviationAggregationDefinition extends IBaseMetricAggregationDefinition {
    type: string;
    field: string;
    script: string | undefined;
    params: { [key: string]: any; } | undefined;
    missing_value: number | undefined;
    name: string;
    label: string | undefined;
}

export class MinAggregationDefinition extends BaseMetricAggregationDefinition implements IMinAggregationDefinition {
    readonly type!: string;
    field!: string;
    script!: string | undefined;
    params!: { [key: string]: any; } | undefined;
    missing_value!: number | undefined;
    name!: string;
    label!: string | undefined;

    constructor(data?: IMinAggregationDefinition) {
        super(data);
        if (!data) {
            this.type = "min";
        }
        this._discriminator = "MinAggregationDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "min";
            this.field = _data["field"];
            this.script = _data["script"];
            if (_data["params"]) {
                this.params = {} as any;
                for (let key in _data["params"]) {
                    if (_data["params"].hasOwnProperty(key))
                        this.params![key] = _data["params"][key];
                }
            }
            this.missing_value = _data["missing_value"];
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): MinAggregationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new MinAggregationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["field"] = this.field;
        data["script"] = this.script;
        if (this.params) {
            data["params"] = {};
            for (let key in this.params) {
                if (this.params.hasOwnProperty(key))
                    data["params"][key] = this.params[key];
            }
        }
        data["missing_value"] = this.missing_value;
        data["name"] = this.name;
        data["label"] = this.label;
        super.toJSON(data);
        return data; 
    }
}

export interface IMinAggregationDefinition extends IBaseMetricAggregationDefinition {
    type: string;
    field: string;
    script: string | undefined;
    params: { [key: string]: any; } | undefined;
    missing_value: number | undefined;
    name: string;
    label: string | undefined;
}

export class PercentileRanksAggregationDefinition extends BaseMetricAggregationDefinition implements IPercentileRanksAggregationDefinition {
    readonly type!: string;
    field!: string;
    values!: number[];
    script!: string | undefined;
    params!: { [key: string]: any; } | undefined;
    missing_value!: number | undefined;
    name!: string;
    label!: string | undefined;

    constructor(data?: IPercentileRanksAggregationDefinition) {
        super(data);
        if (!data) {
            this.type = "percentile_ranks";
            this.values = [];
        }
        this._discriminator = "PercentileRanksAggregationDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "percentile_ranks";
            this.field = _data["field"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
            this.script = _data["script"];
            if (_data["params"]) {
                this.params = {} as any;
                for (let key in _data["params"]) {
                    if (_data["params"].hasOwnProperty(key))
                        this.params![key] = _data["params"][key];
                }
            }
            this.missing_value = _data["missing_value"];
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): PercentileRanksAggregationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new PercentileRanksAggregationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["field"] = this.field;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        data["script"] = this.script;
        if (this.params) {
            data["params"] = {};
            for (let key in this.params) {
                if (this.params.hasOwnProperty(key))
                    data["params"][key] = this.params[key];
            }
        }
        data["missing_value"] = this.missing_value;
        data["name"] = this.name;
        data["label"] = this.label;
        super.toJSON(data);
        return data; 
    }
}

export interface IPercentileRanksAggregationDefinition extends IBaseMetricAggregationDefinition {
    type: string;
    field: string;
    values: number[];
    script: string | undefined;
    params: { [key: string]: any; } | undefined;
    missing_value: number | undefined;
    name: string;
    label: string | undefined;
}

export class PercentilesAggregationDefinition extends BaseMetricAggregationDefinition implements IPercentilesAggregationDefinition {
    readonly type!: string;
    field!: string;
    percents!: number[];
    script!: string | undefined;
    params!: { [key: string]: any; } | undefined;
    missing_value!: number | undefined;
    name!: string;
    label!: string | undefined;

    constructor(data?: IPercentilesAggregationDefinition) {
        super(data);
        if (!data) {
            this.type = "percentiles";
            this.percents = [];
        }
        this._discriminator = "PercentilesAggregationDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "percentiles";
            this.field = _data["field"];
            if (Array.isArray(_data["percents"])) {
                this.percents = [] as any;
                for (let item of _data["percents"])
                    this.percents!.push(item);
            }
            this.script = _data["script"];
            if (_data["params"]) {
                this.params = {} as any;
                for (let key in _data["params"]) {
                    if (_data["params"].hasOwnProperty(key))
                        this.params![key] = _data["params"][key];
                }
            }
            this.missing_value = _data["missing_value"];
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): PercentilesAggregationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new PercentilesAggregationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["field"] = this.field;
        if (Array.isArray(this.percents)) {
            data["percents"] = [];
            for (let item of this.percents)
                data["percents"].push(item);
        }
        data["script"] = this.script;
        if (this.params) {
            data["params"] = {};
            for (let key in this.params) {
                if (this.params.hasOwnProperty(key))
                    data["params"][key] = this.params[key];
            }
        }
        data["missing_value"] = this.missing_value;
        data["name"] = this.name;
        data["label"] = this.label;
        super.toJSON(data);
        return data; 
    }
}

export interface IPercentilesAggregationDefinition extends IBaseMetricAggregationDefinition {
    type: string;
    field: string;
    percents: number[];
    script: string | undefined;
    params: { [key: string]: any; } | undefined;
    missing_value: number | undefined;
    name: string;
    label: string | undefined;
}

export class ScriptedMetricAggregationDefinition extends BaseMetricAggregationDefinition implements IScriptedMetricAggregationDefinition {
    readonly type!: string;
    init_script!: string | undefined;
    combine_script!: string | undefined;
    map_script!: string | undefined;
    reduce_script!: string | undefined;
    params!: { [key: string]: any; } | undefined;
    name!: string;
    label!: string | undefined;

    constructor(data?: IScriptedMetricAggregationDefinition) {
        super(data);
        if (!data) {
            this.type = "scripted_metric";
        }
        this._discriminator = "ScriptedMetricAggregationDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "scripted_metric";
            this.init_script = _data["init_script"];
            this.combine_script = _data["combine_script"];
            this.map_script = _data["map_script"];
            this.reduce_script = _data["reduce_script"];
            if (_data["params"]) {
                this.params = {} as any;
                for (let key in _data["params"]) {
                    if (_data["params"].hasOwnProperty(key))
                        this.params![key] = _data["params"][key];
                }
            }
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): ScriptedMetricAggregationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new ScriptedMetricAggregationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["init_script"] = this.init_script;
        data["combine_script"] = this.combine_script;
        data["map_script"] = this.map_script;
        data["reduce_script"] = this.reduce_script;
        if (this.params) {
            data["params"] = {};
            for (let key in this.params) {
                if (this.params.hasOwnProperty(key))
                    data["params"][key] = this.params[key];
            }
        }
        data["name"] = this.name;
        data["label"] = this.label;
        super.toJSON(data);
        return data; 
    }
}

export interface IScriptedMetricAggregationDefinition extends IBaseMetricAggregationDefinition {
    type: string;
    init_script: string | undefined;
    combine_script: string | undefined;
    map_script: string | undefined;
    reduce_script: string | undefined;
    params: { [key: string]: any; } | undefined;
    name: string;
    label: string | undefined;
}

export class StatsAggregationDefinition extends BaseMetricAggregationDefinition implements IStatsAggregationDefinition {
    readonly type!: string;
    field!: string;
    script!: string | undefined;
    params!: { [key: string]: any; } | undefined;
    missing_value!: number | undefined;
    name!: string;
    label!: string | undefined;

    constructor(data?: IStatsAggregationDefinition) {
        super(data);
        if (!data) {
            this.type = "stats";
        }
        this._discriminator = "StatsAggregationDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "stats";
            this.field = _data["field"];
            this.script = _data["script"];
            if (_data["params"]) {
                this.params = {} as any;
                for (let key in _data["params"]) {
                    if (_data["params"].hasOwnProperty(key))
                        this.params![key] = _data["params"][key];
                }
            }
            this.missing_value = _data["missing_value"];
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): StatsAggregationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new StatsAggregationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["field"] = this.field;
        data["script"] = this.script;
        if (this.params) {
            data["params"] = {};
            for (let key in this.params) {
                if (this.params.hasOwnProperty(key))
                    data["params"][key] = this.params[key];
            }
        }
        data["missing_value"] = this.missing_value;
        data["name"] = this.name;
        data["label"] = this.label;
        super.toJSON(data);
        return data; 
    }
}

export interface IStatsAggregationDefinition extends IBaseMetricAggregationDefinition {
    type: string;
    field: string;
    script: string | undefined;
    params: { [key: string]: any; } | undefined;
    missing_value: number | undefined;
    name: string;
    label: string | undefined;
}

export class SumAggregationDefinition extends BaseMetricAggregationDefinition implements ISumAggregationDefinition {
    readonly type!: string;
    field!: string;
    script!: string | undefined;
    params!: { [key: string]: any; } | undefined;
    missing_value!: number | undefined;
    name!: string;
    label!: string | undefined;

    constructor(data?: ISumAggregationDefinition) {
        super(data);
        if (!data) {
            this.type = "sum";
        }
        this._discriminator = "SumAggregationDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "sum";
            this.field = _data["field"];
            this.script = _data["script"];
            if (_data["params"]) {
                this.params = {} as any;
                for (let key in _data["params"]) {
                    if (_data["params"].hasOwnProperty(key))
                        this.params![key] = _data["params"][key];
                }
            }
            this.missing_value = _data["missing_value"];
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): SumAggregationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new SumAggregationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["field"] = this.field;
        data["script"] = this.script;
        if (this.params) {
            data["params"] = {};
            for (let key in this.params) {
                if (this.params.hasOwnProperty(key))
                    data["params"][key] = this.params[key];
            }
        }
        data["missing_value"] = this.missing_value;
        data["name"] = this.name;
        data["label"] = this.label;
        super.toJSON(data);
        return data; 
    }
}

export interface ISumAggregationDefinition extends IBaseMetricAggregationDefinition {
    type: string;
    field: string;
    script: string | undefined;
    params: { [key: string]: any; } | undefined;
    missing_value: number | undefined;
    name: string;
    label: string | undefined;
}

export class DateHistogramAggregationDefinition extends BaseBucketAggregationDefinition implements IDateHistogramAggregationDefinition {
    readonly type!: string;
    field!: string;
    calendar_interval!: string | undefined;
    fixed_interval!: string | undefined;
    time_zone!: string | undefined;
    offset!: string | undefined;
    format!: string | undefined;
    min_doc_count!: number | undefined;
    min_ext_bounds!: string | undefined;
    max_ext_bounds!: string | undefined;
    script!: string | undefined;
    params!: { [key: string]: any; } | undefined;
    missing_value!: string | undefined;
    name!: string;
    label!: string | undefined;

    constructor(data?: IDateHistogramAggregationDefinition) {
        super(data);
        if (!data) {
            this.type = "date_histogram";
        }
        this._discriminator = "DateHistogramAggregationDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "date_histogram";
            this.field = _data["field"];
            this.calendar_interval = _data["calendar_interval"];
            this.fixed_interval = _data["fixed_interval"];
            this.time_zone = _data["time_zone"];
            this.offset = _data["offset"];
            this.format = _data["format"];
            this.min_doc_count = _data["min_doc_count"];
            this.min_ext_bounds = _data["min_ext_bounds"];
            this.max_ext_bounds = _data["max_ext_bounds"];
            this.script = _data["script"];
            if (_data["params"]) {
                this.params = {} as any;
                for (let key in _data["params"]) {
                    if (_data["params"].hasOwnProperty(key))
                        this.params![key] = _data["params"][key];
                }
            }
            this.missing_value = _data["missing_value"];
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): DateHistogramAggregationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new DateHistogramAggregationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["field"] = this.field;
        data["calendar_interval"] = this.calendar_interval;
        data["fixed_interval"] = this.fixed_interval;
        data["time_zone"] = this.time_zone;
        data["offset"] = this.offset;
        data["format"] = this.format;
        data["min_doc_count"] = this.min_doc_count;
        data["min_ext_bounds"] = this.min_ext_bounds;
        data["max_ext_bounds"] = this.max_ext_bounds;
        data["script"] = this.script;
        if (this.params) {
            data["params"] = {};
            for (let key in this.params) {
                if (this.params.hasOwnProperty(key))
                    data["params"][key] = this.params[key];
            }
        }
        data["missing_value"] = this.missing_value;
        data["name"] = this.name;
        data["label"] = this.label;
        super.toJSON(data);
        return data; 
    }
}

export interface IDateHistogramAggregationDefinition extends IBaseBucketAggregationDefinition {
    type: string;
    field: string;
    calendar_interval: string | undefined;
    fixed_interval: string | undefined;
    time_zone: string | undefined;
    offset: string | undefined;
    format: string | undefined;
    min_doc_count: number | undefined;
    min_ext_bounds: string | undefined;
    max_ext_bounds: string | undefined;
    script: string | undefined;
    params: { [key: string]: any; } | undefined;
    missing_value: string | undefined;
    name: string;
    label: string | undefined;
}

export class FiltersAggregationDefinition extends BaseBucketAggregationDefinition implements IFiltersAggregationDefinition {
    readonly type!: string;
    other_bucket!: boolean | undefined;
    other_bucket_key!: string | undefined;
    query_string_filters!: { [key: string]: string; } | undefined;
    named_filters!: { [key: string]: BaseQueryDefinition; } | undefined;
    name!: string;
    label!: string | undefined;

    constructor(data?: IFiltersAggregationDefinition) {
        super(data);
        if (!data) {
            this.type = "filters";
        }
        this._discriminator = "FiltersAggregationDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "filters";
            this.other_bucket = _data["other_bucket"];
            this.other_bucket_key = _data["other_bucket_key"];
            if (_data["query_string_filters"]) {
                this.query_string_filters = {} as any;
                for (let key in _data["query_string_filters"]) {
                    if (_data["query_string_filters"].hasOwnProperty(key))
                        this.query_string_filters![key] = _data["query_string_filters"][key];
                }
            }
            if (_data["named_filters"]) {
                this.named_filters = {} as any;
                for (let key in _data["named_filters"]) {
                    if (_data["named_filters"].hasOwnProperty(key))
                        this.named_filters![key] = _data["named_filters"][key] ? BaseQueryDefinition.fromJS(_data["named_filters"][key]) : new BaseQueryDefinition();
                }
            }
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): FiltersAggregationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new FiltersAggregationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["other_bucket"] = this.other_bucket;
        data["other_bucket_key"] = this.other_bucket_key;
        if (this.query_string_filters) {
            data["query_string_filters"] = {};
            for (let key in this.query_string_filters) {
                if (this.query_string_filters.hasOwnProperty(key))
                    data["query_string_filters"][key] = this.query_string_filters[key];
            }
        }
        if (this.named_filters) {
            data["named_filters"] = {};
            for (let key in this.named_filters) {
                if (this.named_filters.hasOwnProperty(key))
                    data["named_filters"][key] = this.named_filters[key] ? this.named_filters[key].toJSON() : <any>undefined;
            }
        }
        data["name"] = this.name;
        data["label"] = this.label;
        super.toJSON(data);
        return data; 
    }
}

export interface IFiltersAggregationDefinition extends IBaseBucketAggregationDefinition {
    type: string;
    other_bucket: boolean | undefined;
    other_bucket_key: string | undefined;
    query_string_filters: { [key: string]: string; } | undefined;
    named_filters: { [key: string]: BaseQueryDefinition; } | undefined;
    name: string;
    label: string | undefined;
}

export class HistogramAggregationDefinition extends BaseBucketAggregationDefinition implements IHistogramAggregationDefinition {
    readonly type!: string;
    field!: string;
    interval!: number | undefined;
    offset!: number | undefined;
    min_doc_count!: number | undefined;
    min_ext_bounds!: number | undefined;
    max_ext_bounds!: number | undefined;
    script!: string | undefined;
    params!: { [key: string]: any; } | undefined;
    missing_value!: number | undefined;
    name!: string;
    label!: string | undefined;

    constructor(data?: IHistogramAggregationDefinition) {
        super(data);
        if (!data) {
            this.type = "histogram";
        }
        this._discriminator = "HistogramAggregationDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "histogram";
            this.field = _data["field"];
            this.interval = _data["interval"];
            this.offset = _data["offset"];
            this.min_doc_count = _data["min_doc_count"];
            this.min_ext_bounds = _data["min_ext_bounds"];
            this.max_ext_bounds = _data["max_ext_bounds"];
            this.script = _data["script"];
            if (_data["params"]) {
                this.params = {} as any;
                for (let key in _data["params"]) {
                    if (_data["params"].hasOwnProperty(key))
                        this.params![key] = _data["params"][key];
                }
            }
            this.missing_value = _data["missing_value"];
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): HistogramAggregationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new HistogramAggregationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["field"] = this.field;
        data["interval"] = this.interval;
        data["offset"] = this.offset;
        data["min_doc_count"] = this.min_doc_count;
        data["min_ext_bounds"] = this.min_ext_bounds;
        data["max_ext_bounds"] = this.max_ext_bounds;
        data["script"] = this.script;
        if (this.params) {
            data["params"] = {};
            for (let key in this.params) {
                if (this.params.hasOwnProperty(key))
                    data["params"][key] = this.params[key];
            }
        }
        data["missing_value"] = this.missing_value;
        data["name"] = this.name;
        data["label"] = this.label;
        super.toJSON(data);
        return data; 
    }
}

export interface IHistogramAggregationDefinition extends IBaseBucketAggregationDefinition {
    type: string;
    field: string;
    interval: number | undefined;
    offset: number | undefined;
    min_doc_count: number | undefined;
    min_ext_bounds: number | undefined;
    max_ext_bounds: number | undefined;
    script: string | undefined;
    params: { [key: string]: any; } | undefined;
    missing_value: number | undefined;
    name: string;
    label: string | undefined;
}

export class IpRangeDefinition implements IIpRangeDefinition {
    /** 虽然目前Elasticsearch支持为每个IpRange设定独立的key名，
但NEST接口目前还不支持，因此本字段目前会被忽略 */
    from!: string | undefined;
    to!: string | undefined;
    mask!: string | undefined;

    constructor(data?: IIpRangeDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.from = _data["from"];
            this.to = _data["to"];
            this.mask = _data["mask"];
        }
    }

    static fromJS(data: any): IpRangeDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new IpRangeDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from;
        data["to"] = this.to;
        data["mask"] = this.mask;
        return data; 
    }
}

export interface IIpRangeDefinition {
    /** 虽然目前Elasticsearch支持为每个IpRange设定独立的key名，
但NEST接口目前还不支持，因此本字段目前会被忽略 */
    from: string | undefined;
    to: string | undefined;
    mask: string | undefined;
}

export class IpRangeAggregationDefinition extends BaseBucketAggregationDefinition implements IIpRangeAggregationDefinition {
    readonly type!: string;
    field!: string;
    ranges!: IpRangeDefinition[];
    name!: string;
    label!: string | undefined;

    constructor(data?: IIpRangeAggregationDefinition) {
        super(data);
        if (!data) {
            this.type = "ip_range";
            this.ranges = [];
        }
        this._discriminator = "IpRangeAggregationDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "ip_range";
            this.field = _data["field"];
            if (Array.isArray(_data["ranges"])) {
                this.ranges = [] as any;
                for (let item of _data["ranges"])
                    this.ranges!.push(IpRangeDefinition.fromJS(item));
            }
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): IpRangeAggregationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new IpRangeAggregationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["field"] = this.field;
        if (Array.isArray(this.ranges)) {
            data["ranges"] = [];
            for (let item of this.ranges)
                data["ranges"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["label"] = this.label;
        super.toJSON(data);
        return data; 
    }
}

export interface IIpRangeAggregationDefinition extends IBaseBucketAggregationDefinition {
    type: string;
    field: string;
    ranges: IpRangeDefinition[];
    name: string;
    label: string | undefined;
}

export class NumericRangeDefinition implements INumericRangeDefinition {
    /** 虽然目前Elasticsearch支持为每个Range设定独立的key名，
但NEST接口目前还不支持，因此本字段目前会被忽略 */
    key!: string | undefined;
    from!: number | undefined;
    to!: number | undefined;

    constructor(data?: INumericRangeDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.from = _data["from"];
            this.to = _data["to"];
        }
    }

    static fromJS(data: any): NumericRangeDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new NumericRangeDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["from"] = this.from;
        data["to"] = this.to;
        return data; 
    }
}

export interface INumericRangeDefinition {
    /** 虽然目前Elasticsearch支持为每个Range设定独立的key名，
但NEST接口目前还不支持，因此本字段目前会被忽略 */
    key: string | undefined;
    from: number | undefined;
    to: number | undefined;
}

export class RangeAggregationDefinition extends BaseBucketAggregationDefinition implements IRangeAggregationDefinition {
    readonly type!: string;
    field!: string;
    ranges!: NumericRangeDefinition[];
    name!: string;
    label!: string | undefined;

    constructor(data?: IRangeAggregationDefinition) {
        super(data);
        if (!data) {
            this.type = "numeric_range";
            this.ranges = [];
        }
        this._discriminator = "RangeAggregationDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "numeric_range";
            this.field = _data["field"];
            if (Array.isArray(_data["ranges"])) {
                this.ranges = [] as any;
                for (let item of _data["ranges"])
                    this.ranges!.push(NumericRangeDefinition.fromJS(item));
            }
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): RangeAggregationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new RangeAggregationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["field"] = this.field;
        if (Array.isArray(this.ranges)) {
            data["ranges"] = [];
            for (let item of this.ranges)
                data["ranges"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["label"] = this.label;
        super.toJSON(data);
        return data; 
    }
}

export interface IRangeAggregationDefinition extends IBaseBucketAggregationDefinition {
    type: string;
    field: string;
    ranges: NumericRangeDefinition[];
    name: string;
    label: string | undefined;
}

export class TermsOrderDefinition implements ITermsOrderDefinition {
    key!: string;
    order!: string | undefined;

    constructor(data?: ITermsOrderDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): TermsOrderDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new TermsOrderDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["order"] = this.order;
        return data; 
    }
}

export interface ITermsOrderDefinition {
    key: string;
    order: string | undefined;
}

export class TermsAggregationDefinition extends BaseBucketAggregationDefinition implements ITermsAggregationDefinition {
    readonly type!: string;
    field!: string;
    min_doc_count!: number | undefined;
    missing_value!: string | undefined;
    script!: string | undefined;
    params!: { [key: string]: any; } | undefined;
    size!: number | undefined;
    order_by_key!: string | undefined;
    order_direction!: string | undefined;
    sort_orders!: TermsOrderDefinition[] | undefined;
    name!: string;
    label!: string | undefined;

    constructor(data?: ITermsAggregationDefinition) {
        super(data);
        if (!data) {
            this.type = "terms";
        }
        this._discriminator = "TermsAggregationDefinition";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "terms";
            this.field = _data["field"];
            this.min_doc_count = _data["min_doc_count"];
            this.missing_value = _data["missing_value"];
            this.script = _data["script"];
            if (_data["params"]) {
                this.params = {} as any;
                for (let key in _data["params"]) {
                    if (_data["params"].hasOwnProperty(key))
                        this.params![key] = _data["params"][key];
                }
            }
            this.size = _data["size"];
            this.order_by_key = _data["order_by_key"];
            this.order_direction = _data["order_direction"];
            if (Array.isArray(_data["sort_orders"])) {
                this.sort_orders = [] as any;
                for (let item of _data["sort_orders"])
                    this.sort_orders!.push(TermsOrderDefinition.fromJS(item));
            }
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): TermsAggregationDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new TermsAggregationDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["field"] = this.field;
        data["min_doc_count"] = this.min_doc_count;
        data["missing_value"] = this.missing_value;
        data["script"] = this.script;
        if (this.params) {
            data["params"] = {};
            for (let key in this.params) {
                if (this.params.hasOwnProperty(key))
                    data["params"][key] = this.params[key];
            }
        }
        data["size"] = this.size;
        data["order_by_key"] = this.order_by_key;
        data["order_direction"] = this.order_direction;
        if (Array.isArray(this.sort_orders)) {
            data["sort_orders"] = [];
            for (let item of this.sort_orders)
                data["sort_orders"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["label"] = this.label;
        super.toJSON(data);
        return data; 
    }
}

export interface ITermsAggregationDefinition extends IBaseBucketAggregationDefinition {
    type: string;
    field: string;
    min_doc_count: number | undefined;
    missing_value: string | undefined;
    script: string | undefined;
    params: { [key: string]: any; } | undefined;
    size: number | undefined;
    order_by_key: string | undefined;
    order_direction: string | undefined;
    sort_orders: TermsOrderDefinition[] | undefined;
    name: string;
    label: string | undefined;
}

/** type字段为numberInput */
export class NumberInputFormConfiguration extends BaseFormConfiguration implements INumberInputFormConfiguration {
    readonly type!: string;
    placeholder!: string | undefined;
    value!: number;
    key!: string | undefined;
    label!: string | undefined;
    required!: boolean;

    constructor(data?: INumberInputFormConfiguration) {
        super(data);
        if (!data) {
            this.type = "numberInput";
        }
        this._discriminator = "NumberInputFormConfiguration";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "numberInput";
            this.placeholder = _data["placeholder"];
            this.value = _data["value"];
            this.key = _data["key"];
            this.label = _data["label"];
            this.required = _data["required"];
        }
    }

    static fromJS(data: any): NumberInputFormConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new NumberInputFormConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["placeholder"] = this.placeholder;
        data["value"] = this.value;
        data["key"] = this.key;
        data["label"] = this.label;
        data["required"] = this.required;
        super.toJSON(data);
        return data; 
    }
}

/** type字段为numberInput */
export interface INumberInputFormConfiguration extends IBaseFormConfiguration {
    type: string;
    placeholder: string | undefined;
    value: number;
    key: string | undefined;
    label: string | undefined;
    required: boolean;
}

export class Option implements IOption {
    label!: string | undefined;
    value!: string | undefined;

    constructor(data?: IOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Option {
        data = typeof data === 'object' ? data : {};
        let result = new Option();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }
}

export interface IOption {
    label: string | undefined;
    value: string | undefined;
}

/** type字段为radioGroup */
export class RadioGroupFormConfiguration extends BaseFormConfiguration implements IRadioGroupFormConfiguration {
    readonly type!: string;
    placeholder!: string | undefined;
    options!: Option[] | undefined;
    value!: string | undefined;
    key!: string | undefined;
    label!: string | undefined;
    required!: boolean;

    constructor(data?: IRadioGroupFormConfiguration) {
        super(data);
        if (!data) {
            this.type = "radioGroup";
        }
        this._discriminator = "RadioGroupFormConfiguration";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "radioGroup";
            this.placeholder = _data["placeholder"];
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(Option.fromJS(item));
            }
            this.value = _data["value"];
            this.key = _data["key"];
            this.label = _data["label"];
            this.required = _data["required"];
        }
    }

    static fromJS(data: any): RadioGroupFormConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new RadioGroupFormConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["placeholder"] = this.placeholder;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        data["value"] = this.value;
        data["key"] = this.key;
        data["label"] = this.label;
        data["required"] = this.required;
        super.toJSON(data);
        return data; 
    }
}

/** type字段为radioGroup */
export interface IRadioGroupFormConfiguration extends IBaseFormConfiguration {
    type: string;
    placeholder: string | undefined;
    options: Option[] | undefined;
    value: string | undefined;
    key: string | undefined;
    label: string | undefined;
    required: boolean;
}

/** type字段为selector */
export class SelectorFormConfiguration extends BaseFormConfiguration implements ISelectorFormConfiguration {
    readonly type!: string;
    mode!: string | undefined;
    options!: Option[] | undefined;
    value!: string[] | undefined;
    key!: string | undefined;
    label!: string | undefined;
    required!: boolean;

    constructor(data?: ISelectorFormConfiguration) {
        super(data);
        if (!data) {
            this.type = "selector";
        }
        this._discriminator = "SelectorFormConfiguration";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "selector";
            this.mode = _data["mode"];
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(Option.fromJS(item));
            }
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
            this.key = _data["key"];
            this.label = _data["label"];
            this.required = _data["required"];
        }
    }

    static fromJS(data: any): SelectorFormConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new SelectorFormConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["mode"] = this.mode;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["key"] = this.key;
        data["label"] = this.label;
        data["required"] = this.required;
        super.toJSON(data);
        return data; 
    }
}

/** type字段为selector */
export interface ISelectorFormConfiguration extends IBaseFormConfiguration {
    type: string;
    mode: string | undefined;
    options: Option[] | undefined;
    value: string[] | undefined;
    key: string | undefined;
    label: string | undefined;
    required: boolean;
}

/** type字段为switch */
export class SwitchFormConfiguration extends BaseFormConfiguration implements ISwitchFormConfiguration {
    readonly type!: string;
    value!: boolean;
    key!: string | undefined;
    label!: string | undefined;
    required!: boolean;

    constructor(data?: ISwitchFormConfiguration) {
        super(data);
        if (!data) {
            this.type = "switch";
        }
        this._discriminator = "SwitchFormConfiguration";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "switch";
            this.value = _data["value"];
            this.key = _data["key"];
            this.label = _data["label"];
            this.required = _data["required"];
        }
    }

    static fromJS(data: any): SwitchFormConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchFormConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["value"] = this.value;
        data["key"] = this.key;
        data["label"] = this.label;
        data["required"] = this.required;
        super.toJSON(data);
        return data; 
    }
}

/** type字段为switch */
export interface ISwitchFormConfiguration extends IBaseFormConfiguration {
    type: string;
    value: boolean;
    key: string | undefined;
    label: string | undefined;
    required: boolean;
}

export class TextareaFormConfiguration extends BaseFormConfiguration implements ITextareaFormConfiguration {
    readonly type!: string;
    placeholder!: string | undefined;
    key!: string | undefined;
    label!: string | undefined;
    required!: boolean;

    constructor(data?: ITextareaFormConfiguration) {
        super(data);
        if (!data) {
            this.type = "textarea";
        }
        this._discriminator = "TextareaFormConfiguration";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "textarea";
            this.placeholder = _data["placeholder"];
            this.key = _data["key"];
            this.label = _data["label"];
            this.required = _data["required"];
        }
    }

    static fromJS(data: any): TextareaFormConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new TextareaFormConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["placeholder"] = this.placeholder;
        data["key"] = this.key;
        data["label"] = this.label;
        data["required"] = this.required;
        super.toJSON(data);
        return data; 
    }
}

export interface ITextareaFormConfiguration extends IBaseFormConfiguration {
    type: string;
    placeholder: string | undefined;
    key: string | undefined;
    label: string | undefined;
    required: boolean;
}

/** type字段为text、textarea */
export class TextFormConfiguration extends BaseFormConfiguration implements ITextFormConfiguration {
    readonly type!: string;
    placeholder!: string | undefined;
    key!: string | undefined;
    label!: string | undefined;
    required!: boolean;

    constructor(data?: ITextFormConfiguration) {
        super(data);
        if (!data) {
            this.type = "text";
        }
        this._discriminator = "TextFormConfiguration";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : "text";
            this.placeholder = _data["placeholder"];
            this.key = _data["key"];
            this.label = _data["label"];
            this.required = _data["required"];
        }
    }

    static fromJS(data: any): TextFormConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new TextFormConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["placeholder"] = this.placeholder;
        data["key"] = this.key;
        data["label"] = this.label;
        data["required"] = this.required;
        super.toJSON(data);
        return data; 
    }
}

/** type字段为text、textarea */
export interface ITextFormConfiguration extends IBaseFormConfiguration {
    type: string;
    placeholder: string | undefined;
    key: string | undefined;
    label: string | undefined;
    required: boolean;
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}